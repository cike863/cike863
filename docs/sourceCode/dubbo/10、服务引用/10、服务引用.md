# 本地引用

## 1. 概述

Dubbo 服务引用，**和 Dubbo 服务暴露一样**，**也**有两种方式：

- 本地引用，JVM 本地调用。配置如下：

  ```
  // 推荐
  <dubbo:service scope="local" />
  // 不推荐使用，准备废弃
  <dubbo:service injvm="true" />
  ```

- 远程暴露，网络远程通信。配置如下：

  ```
  <dubbo:service scope="remote" />
  ```

我们知道 Dubbo 提供了多种协议( Protocol )实现。

- **本文**仅分享本地引用，该方式仅使用 Injvm 协议实现，具体代码在 `dubbo-rpc-injvm` 模块中。
- **下几篇**会分享远程引用，该方式有多种协议实现，例如 Dubbo ( 默认协议 )、Hessian 、Rest 等等。我们会每个协议对应一篇文章，进行分享。

## 2. createProxy

本地引用服务的顺序图如下：

[![本地引用顺序图](http://static.iocoder.cn/images/Dubbo/2018_05_01/02.png)](http://static.iocoder.cn/images/Dubbo/2018_05_01/02.png)本地引用顺序图

在 [《精尽 Dubbo 源码分析 —— API 配置（三）之服务消费者》](http://svip.iocoder.cn/Dubbo/configuration-api-3/?self) 一文中，我们看到 `ReferenceConfig#init()` 方法中，会在配置初始化完成后，调用顺序图的**起点** `#createProxy(map)` 方法，开始引用服务。代码如下：

```
/**
 * 自适应 Protocol 实现对象
 */
private static final Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
/**
 * 自适应 ProxyFactory 实现对象
 */
private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
    
/**
 * 直连服务提供者地址
 */
// url for peer-to-peer invocation
private String url;

  1: private T createProxy(Map<String, String> map) {
  2:     URL tmpUrl = new URL("temp", "localhost", 0, map);
  3:     // 是否本地引用
  4:     final boolean isJvmRefer;
  5:     // injvm 属性为空，不通过该属性判断
  6:     if (isInjvm() == null) {
  7:         // 直连服务提供者，参见文档《直连提供者》http://dubbo.apache.org/zh-cn/docs/user/demos/explicit-target.html
  8:         if (url != null && url.length() > 0) { // if a url is specified, don't do local reference
  9:             isJvmRefer = false;
 10:         // 通过 `tmpUrl` 判断，是否需要本地引用
 11:         } else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) {
 12:             // by default, reference local service if there is
 13:             isJvmRefer = true;
 14:         // 默认不是
 15:         } else {
 16:             isJvmRefer = false;
 17:         }
 18:     // 通过 injvm 属性。
 19:     } else {
 20:         isJvmRefer = isInjvm();
 21:     }
 22: 
 23:     // 本地引用
 24:     if (isJvmRefer) {
 25:         // 创建服务引用 URL 对象
 26:         URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);
 27:         // 引用服务，返回 Invoker 对象
 28:         invoker = refprotocol.refer(interfaceClass, url);
 29:         if (logger.isInfoEnabled()) {
 30:             logger.info("Using injvm service " + interfaceClass.getName());
 31:         }
 32:     // 正常流程，一般为远程引用
 33:     } else {
 34:         // ... 省略本文暂时不分享的服务远程引用 
 35:         }
 36:     }
 37: 
 38:     // 启动时检查
 39:     Boolean c = check;
 40:     if (c == null && consumer != null) {
 41:         c = consumer.isCheck();
 42:     }
 43:     if (c == null) {
 44:         c = true; // default true
 45:     }
 46:     if (c && !invoker.isAvailable()) {
 47:         throw new IllegalStateException("Failed to check the status of the service " + interfaceName + ". No provider available for the service " + (group == null ? "" : group + "/") + interfaceName + (version == null ? "" : ":" + version) + " from the url " + invoker.getUrl() + " to the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion());
 48:     }
 49:     if (logger.isInfoEnabled()) {
 50:         logger.info("Refer dubbo service " + interfaceClass.getName() + " from url " + invoker.getUrl());
 51:     }
 52: 
 53:     // 创建 Service 代理对象
 54:     // create service proxy
 55:     return (T) proxyFactory.getProxy(invoker);
 56: }
```

- `map` 方法参数，URL 参数集合，包含服务引用配置对象的配置项。

- ============ 分割线 ============

- 第 2 行：创建 URL 对象，重点在

  第四个参数

  ，传入的是

   

  ```
  map
  ```

   

  ，仅用于第 11 行，是否本地引用。

  - `protocol = temp` 的原因是，在第 11 行，已经直接使用了 InjvmProtocol ，而不需要通过该值去获取。

- 第 4 行：是否本地引用变量 `isJvmRefer` 。

- 第 19 行 至 20 行：调用 `#isInjvm()` 方法，返回**非空**，说明配置了 `injvm` 配置项，直接使用配置项。

- 第 8 至 9 行：配置了

   

  ```
  url
  ```

   

  配置项，说明使用直连服务提供者的功能，则不使用本地使用。

  - [《Dubbo 用户指南 —— 直连提供者》](http://dubbo.apache.org/zh-cn/docs/user/demos/explicit-target.html)

- 第 11 至 13 行：调用 `InjvmProtocol#isInjvmRefer(url)` 方法，通过 `tmpUrl` 判断，是否需要本地引用。使用 `tmpUrl` ，相当于使用服务引用配置对象的配置项。该方法代码如下：

  ```
   1: /**
   2:  * 是否本地引用
   3:  *
   4:  * @param url URL
   5:  * @return 是否
   6:  */
   7: public boolean isInjvmRefer(URL url) {
   8:     final boolean isJvmRefer;
   9:     String scope = url.getParameter(Constants.SCOPE_KEY);
  10:     // Since injvm protocol is configured explicitly, we don't need to set any extra flag, use normal refer process.
  11:     // 当 `protocol = injvm` 时，本身已经是 jvm 协议了，走正常流程就是了。
  12:     if (Constants.LOCAL_PROTOCOL.toString().equals(url.getProtocol())) {
  13:         isJvmRefer = false;
  14:     // 当 `scope = local` 或者 `injvm = true` 时，本地引用
  15:     } else if (Constants.SCOPE_LOCAL.equals(scope) || (url.getParameter("injvm", false))) {
  16:         // if it's declared as local reference
  17:         // 'scope=local' is equivalent to 'injvm=true', injvm will be deprecated in the future release
  18:         isJvmRefer = true;
  19:     // 当 `scope = remote` 时，远程引用
  20:     } else if (Constants.SCOPE_REMOTE.equals(scope)) {
  21:         // it's declared as remote reference
  22:         isJvmRefer = false;
  23:     // 当 `generic = true` 时，即使用泛化调用，远程引用。
  24:     } else if (url.getParameter(Constants.GENERIC_KEY, false)) {
  25:         // generic invocation is not local reference
  26:         isJvmRefer = false;
  27:     // 当本地已经有该 Exporter 时，本地引用
  28:     } else if (getExporter(exporterMap, url) != null) {
  29:         // by default, go through local reference if there's the service exposed locally
  30:         isJvmRefer = true;
  31:     // 默认，远程引用
  32:     } else {
  33:         isJvmRefer = false;
  34:     }
  35:     return isJvmRefer;
  36: }
  ```

  - ============ 本地引用 ============

    - 第 15 至 18 行：当 `scope = local` 或 `injvm = true` 时，本地引用。

    - 第 27 至 30 行：调用

       

      ```
      #getExporter(url)
      ```

       

      方法，判断当本地已经有

       

      ```
      url
      ```

       

      对应的 InjvmExporter 时，

      直接

      引用。🙂 本地已有的服务，不必要使用远程服务，减少网络开销，提升性能。

      - 🙂 代码比较简单，已经添加中文注释，胖友点击链接查看。
      - [`InjvmProtocol#getExporter(url)`](https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmProtocol.java#L63-L94)
      - [`UrlUtils#isServiceKeyMatch(pattern, value)`](https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/UrlUtils.java#L462-L491)

    - ============ 远程引用 ============

    - 第 10 至 13 行：当 `protocol = injvm` 时，本身已经是 Injvm 协议了，走正常流程即可。**这是最特殊的，下面会更好的理解**。另外，因为 `#isInjvmRefer(url)` 方法，仅有在 `#createProxy(map)` 方法中调用，因此实际也不会触发该逻辑。

    - 第 19 至 22 行：当 `scope = remote` 时，远程引用。

    - 第 23 至 26 行：当

       

      ```
      generic = true
      ```

       

      时，即使用泛化调用，远程引用。

      - [《Dubbo 用户指南 —— 泛化调用》](http://dubbo.apache.org/zh-cn/docs/user/demos/generic-reference.html)

    - 第 31 至 34 行：默认，远程引用。

- 第 23 至 31 行：**本地引用**。

  - 第 26 行：创建本地服务引用 URL 对象。

  - 第 28 行：调用

     

    ```
    Protocol#refer(interface, url)
    ```

     

    方法，引用服务，返回 Invoker 对象。

    - 此处 Dubbo SPI **自适应**的特性的**好处**就出来了，可以**自动**根据 URL 参数，获得对应的拓展实现。例如，`invoker` 传入后，根据 `invoker.url` 自动获得对应 Protocol 拓展实现为 InjvmProtocol 。
    - 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，`#refer(...)` 方法的调用顺序是：**Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => InjvmProtocol** 。
    - 🙂 详细的调用，在 [「3. Protocol」](http://svip.iocoder.cn/Dubbo/reference-refer-local/#) 在解析。

- 第 32 至 36 行：正常流程，一般为**远程引用**。为什么是**一般**呢？如果我们配置 `protocol = injvm` ，实际走的是**本地引用**。例如：

  ```
  <dubbo:reference protocol="injvm" >
  </dubbo:reference>
  ```

  - 🌞 当然，笔者建议，如果真的是需要本地应用，建议配置 `scope = local` 。这样，会更加明确和清晰。

- 第 38 至 51 行：若配置 `check = true` 配置项时，调用 `Invoker#isAvailable()` 方法，启动时检查。

  - 🙂 该方法在 [「4.2 InjvmInvoker」](http://svip.iocoder.cn/Dubbo/reference-refer-local/#) ，详细分享。
  - 🙂 [《Dubbo 用户指南 —— 启动时检查》](http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html)

- 第 55 行：调用

   

  ```
  ProxyFactory#getProxy(invoker)
  ```

   

  方法，创建 Service 代理对象。该 Service 代理对象的内部，会调用

   

  ```
  Invoker#invoke(Invocation)
  ```

   

  方法，进行 Dubbo 服务的调用。

  - 🙂 详细的实现，后面单独写文章分享。

## 3. Protocol

**服务引用与暴露的 Protocol 很多类似点**，本文就不重复叙述了。

建议不熟悉的胖友，请点击 [《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》「3. Protocol」](http://svip.iocoder.cn/Dubbo/service-export-local/?self) 查看。

本文涉及的 Protocol 类图如下：

[![Protocol 类图](http://static.iocoder.cn/images/Dubbo/2018_05_01/04.png)](http://static.iocoder.cn/images/Dubbo/2018_05_01/04.png)Protocol 类图

#### 3.1 ProtocolFilterWrapper

###### 3.1.1 refer

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
2:     // 注册中心
3:     if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
4:         return protocol.refer(type, url);
5:     }
6:     // 引用服务，返回 Invoker 对象
7:     // 给改 Invoker 对象，包装成带有 Filter 过滤链的 Invoker 对象
8:     return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);
9: }
```

- 第 2 至 5 行：当 `invoker.url.protocl = registry` ，跳过，本地引用服务不会符合这个判断。在远程引用服务会符合暴露该判断，所以下一篇文章分享。
- 第 8 行：调用 `protocol#refer(type, url)` 方法，继续引用服务，最终返回 Invoker 。
- 第 8 行：在引用服务完成后，调用 `#buildInvokerChain(invoker, key, group)` 方法，创建带有 Filter 过滤链的 Invoker 对象。

###### 3.1.2 buildInvokerChain

和 [《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》「3.1.3 buildInvokerChain」](http://svip.iocoder.cn/Dubbo/service-export-local/?self) 基本一致，**默认情况下**，获得的 Filter 数组如下：

- ConsumerContextFilter
- FutureFilter
- MonitorFilter

当然，因为传入的参数 `group` 不同，如果胖友自定义了**自动激活**的 Filter 只出现在 `group = consumer` ，那么服务消费者就会多一个该 Filter 实现。

#### 3.2 ProtocolListenerWrapper

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
 1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
 2:     // 注册中心协议
 3:     if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
 4:         return protocol.refer(type, url);
 5:     }
 6:     // 引用服务
 7:     Invoker<T> invoker = protocol.refer(type, url);
 8:     // 获得 InvokerListener 数组
 9:     List<InvokerListener> listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(InvokerListener.class).getActivateExtension(url, Constants.INVOKER_LISTENER_KEY));
10:     // 创建 ListenerInvokerWrapper 对象
11:     return new ListenerInvokerWrapper<T>(invoker, listeners);
12: }
```

- 第 2 至 5 行：当 `invoker.url.protocl = registry` ，跳过，本地引用服务不会符合这个判断。在远程引用服务会符合暴露该判断，所以下一篇文章分享。

- 第 7 行：调用 `protocol#refer(type, url)` 方法，继续引用服务，最终返回 Invoker 。

- 第 9 行：调用

   

  ```
  ExtensionLoader#getActivateExtension(url, key, group)
  ```

   

  方法，获得监听器数组。

  - 🙂 不熟悉的胖友，请看 [《精尽 Dubbo 源码分析 —— 拓展机制 SPI》](http://svip.iocoder.cn/Dubbo/spi/?self) 文章。
  - 继续以上面的例子为基础，`listeners` 为**空**。胖友可以自行实现 ExporterListener ，并进行配置 `@Activate` 注解，或者 XML 中 `listener` 属性。

- 第 11 行：创建带 InvokerListener 的 ListenerInvokerWrapper 对象。在这个过程中，会执行

   

  ```
  ExporterListener#referred(invoker)
  ```

   

  方法。

  - 🙂 在 [「4.3 ListenerInvokerWrapper」](http://svip.iocoder.cn/Dubbo/reference-refer-local/#) 详细解析。

#### 3.3 InjvmProtocol

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {
    return new InjvmInvoker<T>(serviceType, url, url.getServiceKey(), exporterMap);
}
```

- 创建 InjvmInvoker 对象。**注意**，传入的 `exporterMap` 参数，包含**所有的** InjvmExporter 对象。

## 4. Invoker

Exporter **接口**，在 [《精尽 Dubbo 源码分析 —— 核心流程一览》「4.1 Invoker」](http://svip.iocoder.cn/Dubbo/reference-refer-local/#) 有详细解析。

本文涉及的 Invoker 类图如下：

[![Invoker 类图](http://static.iocoder.cn/images/Dubbo/2018_05_01/05.png)](http://static.iocoder.cn/images/Dubbo/2018_05_01/05.png)Invoker 类图

#### 4.1 AbstractInvoker

[`com.alibaba.dubbo.rpc.protocol.AbstractInvoker`](https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractInvoker.java) ，实现 Invoker 接口，抽象 Invoker 类，主要提供了 Invoker 的通用属性和 `#invoke(Invocation)` 方法的通用实现。

本文主要涉及到它的通用属性，代码如下：

```
/**
 * 接口类型
 */
private final Class<T> type;
/**
 * 服务 URL
 */
private final URL url;
/**
 * 公用的隐式传参。在 {@link #invoke(Invocation)} 方法中使用。
 */
private final Map<String, String> attachment;
/**
 * 是否可用
 */
private volatile boolean available = true;
/**
 * 是否销毁
 */
private AtomicBoolean destroyed = new AtomicBoolean(false);
```

ps：`#invoke(Invocation)` 方法，在后续的文章分享。

#### 4.2 InjvmInvoker

[`com.alibaba.dubbo.rpc.protocol.injvm.InjvmInvoker`](https://github.com/YunaiV/dubbo/blob/6f366fae76b4fc5fc4fb0352737b6e847a3a2b0b/dubbo-rpc/dubbo-rpc-injvm/src/main/java/com/alibaba/dubbo/rpc/protocol/injvm/InjvmInvoker.java) ，实现 AbstractInvoker 抽象类，Injvm Invoker 实现类。

###### 4.2.1 属性

```
/**
 * 服务键
 */
private final String key;
/**
 * Exporter 集合
 *
 * key: 服务键
 *
 * 该值实际就是 {@link com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}
 */
private final Map<String, Exporter<?>> exporterMap;

InjvmInvoker(Class<T> type, URL url, String key, Map<String, Exporter<?>> exporterMap) {
    super(type, url);
    this.key = key;
    this.exporterMap = exporterMap;
}
```

- `key` 属性，服务键。
- `exporterMap` 属性，Exporter 集合。在 `InjvmInvoker#invoke(invocation)` 方法中，通过该 Invoker 的 `key` 属性，获得对应的 Exporter 对象。

###### 4.2.2 isAvailable

`#isAvailable()` 方法，是否可用。代码如下：

```
@Override
public boolean isAvailable() {
    // 判断是否有 Exporter 对象
    InjvmExporter<?> exporter = (InjvmExporter<?>) exporterMap.get(key);
    if (exporter == null) {
        return false;
    } else {
        return super.isAvailable();
    }
}
```

- 开启 [启动时检查](http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html) 时，调用该方法，判断该 Invoker 对象，是否有对应的 Exporter 。若不存在，**说明依赖服务不存在**，检查不通过。

#### 4.3 ListenerInvokerWrapper

[`com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper`](https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/listener/ListenerInvokerWrapper.java) ，实现 Invoker 接口，具有监听器功能的 Invoker 包装器。代码如下：

```
public class ListenerInvokerWrapper<T> implements Invoker<T> {

    private static final Logger logger = LoggerFactory.getLogger(ListenerInvokerWrapper.class);

    /**
     * 真实的 Invoker 对象
     */
    private final Invoker<T> invoker;
    /**
     * Invoker 监听器数组
     */
    private final List<InvokerListener> listeners;

    public ListenerInvokerWrapper(Invoker<T> invoker, List<InvokerListener> listeners) {
        if (invoker == null) {
            throw new IllegalArgumentException("invoker == null");
        }
        this.invoker = invoker;
        this.listeners = listeners;
        // 执行监听器
        if (listeners != null && !listeners.isEmpty()) {
            for (InvokerListener listener : listeners) {
                if (listener != null) {
                    try {
                        listener.referred(invoker);
                    } catch (Throwable t) {
                        logger.error(t.getMessage(), t);
                    }
                }
            }
        }
    }

    public Class<T> getInterface() {
        return invoker.getInterface();
    }

    public URL getUrl() {
        return invoker.getUrl();
    }

    public boolean isAvailable() {
        return invoker.isAvailable();
    }

    public Result invoke(Invocation invocation) throws RpcException {
        return invoker.invoke(invocation);
    }

    @Override
    public String toString() {
        return getInterface() + " -> " + (getUrl() == null ? " " : getUrl().toString());
    }

    public void destroy() {
        try {
            invoker.destroy();
        } finally {
            // 执行监听器
            if (listeners != null && !listeners.isEmpty()) {
                for (InvokerListener listener : listeners) {
                    if (listener != null) {
                        try {
                            listener.destroyed(invoker);
                        } catch (Throwable t) {
                            logger.error(t.getMessage(), t);
                        }
                    }
                }
            }
        }
    }

}
```

- **构造方法**，循环 `listeners` ，执行 `InvokerListener#referred(invoker)` 方法。😈 和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，**仅**打印错误日志，继续执行，最终**不**抛出异常。
- `#unexport()` 方法，循环 `listeners` ，执行 `InvokerListener#destroyed(invoker)` 。😈 和 ListenerExporterWrapper 不同，若执行过程中发生异常 RuntimeException ，**仅**打印错误日志，继续执行，最终**不**抛出异常。

## 5. InvokerListener

[`com.alibaba.dubbo.rpc.InvokerListener`](https://github.com/YunaiV/dubbo/blob/6de0a069fcc870894e64ffd54a24e334b19dcb36/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/InvokerListener.java) ，Invoker 监听器。

代码如下：

```
@SPI
public interface InvokerListener {

    /**
     * The invoker referred
     *
     * 当服务引用完成
     *
     * @param invoker
     * @throws RpcException
     * @see com.alibaba.dubbo.rpc.Protocol#refer(Class, URL)
     */
    void referred(Invoker<?> invoker) throws RpcException;

    /**
     * The invoker destroyed.
     *
     * 当服务销毁引用完成
     *
     * @param invoker
     * @see com.alibaba.dubbo.rpc.Invoker#destroy()
     */
    void destroyed(Invoker<?> invoker);

}
```

[![InvokerListener 子类](http://static.iocoder.cn/images/Dubbo/2018_03_01/16.png)](http://static.iocoder.cn/images/Dubbo/2018_03_01/16.png)InvokerListener 子类

#### 5.1 InvokerListenerAdapter

`com.alibaba.dubbo.rpc.listener.InvokerListenerAdapter` ，实现 InvokerListener 接口，InvokerListener 适配器**抽象类**。代码如下：

```
public abstract class InvokerListenerAdapter implements InvokerListener {

    public void referred(Invoker<?> invoker) throws RpcException { }

    public void destroyed(Invoker<?> invoker) { }

}
```

#### 5.2 DeprecatedInvokerListener

`com.alibaba.dubbo.rpc.listener.DeprecatedInvokerListener` ，实现 InvokerListenerAdapter **抽象类** ，引用废弃的服务时，打印错误日志提醒。代码如下：

```
@Activate(Constants.DEPRECATED_KEY)
public class DeprecatedInvokerListener extends InvokerListenerAdapter {

    private static final Logger LOGGER = LoggerFactory.getLogger(DeprecatedInvokerListener.class);

    public void referred(Invoker<?> invoker) throws RpcException {
        if (invoker.getUrl().getParameter(Constants.DEPRECATED_KEY, false)) {
            LOGGER.error("The service " + invoker.getInterface().getName() + " is DEPRECATED! Declare from " + invoker.getUrl());
        }
    }

}
```

- `@Activate(Constants.DEPRECATED_KEY)` 注解，基于 Dubbo SPI Activate 机制加载。配置方式如下：

  ```
      <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" deprecated="true" />
  ```
      * 通过设置 `"deprecated"` 为 `true` 来设置。
      * 该方式仅适用于**远程引用**服务。
  
  * 在 `#referred(invoker)` 方法中，打印错误日志，例如：
  
      ```Java
      [25/03/18 07:37:56:056 CST] main ERROR listener.DeprecatedInvokerListener:  [DUBBO] The service com.alibaba.dubbo.demo.DemoService is DEPRECATED! Declare from dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-consumer&check=false&compiler=jdk&default.delay=-1&default.retries=0&delay=-1&deprecated=true&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,bye&pid=45155&qos.port=33333&register.ip=192.168.3.17&remote.timestamp=1521977820764&service.filter=demo&side=consumer&timestamp=1521977854685, dubbo version: 2.0.0, current host: 192.168.3.17
      group:consumer
      ```
  
  ```
  
  ```

另外，**本地引用**服务的配置方式如下：

```
<dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" protocol="injvm">
    <dubbo:parameter key="deprecated" value="true" />
</dubbo:reference>
```

- 因为，本地引用服务时，不是使用服务提供者的 URL ，而是服务消费者的 URL 。

# 远程引用

## 1. 概述

在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 一文中，我们已经分享了**本地引用服务**。在本文中，我们来分享**远程引用服务**。在 Dubbo 中提供多种协议( Protocol ) 的实现，大体流程一致，本文以 [Dubbo Protocol](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html) 为例子，这也是 Dubbo 的**默认**协议。

如果不熟悉该协议的同学，可以先看看 [《Dubbo 使用指南 —— dubbo://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html) ，简单了解即可。

> **特性**
>
> 缺省协议，使用基于 mina `1.1.7` 和 hessian `3.2.1` 的 remoting 交互。
>
> - 连接个数：单连接
> - 连接方式：长连接
> - 传输协议：TCP
> - 传输方式：NIO 异步传输
> - 序列化：Hessian 二进制序列化
> - 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。
> - 适用场景：常规远程服务方法调用

相比**本地引用**，**远程引用**会多做如下几件事情：

- 向注册中心**订阅**，从而**发现**服务提供者列表。
- 启动通信客户端，通过它进行**远程调用**。

## 2. 远程引用

远程暴露服务的顺序图如下：

[![远程引用顺序图](http://static.iocoder.cn/images/Dubbo/2018_05_04/02.png)](http://static.iocoder.cn/images/Dubbo/2018_05_04/02.png)远程引用顺序图

在 [`#createProxy(map)`](https://github.com/YunaiV/dubbo/blob/c635dd1990a1803643194048f408db310f06175b/dubbo-config/dubbo-config-api/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java#L621-L648) 方法中，涉及**远程引用服务**的代码如下：

```
/**
 * 服务引用 URL 数组
 */
private final List<URL> urls = new ArrayList<URL>();
/**
 * 直连服务地址
 *
 * 1. 可以是注册中心，也可以是服务提供者
 * 2. 可配置多个，使用 ; 分隔
 */
// url for peer-to-peer invocation
private String url;

  1: /**
  2:  * 创建 Service 代理对象
  3:  *
  4:  * @param map 集合
  5:  * @return 代理对象
  6:  */
  7: @SuppressWarnings({"unchecked", "rawtypes", "deprecation"})
  8: private T createProxy(Map<String, String> map) {
  9:     URL tmpUrl = new URL("temp", "localhost", 0, map);
 10:     // 【省略代码】是否本地引用
 11:     final boolean isJvmRefer;
 12: 
 13:     // 【省略代码】本地引用
 14:     if (isJvmRefer) {
 15:     // 正常流程，一般为远程引用
 16:     } else {
 17:         // 定义直连地址，可以是服务提供者的地址，也可以是注册中心的地址
 18:         if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.
 19:             // 拆分地址成数组，使用 ";" 分隔。
 20:             String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);
 21:             // 循环数组，添加到 `url` 中。
 22:             if (us != null && us.length > 0) {
 23:                 for (String u : us) {
 24:                     // 创建 URL 对象
 25:                     URL url = URL.valueOf(u);
 26:                     // 设置默认路径
 27:                     if (url.getPath() == null || url.getPath().length() == 0) {
 28:                         url = url.setPath(interfaceName);
 29:                     }
 30:                     // 注册中心的地址，带上服务引用的配置参数
 31:                     if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
 32:                         urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));
 33:                     // 服务提供者的地址
 34:                     } else {
 35:                         urls.add(ClusterUtils.mergeUrl(url, map));
 36:                     }
 37:                 }
 38:             }
 39:         // 注册中心
 40:         } else { // assemble URL from register center's configuration
 41:             // 加载注册中心 URL 数组
 42:             List<URL> us = loadRegistries(false);
 43:             // 循环数组，添加到 `url` 中。
 44:             if (us != null && !us.isEmpty()) {
 45:                 for (URL u : us) {
 46:                     // 加载监控中心 URL
 47:                     URL monitorUrl = loadMonitor(u);
 48:                     // 服务引用配置对象 `map`，带上监控中心的 URL
 49:                     if (monitorUrl != null) {
 50:                         map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
 51:                     }
 52:                     // 注册中心的地址，带上服务引用的配置参数
 53:                     urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map))); // 注册中心，带上服务引用的配置参数
 54:                 }
 55:             }
 56:             if (urls == null || urls.isEmpty()) {
 57:                 throw new IllegalStateException("No such any registry to reference " + interfaceName + " on the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", please config <dubbo:registry address=\"...\" /> to your spring config.");
 58:             }
 59:         }
 60: 
 61:         // 单 `urls` 时，引用服务，返回 Invoker 对象
 62:         if (urls.size() == 1) {
 63:             // 引用服务
 64:             invoker = refprotocol.refer(interfaceClass, urls.get(0));
 65:         } else {
 66:             // 循环 `urls` ，引用服务，返回 Invoker 对象
 67:             List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
 68:             URL registryURL = null;
 69:             for (URL url : urls) {
 70:                 // 引用服务
 71:                 invokers.add(refprotocol.refer(interfaceClass, url));
 72:                 // 使用最后一个注册中心的 URL
 73:                 if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
 74:                     registryURL = url; // use last registry url
 75:                 }
 76:             }
 77:             // 有注册中心
 78:             if (registryURL != null) { // registry url is available
 79:                 // 对有注册中心的 Cluster 只用 AvailableCluster
 80:                 // use AvailableCluster only when register's cluster is available
 81:                 URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);
 83:                 invoker = cluster.join(new StaticDirectory(u, invokers));
 84:             // 无注册中心
 85:             } else { // not a registry url
 87:                 invoker = cluster.join(new StaticDirectory(invokers));
 88:             }
 89:         }
 90:     }
 91: 
 92:     // 【省略代码】启动时检查
 93: 
 94:     // 创建 Service 代理对象
 95:     // create service proxy
 96:     return (T) proxyFactory.getProxy(invoker);
 97: }
```

- 第 11 行：省略**是否本地引用**的代码，在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 已经有分享。

- 第 13 至 15 行：省略**本地引用**的代码，在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 已经有分享。

- 第 16 至 90 行：正常流程，一般为远程引用。

- 第 18 至 38 行：

  ```
  url
  ```

   

  配置项，

  定义直连地址

  ，可以是服务提供者的地址，也可以是注册中心的地址。

  - 第 20 行：拆分地址成数组，使用 “;” 分隔。

  - 第 22 至 23 行：循环数组 `us` ，创建 URL 对象后，添加到 `urls` 中。

  - 第 25 行：创建 URL 对象。

  - 第 26 至 29 行：路径属性 `url.path` 未设置时，缺省使用接口全名 `interfaceName` 。

  - 第 30 至 32 行：若 `url.protocol = registry` 时，**注册中心的地址**，在参数 `url.parameters.refer` 上，设置上服务引用的配置参数集合 `map` 。

  - 第 33 至 36 行：

    服务提供者的地址

    。

    - 从逻辑上类似【第 53 行】的代码。
    - 一般情况下，不建议这样在 `url` 配置注册中心，而是在 `registry` 配置。如果要配置，格式为 `registry://host:port?registry=` ，例如 `registry://127.0.0.1?registry=zookeeper` 。
    - TODO ClusterUtils.mergeUrl

- 第 39 至 59 行：

  ```
  protocol
  ```

   

  配置项，

  注册中心

  。

  - 第 42 行：调用

     

    ```
    #loadRegistries(provider)
    ```

     

    方法，加载注册中心的 com.alibaba.dubbo.common.URL` 数组。

    - 🙂 在 [《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》「2.1 loadRegistries」](http://svip.iocoder.cn/Dubbo/service-export-local/?self) 详细解析。

  - 第 43 至 58 行：循环数组

     

    ```
    us
    ```

     

    ，创建 URL 对象后，添加到

     

    ```
    urls
    ```

     

    中。

    - 第 47 行：调用

       

      ```
      #loadMonitor(registryURL)
      ```

       

      方法，获得监控中心 URL 。

      - 🙂 在 [《精尽 Dubbo 源码分析 —— 服务暴露（二）之远程暴露（Dubbo）》「2.1 loadRegistries」](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/#) 小节，详细解析。

    - 第 49 至 51 行：服务引用配置对象 `map`，带上监控中心的 URL 。具体用途，我们在后面分享监控中心会看到。

    - 第 53 行：调用 [`URL#addParameterAndEncoded(key, value)`](https://github.com/YunaiV/dubbo/blob/c635dd1990a1803643194048f408db310f06175b/dubbo-common/src/main/java/com/alibaba/dubbo/common/URL.java#L891-L896) 方法，将服务引用配置对象参数集合 `map` ，作为 `"refer"` 参数添加到注册中心的 URL 中，**并且需要编码**。通过这样的方式，注册中心的 URL 中，**包含了服务引用的配置**。

- 第 61 至 64 行：单 `urls` 时，**直接调用** `Protocol#refer(type, url)` 方法，引用服务，返回 Invoker 对象。

  - 此处 Dubbo SPI **自适应**的特性的**好处**就出来了，可以**自动**根据 URL 参数，获得对应的拓展实现。例如，`invoker` 传入后，根据 `invoker.url` 自动获得对应 Protocol 拓展实现为 DubboProtocol 。

  - 实际上，Protocol 有两个 Wrapper 拓展实现类： ProtocolFilterWrapper、ProtocolListenerWrapper 。所以，`#export(...)` 方法的调用顺序是：

    - **Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => RegistryProtocol**

    - =>

    - **Protocol$Adaptive => ProtocolFilterWrapper => ProtocolListenerWrapper => DubboProtocol**

    - 也就是说，

      这一条大的调用链，包含两条小的调用链

      。原因是：

      - 首先，传入的是注册中心的 URL ，通过 Protocol$Adaptive 获取到的是 RegistryProtocol 对象。
      - 其次，RegistryProtocol 会在其 `#refer(...)` 方法中，使用服务提供者的 URL ( 即注册中心的 URL 的 `refer` 参数值)，再次调用 Protocol$Adaptive 获取到的是 DubboProtocol 对象，进行服务暴露。

    - **为什么是这样的顺序**？通过这样的顺序，可以实现类似 **AOP** 的效果，在获取服务提供者列表后，再创建连接服务提供者的客户端。伪代码如下：

      ```
      RegistryProtocol#refer(...) {
          
          // 1. 获取服务提供者列表 【并且订阅】
          
          // 2. 创建调用连接服务提供者的客户端 
          DubboProtocol#refer(...);
          
          // ps：实际这个过程中，还有别的代码，详细见下文。
      }
      ```

      - x

- 第 65 至 89 行：多 `urls` 时，**循环调用** `Protocol#refer(type, url)` 方法，引用服务，返回 Invoker 对象。此时，会有多个 Invoker 对象，需要进行合并。

  - 什么时候会出现多个 `urls` 呢？例如：[《Dubbo 用户指南 —— 多注册中心注册》](http://dubbo.apache.org/zh-cn/docs/user/demos/multi-registry.html) 。

  - 第 66 至 76 行：循环

     

    ```
    urls
    ```

     

    ，引用服务。

    - 第 71 行：调用 `Protocol#refer(type, url)` 方法，引用服务，返回 Invoker 对象。然后，添加到 `invokers` 中。
    - 第 72 会 75 行：使用最后一个注册中心的 URL ，赋值到 `registryURL` 。

  - 第 77 至 88 行：详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（三）之 Directory 实现》](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/?self) 。

- 第 92 行：省略**启动时检查**的代码，在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 已经有分享。

- 第 96 行：省略**创建 Service 代理对象**的代码，在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 已经有分享。

## 3. Protocol

**服务引用与暴露的 Protocol 很多类似点**，本文就不重复叙述了。

建议不熟悉的胖友，请点击 [《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》「3. Protocol」](http://svip.iocoder.cn/Dubbo/service-export-local/?self) 查看。

本文涉及的 Protocol 类图如下：

[![Protocol 类图](http://static.iocoder.cn/images/Dubbo/2018_05_04/03.png)](http://static.iocoder.cn/images/Dubbo/2018_05_04/03.png)Protocol 类图

#### 3.1 ProtocolFilterWrapper

接 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》「 3.1 ProtocolFilterWrapper」](http://svip.iocoder.cn/Dubbo/service-reference-local/?self) 小节。

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
2:     // 注册中心
3:     if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
4:         return protocol.refer(type, url);
5:     }
6:     // 引用服务，返回 Invoker 对象
7:     // 给改 Invoker 对象，包装成带有 Filter 过滤链的 Invoker 对象
8:     return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);
9: }
```

- 第 2 至 5 行：当 `invoker.url.protocl = registry` ，**注册中心的 URL** ，无需创建 Filter 过滤链。
- 第 8 行：调用 `protocol#refer(type, url)` 方法，继续引用服务，最终返回 Invoker 。
- 第 8 行：在引用服务完成后，调用 `#buildInvokerChain(invoker, key, group)` 方法，创建带有 Filter 过滤链的 Invoker 对象。

#### 3.2 RegistryProtocol

###### 3.2.1 refer

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
/**
 * Cluster 自适应拓展实现类对象
 */
private Cluster cluster;

  1: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
  2:     // 获得真实的注册中心的 URL
  3:     url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);
  4:     // 获得注册中心
  5:     Registry registry = registryFactory.getRegistry(url);
  6:     // TODO 芋艿
  7:     if (RegistryService.class.equals(type)) {
  8:         return proxyFactory.getInvoker((T) registry, type, url);
  9:     }
 10: 
 11:     // 获得服务引用配置参数集合
 12:     // group="a,b" or group="*"
 13:     Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
 14:     String group = qs.get(Constants.GROUP_KEY);
 15:     // 分组聚合，参见文档 http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html
 16:     if (group != null && group.length() > 0) {
 17:         if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1
 18:                 || "*".equals(group)) {
 19:             // 执行服务引用
 20:             return doRefer(getMergeableCluster(), registry, type, url);
 21:         }
 22:     }
 23:     // 执行服务引用
 24:     return doRefer(cluster, registry, type, url);
 25: }
```

- 第 3 行：获得**真实**的注册中心的 URL 。该过程是我们在 [《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》「2.1 loadRegistries」](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/#) 的那张图的反向流程，即**红线部分** ：[![getRegistryUrl](http://static.iocoder.cn/images/Dubbo/2018_03_10/01.png)](http://static.iocoder.cn/images/Dubbo/2018_03_10/01.png)getRegistryUrl

- 第 5 行：获得注册中心 Registry 对象。

- 第 7至 9 行：【TODO 8018】RegistryService.class

- 第 13 行：获得服务引用配置参数集合 `qs` 。

- 第 16 至 22 行：分组聚合，参见 [《Dubbo 用户指南 —— 分组聚合》](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) 文档。

- 第 24 行：调用 `#doRefer(cluster, registry, type, url)` 方法，执行服务引用。不同于【第 20 行】的代码，后者调用 `#getMergeableCluster()` 方法，获得**可合并的** Cluster 对象，代码如下：

  ```
  private Cluster getMergeableCluster() {
      return ExtensionLoader.getExtensionLoader(Cluster.class).getExtension("mergeable");
  }
  ```

###### 3.2.2 doRefer

`#doRefer(cluster, registry, type, url)` 方法，执行服务引用的逻辑。代码如下：

```
 1: /**
 2:  * 执行服务引用，返回 Invoker 对象
 3:  *
 4:  * @param cluster Cluster 对象
 5:  * @param registry 注册中心对象
 6:  * @param type 服务接口类型
 7:  * @param url 注册中心 URL
 8:  * @param <T> 泛型
 9:  * @return Invoker 对象
10:  */
11: private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
12:     // 创建 RegistryDirectory 对象，并设置注册中心
13:     RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
14:     directory.setRegistry(registry);
15:     directory.setProtocol(protocol);
16:     // 创建订阅 URL
17:     // all attributes of REFER_KEY
18:     Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters()); // 服务引用配置集合
19:     URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);
20:     // 向注册中心注册自己（服务消费者）
21:     if (!Constants.ANY_VALUE.equals(url.getServiceInterface())
22:             && url.getParameter(Constants.REGISTER_KEY, true)) {
23:         registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,
24:                 Constants.CHECK_KEY, String.valueOf(false)));
25:     }
26:     // 向注册中心订阅服务提供者
27:     directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,
28:             Constants.PROVIDERS_CATEGORY
29:                     + "," + Constants.CONFIGURATORS_CATEGORY
30:                     + "," + Constants.ROUTERS_CATEGORY));
31: 
32:     // 创建 Invoker 对象
33:     Invoker invoker = cluster.join(directory);
34:     // 向本地注册表，注册消费者
35:     ProviderConsumerRegTable.registerConsuemr(invoker, url, subscribeUrl, directory);
36:     return invoker;
37: }
```

- 第 12 至 15 行，创建 RegistryDirectory 对象，并设置注册中心到它的属性。

- 第 18 行：获得服务引用配置集合 `parameters` 。**注意**，`url` 传入 RegistryDirectory 后，经过处理并重新创建，所以 `url != directory.url` ，所以获得的是服务引用配置集合。如下图所示：[![parameters](http://static.iocoder.cn/images/Dubbo/2018_05_04/01.png)](http://static.iocoder.cn/images/Dubbo/2018_05_04/01.png)parameters

- 第 19 行：创建订阅 URL 对象。

- 第 20 至 25 行：调用

   

  ```
  RegistryService#register(url)
  ```

   

  方法，向注册中心注册

  自己

  （服务消费者）。

  - 在 [《精尽 Dubbo 源码分析 —— 注册中心（一）之抽象 API》「3. RegistryService」 ](http://svip.iocoder.cn/Dubbo/registry-api/?self)，有详细解析。

- 第 26 终 30 行：调用

   

  ```
  Directory#subscribe(url)
  ```

   

  方法，向注册中心订阅服务提供者 + 路由规则 + 配置规则。

  - 在该方法中，会循环获得到的服务体用这列表，调用 `Protocol#refer(type, url)` 方法，创建每个调用服务的 Invoker 对象。

- 第 33 行：创建 Invoker 对象。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/?self) 。

- 第 35 行：调用

   

  ```
  ProviderConsumerRegTable#registerConsuemr(invoker, url, subscribeUrl, directory)
  ```

   

  方法，向本地注册表，注册消费者。

  - 在 [《精尽 Dubbo 源码分析 —— 注册中心（一）之抽象 API》「5. ProviderConsumerRegTable」 ](http://svip.iocoder.cn/Dubbo/registry-api/?self)，有详细解析。

- 第 36 行：返回 Invoker 对象。

#### 3.3 DubboProtocol

###### 3.3.1 refer

本文涉及的 `#refer(type, url)` 方法，代码如下：

```
// AbstractProtocol.java 父类
/**
 * Invoker 集合
 */
//TODO SOFEREFENCE
protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>();

// DubboProtocol.java

  1: public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {
  2:     // 初始化序列化优化器
  3:     optimizeSerialization(url);
  4:     // 获得远程通信客户端数组
  5:     // 创建 DubboInvoker 对象
  6:     // create rpc invoker.
  7:     DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
  8:     // 添加到 `invokers`
  9:     invokers.add(invoker);
 10:     return invoker;
 11: }
```

- `invokers` 属性，Invoker 集合。
- 第 3 行：调用 `#optimizeSerialization(url)` 方法，初始化序列化优化器。在 [《精尽 Dubbo 源码分析 —— 序列化（一）之总体实现》](http://svip.iocoder.cn/Dubbo/serialize-1-all?self) 中，详细解析。
- 第 7 行：调用 `#getClients(url)` 方法，创建远程通信客户端数组。
- 第 7 行：创建 DubboInvoker 对象。
- 第 9 行：添加到 `invokers` 。
- 第 10 行：返回 Invoker 对象。

###### 3.3.2 getClients

> 友情提示，涉及 Client 的内容，胖友先看过 [《精尽 Dubbo 源码分析 —— NIO 服务器》](http://svip.iocoder.cn/Dubbo/remoting-api-interface/?self) 所有的文章。

`#getClients(url)` 方法，获得连接服务提供者的远程通信客户端数组。代码如下：

```
 1: /**
 2:  * 获得连接服务提供者的远程通信客户端数组
 3:  *
 4:  * @param url 服务提供者 URL
 5:  * @return 远程通信客户端
 6:  */
 7: private ExchangeClient[] getClients(URL url) {
 8:     // 是否共享连接
 9:     // whether to share connection
10:     boolean service_share_connect = false;
11:     int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);
12:     // if not configured, connection is shared, otherwise, one connection for one service
13:     if (connections == 0) { // 未配置时，默认共享
14:         service_share_connect = true;
15:         connections = 1;
16:     }
17: 
18:     // 创建连接服务提供者的 ExchangeClient 对象数组
19:     ExchangeClient[] clients = new ExchangeClient[connections];
20:     for (int i = 0; i < clients.length; i++) {
21:         if (service_share_connect) { // 共享
22:             clients[i] = getSharedClient(url);
23:         } else { // 不共享
24:             clients[i] = initClient(url);
25:         }
26:     }
27:     return clients;
28: }
```

- 第 8 至 16 行：是否共享连接。

- 第 18 至 26 行：创建连接服务提供者的 ExchangeClient 对象数组。

  - **注意**，若开启共享连接，基于 URL 为维度共享。
  - 第 21 至 22 行：共享连接，调用 `#getSharedClient(url)` 方法，获得 ExchangeClient 对象。
  - 第 23 至 25 行：不共享连接，调用 `#initClient(url)` 方法，直接创建 ExchangeClient 对象。

- ```
  connections
  ```

   

  配置项。

  - 默认 0 。即，对同一个远程服务器，**共用**同一个连接。
  - 大于 0 。即，每个服务引用，**独立**每一个连接。
  - [《Dubbo 用户指南 —— 连接控制》](http://dubbo.apache.org/zh-cn/docs/user/demos/config-connections.html)
  - [《Dubbo 用户指南 —— dubbo:reference》](http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html)

###### 3.3.3 getSharedClient

`#getClients(url)` 方法，获得连接服务提供者的远程通信客户端数组。代码如下：

```
/**
 * 通信客户端集合
 *
 * key: 服务器地址。格式为：host:port
 */
private final Map<String, ReferenceCountExchangeClient> referenceClientMap = new ConcurrentHashMap<String, ReferenceCountExchangeClient>(); // <host:port,Exchanger>
/**
 * TODO 8030 ，这个是什么用途啊。
 *
 * key: 服务器地址。格式为：host:port 。和 {@link #referenceClientMap} Key ，是一致的。
 */
private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap = new ConcurrentHashMap<String, LazyConnectExchangeClient>();

  1: private ExchangeClient getSharedClient(URL url) {
  2:     // 从集合中，查找 ReferenceCountExchangeClient 对象
  3:     String key = url.getAddress();
  4:     ReferenceCountExchangeClient client = referenceClientMap.get(key);
  5:     if (client != null) {
  6:         // 若未关闭，增加指向该 Client 的数量，并返回它
  7:         if (!client.isClosed()) {
  8:             client.incrementAndGetCount();
  9:             return client;
 10:         // 若已关闭，移除
 11:         } else {
 12:             referenceClientMap.remove(key);
 13:         }
 14:     }
 15:     // 同步，创建 ExchangeClient 对象。
 16:     synchronized (key.intern()) {
 17:         // 创建 ExchangeClient 对象
 18:         ExchangeClient exchangeClient = initClient(url);
 19:         // 将 `exchangeClient` 包装，创建 ReferenceCountExchangeClient 对象
 20:         client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);
 21:         // 添加到集合
 22:         referenceClientMap.put(key, client);
 23:         // 添加到 `ghostClientMap`
 24:         ghostClientMap.remove(key);
 25:         return client;
 26:     }
 27: }
```

- ```
  referenceClientMap
  ```

   

  属性，通信客户端集合。在我们创建好 Client 对象，“

  连接

  ”服务器后，会添加到这个集合中，用于后续的 Client 的

  共享

  。

  - ReferenceCountExchangeClient ，顾名思义，带有指向数量计数的 Client 封装。
  - “**连接**” ，打引号的原因，因为有 LazyConnectExchangeClient ，还是顾名思义，延迟连接的 Client 封装。
  - 🙂 ReferenceCountExchangeClient 和 LazyConnectExchangeClient 的具体实现，在 [「5. Client」](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/#) 详细解析。

- ```
  ghostClientMap
  ```

   

  属性，幽灵客户端集合。TODO 8030 ，这个是什么用途啊。

  - 【添加】每次 ReferenceCountExchangeClient **彻底**关闭( 指向归零 ) ，其内部的 `client` 会替换成**重新创建**的 LazyConnectExchangeClient 对象，此时叫这个对象为**幽灵客户端**，添加到 `ghostClientMap` 中。
  - 【移除】当幽灵客户端，对应的 URL 的服务器被重新连接上后，会被移除。
  - **注意**，在幽灵客户端**被移除之前**，`referenceClientMap` 中，依然保留着对应的 URL 的 ReferenceCountExchangeClient 对象。所以，`ghostClientMap` 相当于标记 `referenceClientMap` 中，哪些 LazyConnectExchangeClient 对象，是**幽灵**状态。👻

- 第 2 至 4 行：从集合 `referenceClientMap` 中，查找 ReferenceCountExchangeClient 对象。

- 第 5 至 14 行：查找到客户端。

  - 第 6 至 9 行：若**未关闭**，调用 `ReferenceCountExchangeClient#incrementAndGetCount()` 方法，增加指向该客户端的数量，并返回。
  - 第 11 至 13 行：若**已关闭**，适用于**幽灵**状态的 ReferenceCountExchangeClient 对象，从 `referenceClientMap` 中移除，准备下面的代码，创建**新的** ReferenceCountExchangeClient 对象。

- 第 15 至 26 行：

  同步

  (

   

  ```
  synchronized
  ```

   

  ) ，创建新的 ReferenceCountExchangeClient 对象。

  - 第 18 行：调用 `#initClient(url)` 方法，创建 ExchangeClient 对象。
  - 第 20 行：将 ExchangeClient 对象，封装创建成 ReferenceCountExchangeClient 独享。
  - 第 22 行：添加到集合 `referenceClientMap` 。
  - 第 24 行：移除出集合 `ghostClientMap` ，因为不再是**幽灵**状态啦。

###### 3.3.4 initClient

`#initClient(url)` 方法，创建 ExchangeClient 对象，”连接”服务器。

```
 1: private ExchangeClient initClient(URL url) {
 2:     // 校验 Client 的 Dubbo SPI 拓展是否存在
 3:     // client type setting.
 4:     String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));
 5:     // BIO is not allowed since it has severe performance issue.
 6:     if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
 7:         throw new RpcException("Unsupported client type: " + str + "," +
 8:                 " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));
 9:     }
10: 
11:     // 设置编解码器为 Dubbo ，即 DubboCountCodec
12:     url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
13: 
14:     // 默认开启 heartbeat
15:     // enable heartbeat by default
16:     url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));
17: 
18:     // 连接服务器，创建客户端
19:     ExchangeClient client;
20:     try {
21:         // 懒连接，创建 LazyConnectExchangeClient 对象
22:         // connection should be lazy
23:         if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) {
24:             client = new LazyConnectExchangeClient(url, requestHandler);
25:         // 直接连接，创建 HeaderExchangeClient 对象
26:         } else {
27:             client = Exchangers.connect(url, requestHandler);
28:         }
29:     } catch (RemotingException e) {
30:         throw new RpcException("Fail to create remoting client for service(" + url + "): " + e.getMessage(), e);
31:     }
32:     return client;
33: }
```

- 第 2 至 9 行：校验配置的 Client 的 Dubbo SPI 拓展是否存在。若不存在，抛出 RpcException 异常。
- 第 12 行：设置编解码器为 `"Dubbo"` 协议，即 DubboCountCodec 。
- 第 16 行：默认开启**心跳**功能。
- 第 19 至 31 行：连接服务器，创建客户端。
  - 第 21 至 24 行：**懒加载**，创建 LazyConnectExchangeClient 对象。
  - 第 25 至 28 行：**直接连接**，创建 HeaderExchangeClient 对象。

## 4. Invoker

本文涉及的 Invoker 类图如下：

[![Invoker 类图](http://static.iocoder.cn/images/Dubbo/2018_05_04/04.png)](http://static.iocoder.cn/images/Dubbo/2018_05_04/04.png)Invoker 类图

#### 4.1 DubboInvoker

[`com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker`](https://github.com/YunaiV/dubbo/blob/8de6d56d06965a38712c46a0220f4e59213db72f/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboInvoker.java) ，实现 AbstractExporter 抽象类，Dubbo Invoker 实现类。代码如下：

```
 1: /**
 2:  * 远程通信客户端数组
 3:  */
 4: private final ExchangeClient[] clients;
 5: /**
 6:  * 使用的 {@link #clients} 的位置
 7:  */
 8: private final AtomicPositiveInteger index = new AtomicPositiveInteger();
 9: /**
10:  * 版本
11:  */
12: private final String version;
13: /**
14:  * 销毁锁
15:  *
16:  * 在 {@link #destroy()} 中使用
17:  */
18: private final ReentrantLock destroyLock = new ReentrantLock();
19: /**
20:  * Invoker 集合，从 {@link DubboProtocol#invokers} 获取
21:  */
22: private final Set<Invoker<?>> invokers;
23: 
24: public DubboInvoker(Class<T> serviceType, URL url, ExchangeClient[] clients) {
25:     this(serviceType, url, clients, null);
26: }
27: 
28: public DubboInvoker(Class<T> serviceType, URL url, ExchangeClient[] clients, Set<Invoker<?>> invokers) {
29:     super(serviceType, url, new String[]{Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY});
30:     this.clients = clients;
31:     // get version.
32:     this.version = url.getParameter(Constants.VERSION_KEY, "0.0.0");
33:     this.invokers = invokers;
34: }
```

- 胖友，请看属性上的代码注释。

- 第 29 行：调用父类构造方法。该方法中，会将

   

  ```
  interface
  ```

   

  ```
  group
  ```

   

  ```
  version
  ```

   

  ```
  token
  ```

   

  ```
  timeout
  ```

   

  添加到公用的隐式传参

   

  ```
  AbstractInvoker.attachment
  ```

   

  属性。

  - 🙂 代码比较简单，胖友请自己阅读。

## 5. Client

> 友情提示，涉及 Client 的内容，胖友先看过 [《精尽 Dubbo 源码分析 —— NIO 服务器》](http://svip.iocoder.cn/Dubbo/remoting-api-interface/?self) 所有的文章。

#### 5.1 ReferenceCountExchangeClient

[`com.alibaba.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/ReferenceCountExchangeClient.java) ，实现 ExchangeClient 接口，**支持指向计数**的信息交换客户端实现类。

**构造方法**

```
 1: /**
 2:  * URL
 3:  */
 4: private final URL url;
 5: /**
 6:  * 指向数量
 7:  */
 8: private final AtomicInteger refenceCount = new AtomicInteger(0);
 9: /**
10:  * 幽灵客户端集合
11:  */
12: private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap;
13: /**
14:  * 客户端
15:  */
16: private ExchangeClient client;
17: 
18: public ReferenceCountExchangeClient(ExchangeClient client, ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap) {
19:     this.client = client;
20:     // 指向加一
21:     refenceCount.incrementAndGet();
22:     this.url = client.getUrl();
23:     if (ghostClientMap == null) {
24:         throw new IllegalStateException("ghostClientMap can not be null, url: " + url);
25:     }
26:     this.ghostClientMap = ghostClientMap;
27: }
```

- ```
  refenceCount
  ```

   

  属性，指向计数。

  - 【初始】构造方法，【第 21 行】，计数加一。
  - 【引用】每次引用，计数加一。

- `ghostClientMap` 属性，幽灵客户端集合，和 `Protocol.ghostClientMap` 参数，一致。

- ```
  client
  ```

   

  属性，客户端。

  - 【创建】构造方法，传入 `client` 属性，指向它。
  - 【关闭】关闭方法，创建 LazyConnectExchangeClient 对象，指向该幽灵客户端。

**装饰器模式**

基于**装饰器模式**，所以，每个实现方法，都是调用 `client` 的对应的方法。例如：

```
@Override
public void send(Object message) throws RemotingException {
    client.send(message);
}
```

**计数**

```
public void incrementAndGetCount() {
    refenceCount.incrementAndGet();
}
```

**关闭**

```
 1: @Override
 2: public void close(int timeout) {
 3:     if (refenceCount.decrementAndGet() <= 0) {
 4:         // 关闭 `client`
 5:         if (timeout == 0) {
 6:             client.close();
 7:         } else {
 8:             client.close(timeout);
 9:         }
10:         // 替换 `client` 为 LazyConnectExchangeClient 对象。
11:         client = replaceWithLazyClient();
12:     }
13: }
```

- 第 3 行：计数**减一**。若无指向，进行真正的关闭。

- 第 4 至 9 行：调用 `client` 的关闭方法，进行关闭。

- 第 11 行：调用 `#replaceWithLazyClient()` 方法，替换 `client` 为 LazyConnectExchangeClient 对象。代码如下：

  ```
   1: private LazyConnectExchangeClient replaceWithLazyClient() {
   2:     // this is a defensive operation to avoid client is closed by accident, the initial state of the client is false
   3:     URL lazyUrl = url.addParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.FALSE)
   4:             .addParameter(Constants.RECONNECT_KEY, Boolean.FALSE) // 不重连
   5:             .addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString())
   6:             .addParameter("warning", Boolean.TRUE.toString())
   7:             .addParameter(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, true)
   8:             .addParameter("_client_memo", "referencecounthandler.replacewithlazyclient"); // 备注
   9: 
  10:     // 创建 LazyConnectExchangeClient 对象，若不存在。
  11:     String key = url.getAddress();
  12:     // in worst case there's only one ghost connection.
  13:     LazyConnectExchangeClient gclient = ghostClientMap.get(key);
  14:     if (gclient == null || gclient.isClosed()) {
  15:         gclient = new LazyConnectExchangeClient(lazyUrl, client.getExchangeHandler());
  16:         ghostClientMap.put(key, gclient);
  17:     }
  18:     return gclient;
  19: }
  ```

  - 第 3 至 8 行：基于 `url` ，创建 LazyConnectExchangeClient 的 URL 链接。设置的一些参数，结合 [「5.2 LazyConnectExchangeClient」](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/#) 一起看。
  - 第 10 至 17 行：创建 LazyConnectExchangeClient 对象，若不存在。

#### 5.2 LazyConnectExchangeClient

[`com.alibaba.dubbo.rpc.protocol.dubbo.LazyConnectExchangeClient`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/LazyConnectExchangeClient.java) ，实现 ExchangeClient 接口，**支持懒连接服务器**的信息交换客户端实现类。

**构造方法**

```
 1: static final String REQUEST_WITH_WARNING_KEY = "lazyclient_request_with_warning";
 2: 
 3: /**
 4:  * URL
 5:  */
 6: private final URL url;
 7: /**
 8:  * 通道处理器
 9:  */
10: private final ExchangeHandler requestHandler;
11: /**
12:  * 连接锁
13:  */
14: private final Lock connectLock = new ReentrantLock();
15: /**
16:  * lazy connect 如果没有初始化时的连接状态
17:  */
18: // lazy connect, initial state for connection
19: private final boolean initialState;
20: /**
21:  * 通信客户端
22:  */
23: private volatile ExchangeClient client;
24: /**
25:  * 请求时，是否检查告警
26:  */
27: protected final boolean requestWithWarning;
28: /**
29:  * 警告计数器。每超过一定次数，打印告警日志。参见 {@link #warning(Object)}
30:  */
31: private AtomicLong warningcount = new AtomicLong(0);
32: 
33: public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler) {
34:     // lazy connect, need set send.reconnect = true, to avoid channel bad status.
35:     this.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString());
36:     this.requestHandler = requestHandler;
37:     this.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE);
38:     this.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, false);
39: }
```

- `initialState` 属性，如果没有初始化客户端时的链接状态。有点绕，看 `#isConnected()` 方法，代码如下：

  ```
  @Override
  public boolean isConnected() {
      if (client == null) { // 客户端未初始化
          return initialState;
      } else {
          return client.isConnected();
      }
  }
  ```

  - 所以，我们可以看到 ReferenceCountExchangeClient 关闭创建的 LazyConnectExchangeClient 对象的 `initialState = false` ，未连接。
  - **默认值**，`DEFAULT_LAZY_CONNECT_INITIAL_STATE = true` 。

- `requestWithWarning` 属性，请求时，是否检查告警。

  - 所以，我们可以看到 ReferenceCountExchangeClient 关闭创建的 LazyConnectExchangeClient 对象的 `initialState = false` ，未连接。
  - **默认值**，`false` 。

- `warningcount` 属性，警告计数器。每超过一定次数，打印告警日志。每次发送请求时，会调用 `#warning(request)` 方法，根据情况，打印告警日志。代码如下：

  ```
  private void warning(Object request) {
      if (requestWithWarning) { // 开启
          if (warningcount.get() % 5000 == 0) { // 5000 次
              logger.warn(new IllegalStateException("safe guard client , should not be called ,must have a bug."));
          }
          warningcount.incrementAndGet(); // 增加计数
      }
  }
  ```

  - 理论来说，不会被调用。如果被调用，那么就是一个 BUG 咯。

**装饰器模式**

基于**装饰器模式**，所以，每个实现方法，都是调用 `client` 的对应的方法。例如：

```
@Override
@Override
public void close(int timeout) {
    if (client != null)
        client.close(timeout);
}
```

**初始化客户端**

```
private void initClient() throws RemotingException {
    // 已初始化，跳过
    if (client != null) {
        return;
    }
    if (logger.isInfoEnabled()) {
        logger.info("Lazy connect to " + url);
    }
    // 获得锁
    connectLock.lock();
    try {
        // 已初始化，跳过
        if (client != null) {
            return;
        }
        // 创建 Client ，连接服务器
        this.client = Exchangers.connect(url, requestHandler);
    } finally {
        // 释放锁
        connectLock.unlock();
    }
}
```

- 发送消息/请求前，都会调用该方法，保证客户端已经初始化。代码如下：

```
public void send(Object message, boolean sent) throws RemotingException {
    initClient();
    client.send(message, sent);
}

@Override
public ResponseFuture request(Object request, int timeout) throws RemotingException {
    warning(request);
    initClient();
    return client.request(request, timeout);
```