# 1、抽象 API

## 1. 概述

从本文开始，我们来分享 Dubbo 的**集群容错**功能的实现。

在 [《精尽 Dubbo 源码分析 —— 项目结构一览》](http://svip.iocoder.cn/Dubbo/intro/?self) 的 [「3.4 dubbo-cluster」](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) 中，我们对 Dubbo 的 `dubbo-cluster` 项目，做了整体的代码结构做了介绍。如果已经没什么印象的胖友，请先回过头找回失散的记忆。

Dubbo 对集群容错功能，实现了很好的 `package` 拆分，因此我们按照如下顺序：

1. 抽象 API

- Cluster 实现
- Directory 实现
- LoadBalance 实现
- Merger 实现
- Router 实现
- Configurator 实现

**一个主题，对应一篇文章**。那么，本文当然是分享**抽象 API**。考虑到干巴巴的看抽象 API 会很容易一脸懵逼，所以我们会使用 **FailoverCluster** 贯穿本文。

## 2. 整体流程

> [![集群容错](http://static.iocoder.cn/images/Dubbo/2018_01_04/09.png)](http://static.iocoder.cn/images/Dubbo/2018_01_04/09.png)集群容错

- 🙂 只看红线。

- 左边 invoke

   

  ：通过 Cluster 暴露

   

  Invoker

   

  对象，从而实现

  统一

  、

  透明

  的调用过程。

  - 无法理解？详细解析，见 [「3. Cluster」](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) 。

- **右边 list** ：通过 Directory 中，**获取**可调用的 Invoker 集合。

- **右边 route** ：通过 Router ，**过滤**符合**路由规则**的 Invoker 集合。

- **右边 select** ：通过 LoadBalance ，根据**负载均衡机制**，**选择**一个符合的 Invoker 对象。

- **右边 invoke** ：调用该 Invoker 对象。

## 3. Cluster

`com.alibaba.dubbo.rpc.cluster.Cluster` ，集群接口。代码如下：

```
@SPI(FailoverCluster.NAME)
public interface Cluster {

    /**
     * Merge the directory invokers to a virtual invoker.
     *
     * 基于 Directory ，创建 Invoker 对象，实现统一、透明的 Invoker 调用过程
     *
     * @param directory Directory 对象
     * @param <T>  泛型
     * @return cluster invoker
     * @throws RpcException
     */
    @Adaptive
    <T> Invoker<T> join(Directory<T> directory) throws RpcException;

}
```

- `@SPI(FailoverCluster.NAME)` 注解，Dubbo SPI **拓展点**，默认为 `"failover"` ，即**失败重试**，也就是会贯穿本文的 FailoverCluster 类。
- `@Adaptive` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Cluster 实现，使用 `URL.cluster` 属性。
- `#join(Directory<T>)` 接口方法，基于 Directory ，创建 Invoker 对象，实现统一、透明的 Invoker 调用过程。

#### 3.1 join 方法

在 RegistryProtocol 的 `#doRefer(Cluster, Registry, type, url)` 方法中，会调用 `Cluster#join(directory)` 方法，创建 Invoker 对象。代码如下：

```
private Cluster cluster; // <1>

private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
    // 创建 RegistryDirectory 对象，并设置注册中心 <2>
    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
    directory.setRegistry(registry);
    directory.setProtocol(protocol);
    
    // ... 省略无关代码

    // 创建 Invoker 对象 <3>
    Invoker invoker = cluster.join(directory);
    // 向本地注册表，注册消费者
    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
    return invoker;
}
```

- `<1>` ：`cluster` 属性，`Cluster$Adaptive` 对象
- `<2>` ：创建 RegistryDirectory 对象。通过它，可以注册到**一个**注册中心的所有服务**提供者**，即上文提到的【右边 list】。
- `<3>` ：调用 `Cluster#join(directory)` 方法，创建 Invoker 对象。因为 `cluster` 是 Dubbo SPI Adaptive 类，所以可以自动获取到**对应的** Cluster 实现类。

#### 3.2 子类

[![Cluster 子类](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)Cluster 子类

我们可以看到，每个 Cluster 实现类，对应一个**专属**于其的 Invoker 实现类。本文分享的 FailoverCluster 的对应的 Invoker 为 FailoverClusterInvoker 。在看具体的代码之前，先一起来看看**集群容错的调用( invoke )过程**。

## 4. 调用顺序图

如下是服务**消费者**的调用顺序图：

[![顺序图](http://static.iocoder.cn/images/Dubbo/2019_04_01/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/02.png)顺序图

- 在 InvokerInvocationHandler 的 【4】`#invoke(invocation)` 处**插入**：**先**调用**集群容错 Invoker** 的 `#invoke(invocation)` ，**再**调用 `ProtocolFilterWrapper$Invoker` 的 `#invoke(invocation)` 。

- 调用栈

  如下图：

  ![调用栈](http://static.iocoder.cn/images/Dubbo/2019_04_01/03.png)

  调用栈

  - MockClusterInvoker ，胖友先无视，后续有详细文章，进行分享。

## 5. FailoverCluster

`com.alibaba.dubbo.rpc.cluster.support.FailoverCluster` ，实现 Cluster 接口，失败自动切换，当出现失败，重试其它服务器。通常用于**读操作**，但重试会带来更长延迟。可通过 `retries="2"` 来设置重试次数(不含第一次)。代码如下：

```
public class FailoverCluster implements Cluster {

    public final static String NAME = "failover";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailoverClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 为 FailoverClusterInvoker 。

## 6. AbstractClusterInvoker

因为，FailoverClusterInvoker 继承 AbstractClusterInvoker ，所以我们来分享它。

`com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker` ，实现 Invoker 接口，Cluster Invoker 抽象类：

- **实现**例如选择一个符合 Invoker 对象等等**公用**方法

- **定义** `#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` **抽象**方法，实现子 Cluster 的 Invoker 实现类的**服务调用**的差异逻辑，代码如下：

  ```
  protected abstract Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException;
  ```

#### 6.1 构造方法

```
/**
 * Directory 对象
 */
protected final Directory<T> directory;
/**
 * 集群时是否排除非可用( available )的 Invoker ，默认为 true
 */
protected final boolean availablecheck;
/**
 * 是否已经销毁
 */
private AtomicBoolean destroyed = new AtomicBoolean(false);
/**
 * 粘滞连接 Invoker
 *
 * http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html
 * 粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。
 * 粘滞连接将自动开启延迟连接，以减少长连接数。
 */
private volatile Invoker<T> stickyInvoker = null;

public AbstractClusterInvoker(Directory<T> directory) {
    this(directory, directory.getUrl());
}

public AbstractClusterInvoker(Directory<T> directory, URL url) {
    // 初始化 directory
    if (directory == null) {
        throw new IllegalArgumentException("service directory == null");
    }
    this.directory = directory;
    // sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.
    // 初始化 availablecheck
    this.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);
}
```

- `directory` 字段，Directory 对象。通过它，可以获得所有服务提供者的 Invoker 对象。

- `availablecheck` 字段，集群时是否排除非可用( available )的 Invoker ，默认为 `"true"` ，通过 `"cluster.availablecheck"` 配置项设置。

- `destroyed` 字段，是否已经销毁。若已经销毁，则不允许在调用。

- `stickyInvoker` 字段，粘滞连接 Invoker ，参见 [《Dubbo 用户指南 —— 粘滞连接
  》](http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html) 文档。

  > 粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。

#### 6.2 list

`#list(Invocation)` 方法，获得所有服务提供者 Invoker 集合。代码如下：

```
protected List<Invoker<T>> list(Invocation invocation) throws RpcException {
    return directory.list(invocation);
}
```

#### 6.3 select

`#select(LoadBalance, Invocation, invokers, selected)` 方法，从**候选**的 Invoker 集合，选择一个**最终调用**的 Invoker 对象。代码如下：

```
/**
 * 使用 loadbalance 选择 invoker.
 *
 * @param loadbalance Loadbalance 对象，提供负责均衡策略
 * @param invocation Invocation 对象
 * @param invokers   候选的 Invoker 集合
 * @param selected    已选过的 Invoker 集合. 注意：输入保证不重复
 * @return 最终的 Invoker 对象
 * @throws RpcException 当发生 RpcException 时
 */
  1: protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
  2:     if (invokers == null || invokers.isEmpty()) {
  3:         return null;
  4:     }
  5:     // 获得 sticky 配置项，方法级
  6:     String methodName = invocation == null ? "" : invocation.getMethodName();
  7:     boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);
  8:     {
  9:         // ignore overloaded method
 10:         // 若 stickyInvoker 不存在于 invokers 中，说明不在候选中，需要置空，重新选择
 11:         if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
 12:             stickyInvoker = null;
 13:         }
 14:         // ignore cucurrent problem
 15:         // 若开启粘滞连接的特性，且 stickyInvoker 不存在于 selected 中，则返回 stickyInvoker 这个 Invoker 对象
 16:         if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
 17:             // 若开启排除非可用的 Invoker 的特性，则校验 stickyInvoker 是否可用。若可用，则进行返回
 18:             if (availablecheck && stickyInvoker.isAvailable()) {
 19:                 return stickyInvoker;
 20:             }
 21:         }
 22:     }
 23: 
 24:     // 执行选择
 25:     Invoker<T> invoker = doselect(loadbalance, invocation, invokers, selected);
 26: 
 27:     // 若开启粘滞连接的特性，记录最终选择的 Invoker 到 stickyInvoker
 28:     if (sticky) {
 29:         stickyInvoker = invoker;
 30:     }
 31:     return invoker;
 32: }
```

- 该方法主要处理**粘滞连接**的特性，具体使用 Loadbalance 选择 Invoker 对象的逻辑，在 `#doselect(loadbalance, invocation, invokers, selected)` 方法中。

- 第 5 至 22 行：获得

  粘滞连接

   

  ```
  stickyInvoker
  ```

   

  对象。

  - 第 6 至 7 行：获得方法级的 `sticky` 配置项。

  - 第 9 至 13 行：若 `stickyInvoker` 不存在于 `invokers` 中，说明不在候选中，需要置空，重新选择。

  - 第 14 至 21 行：获得

    粘滞连接

     

    ```
    stickyInvoker
    ```

     

    对象。如要满足如下

    条件

    ：

    - 第 16 行：1）开启粘滞连接的特性；2）`stickyInvoker` 不存在于 `selected` 中。
    - 第 18 行：若开启**排除非可用**的 Invoker 的特性，则校验 `stickyInvoker` 是否可用。

- 第 25 行：调用 `#doselect(loadbalance, invocation, invokers, selected)` 方法，执行选择一个 Invoker 对象。

- 第 27 至 30 行：若开启**粘滞连接**的特性，记录最终选择的 Invoker 对象，到 `stickyInvoker` 中。

###### 6.3.1 doselect

`#doselect(loadbalance, invocation, invokers, selected)` 方法，从**候选**的 Invoker 集合，选择一个**最终调用**的 Invoker 对象。代码如下：

```
 1: private Invoker<T> doselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
 2:     if (invokers == null || invokers.isEmpty()) {
 3:         return null;
 4:     }
 5:     // 【第一种】如果只有一个 Invoker ，直接选择
 6:     if (invokers.size() == 1) {
 7:         return invokers.get(0);
 8:     }
 9:     // 【第二种】如果只有两个 Invoker ，退化成轮循
10:     // If we only have two invokers, use round-robin instead.
11:     if (invokers.size() == 2 && selected != null && !selected.isEmpty()) {
12:         return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0);
13:     }
14: 
15:     // 【第三种】使用 Loadbalance ，选择一个 Invoker 对象。
16:     Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
17: 
18:     // If the `invoker` is in the  `selected` or invoker is unavailable && availablecheck is true, reselect.
19:     // 如果 selected中包含（优先判断） 或者 不可用&&availablecheck=true 则重试.
20:     if ((selected != null && selected.contains(invoker))
21:             || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
22:         try {
23:             //【第四种】重选一个 Invoker 对象
24:             Invoker<T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
25:             if (rinvoker != null) {
26:                 invoker = rinvoker;
27:             } else {
28:                 // Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
29:                 // 【第五种】看下第一次选的位置，如果不是最后，选+1位置.
30:                 int index = invokers.indexOf(invoker);
31:                 try {
32:                     // Avoid collision
33:                     // 最后在避免碰撞
34:                     invoker = index < invokers.size() - 1 ? invokers.get(index + 1) : invoker;
35:                 } catch (Exception e) {
36:                     logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
37:                 }
38:             }
39:         } catch (Throwable t) {
40:             logger.error("clustor relselect fail reason is :" + t.getMessage() + " if can not slove ,you can set cluster.availablecheck=false in url", t);
41:         }
42:     }
43:     return invoker;
44: }
```

- 有**五种**选择最终调用的 Invoker 对象的方式。

- 【第一种】第 5 至 8 行：如果只有**一个候选**的 Invoker 对象，直接选择返回。😈 因为没的选择了。

- 【第二种】第 9 至 13 行：如果只有**两个候选**的 Invoker 集合，退化为轮询。此处存在一个 BUG ：

  > 转载自我**飞哥**，[《dubbo 源码 - 负载均衡》](https://www.jianshu.com/p/10c30d7b8b6a)
  >
  > 这里退化成轮询的实现有问题，对应源码`return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0)；`如果retries=4，即最多调用5次，且两个可选invoke分别为：
  >
  > 10.0.0.1:20884，10.0.0.1:20886；
  >
  > 那么5次选择的invoke为：
  >
  > - 10.0.0.1:20884
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886，
  >
  > 即除了第1次外后面的选择都是选择**第二个**invoker;
  >
  > 因次需要把selected.get(0)修改为：selected.get(selected.size()-1)；
  >
  > 即每次拿前一次选择的invoker与 invokers.get(0)比较，如果相同，则选则另一个invoker；否则就选 invokers.get(0)；

  - 比较有趣的是，[ISSUE#934：Extension of LoadBalance (a small suggestion for loadbalance policy when there’s less than 2 providers) ](https://github.com/apache/incubator-dubbo/issues/934)。和上述 BUG 无关，胖友自己理解下。

- 【第三种】第 16 至 21 行：调用 `Loadbalance#select(invokers, url, invocation)` 方法，使用 Loadbalance ，选择一个 Invoker 对象。具体的代码实现，见 Loadbalance 的文章。

  - 这种方式的返回，选择的 Invoker 对象，需要满足**两个**条件：1）不存在于 `selected` 中。2）Invoker 是可用的，若开启排除非可用的 Invoker 的特性。

- 【第四种】调用 `#reselect(loadbalance, invocation, invokers, selected, availablecheck)` 方法，重新选择一个 Invoker 对象。😈 因为此时 `invokers` 中，无法找到一个满足条件的 Invoker 对象。详细解析，见 [「6.3.2 reselect」](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) 。

- 【第五种】**顺序**从候选的 `invokers` 集合中，选择一个 Invoker 对象，不考虑是否**可用**，又或者**已经选择过**，类似【第一种】【第二种】的方式。😈总之，保证能获取到一个 Invoker 对象。

###### 6.3.2 reselect

`#reselect(loadbalance, invocation, invokers, selected, availablecheck)` 方法，重新选择一个 Invoker 对象。代码如下：

```
 1: private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availablecheck) throws RpcException {
 2:     // Allocating one in advance, this list is certain to be used.
 3:     // 预先分配一个，这个列表是一定会用到的.
 4:     List<Invoker<T>> reselectInvokers = new ArrayList<Invoker<T>>(invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());
 5: 
 6:     // First, try picking a invoker not in `selected`.
 7:     // 先从非select中选
 8:     if (availablecheck) { // invoker.isAvailable() should be checked
 9:         // 获得非选择过，并且可用的 Invoker 集合
10:         for (Invoker<T> invoker : invokers) {
11:             if (invoker.isAvailable()) { // 并且可用
12:                 if (selected == null || !selected.contains(invoker)) {
13:                     reselectInvokers.add(invoker);
14:                 }
15:             }
16:         }
17:         // 使用 Loadbalance ，选择一个 Invoker 对象。
18:         if (!reselectInvokers.isEmpty()) {
19:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
20:         }
21:     } else { // do not check invoker.isAvailable()
22:         // 获得非选择过的 Invoker 集合
23:         for (Invoker<T> invoker : invokers) {
24:             if (selected == null || !selected.contains(invoker)) {
25:                 reselectInvokers.add(invoker);
26:             }
27:         }
28:         // 使用 Loadbalance ，选择一个 Invoker 对象。
29:         if (!reselectInvokers.isEmpty()) {
30:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
31:         }
32:     }
33:     // Just pick an available invoker using loadbalance policy
34:     // 最后从select中选可用的.
35:     {
36:         // 获得选择过的，并且可用的 Invoker 集合
37:         if (selected != null) {
38:             for (Invoker<T> invoker : selected) {
39:                 if ((invoker.isAvailable()) // available first
40:                         && !reselectInvokers.contains(invoker)) {
41:                     reselectInvokers.add(invoker);
42:                 }
43:             }
44:         }
45:         // 使用 Loadbalance ，选择一个 Invoker 对象。
46:         if (!reselectInvokers.isEmpty()) {
47:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
48:         }
49:     }
50:     return null;
51: }
```

- 第 4 行：预先创建一个重选 Invoker 集合，我们会发现很奇怪的一段 `invokers.size() - 1` 代码。这是为什么呢？笔者的理解是，出现重选 `#reselect(...)` 的原因，说明 `#doselect(...)` 的【第三种】选择的 Invoker 对象，在 `selected` 中，因此需要**去掉一个**。

- 一共有

  两类三种

  的选择方式：

  - 【第一种】第 10 至 16 行：获得**非选择过**( `invokers` )， 并且**必须**可用的 Invoker 集合。
  - 【第二种】第 22 至 27 行：获得**非选择过**( `invokers` )， 并且**不考虑**可用的 Invoker 集合。
  - 【第三种】第 36 至 44 行：获得**选择过**( `selected` )，并且**必须**可用的 Invoker 集合。

- 第 19 行 || 第 30 行 || 第 47 行：调用 `Loadbalance#select(invokers, url, invocation)` 方法，使用 Loadbalance ，选择一个 Invoker 对象。

#### 6.4 invoke

`#invoke(invocation)` 方法，调用服务**提供者**的逻辑。代码如下：

```
 1: @Override
 2: public Result invoke(final Invocation invocation) throws RpcException {
 3:     // 校验是否销毁
 4:     checkWhetherDestroyed();
 5: 
 6:     // 获得所有服务提供者 Invoker 集合
 7:     List<Invoker<T>> invokers = list(invocation);
 8: 
 9:     // 获得 LoadBalance 对象
10:     LoadBalance loadbalance;
11:     if (invokers != null && !invokers.isEmpty()) {
12:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()
13:                 .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));
14:     } else {
15:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);
16:     }
17: 
18:     // 设置调用编号，若是异步调用
19:     RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
20: 
21:     // 执行调用
22:     return doInvoke(invocation, invokers, loadbalance);
23: }
```

- 第 4 行：调用 `#checkWhetherDestroyed()` 方法，**校验**是否已经销毁。代码如下：

  ```
  protected void checkWhetherDestroyed() {
      if (destroyed.get()) {
          throw new RpcException("Rpc cluster invoker for " + getInterface() + " on consumer " + NetUtils.getLocalHost()
                  + " use dubbo version " + Version.getVersion()
                  + " is now destroyed! Can not invoke any more.");
      }
  }
  ```

- 第 7 行：调用 `#list(invocation)` 方法，基于 Directory ，获得所有服务提供者 Invoker 集合。

- 第 9 至 16 行：获得 Loadbalance 对象。

- 第 19 行：调用 `RpcUtils#attachInvocationIdIfAsync(url, invocation)` 方法，设置**调用编号**，若是异步调用。

- 第 22 行：调用 `#doInvoke(invocation, invokers, loadbalance)` **抽象**方法，执行调用。🙂 子 Cluster 的 Invoker 实现类的**服务调用**的差异逻辑。

#### 6.5 其它实现方法

###### 6.5.1 getInterface

```
@Override
public Class<T> getInterface() {
    return directory.getInterface();
}
```

###### 6.5.2 getUrl

```
@Override
public URL getUrl() {
    return directory.getUrl();
}
```

###### 6.5.3 isAvailable

```
@Override
public boolean isAvailable() {
    // 如有粘滞连接 Invoker ，基于它判断。
    Invoker<T> invoker = stickyInvoker; // 指向，避免并发
    if (invoker != null) {
        return invoker.isAvailable();
    }
    // 基于 Directory 判断
    return directory.isAvailable();
}
```

###### 6.5.4 checkInvokers

```
protected void checkInvokers(List<Invoker<T>> invokers, Invocation invocation) {
    if (invokers == null || invokers.isEmpty()) {
        throw new RpcException("Failed to invoke the method "
                + invocation.getMethodName() + " in the service " + getInterface().getName()
                + ". No provider available for the service " + directory.getUrl().getServiceKey()
                + " from registry " + directory.getUrl().getAddress()
                + " on the consumer " + NetUtils.getLocalHost()
                + " using the dubbo version " + Version.getVersion()
                + ". Please check if the providers have been started and registered.");
    }
}
```

###### 6.5.5 destroy

```
@Override
public void destroy() {
    if (destroyed.compareAndSet(false, true)) {
        directory.destroy();
    }
}
```

## 7. FailoverClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，**FailoverCluster** Invoker 实现类。

失败自动切换，当出现失败，重试其它服务器。通常用于**读操作**，但重试会带来更长延迟。可通过 `retries="2"` 来设置重试次数(不含第一次)。

在看具体的 `#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` 的实现代码之前，我们先来瞅瞅**调用顺序图**：

[![调用顺序图](http://static.iocoder.cn/images/Dubbo/2019_04_01/04.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/04.png)调用顺序图

- 实际逻辑很简单：**循环**，查找一个 Invoker 对象，进行调用，直到**成功**。

`#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` 方法，代码如下：

```
 1: @Override
 2: public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
 3:     List<Invoker<T>> copyinvokers = invokers;
 4:     // 检查copyinvokers即可用Invoker集合是否为空，如果为空，那么抛出异常
 5:     checkInvokers(copyinvokers, invocation);
 6:     // 得到最大可调用次数：最大可重试次数+1，默认最大可重试次数Constants.DEFAULT_RETRIES=2
 7:     int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;
 8:     if (len <= 0) {
 9:         len = 1;
10:     }
11:     // 保存最后一次调用的异常
12:     RpcException le = null;
13:     // 保存已经调用过的Invoker
14:     List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.
15:     Set<String> providers = new HashSet<String>(len);
16:     // failover机制核心实现：如果出现调用失败，那么重试其他服务器
17:     for (int i = 0; i < len; i++) {
18:         // 重试时，进行重新选择，避免重试时invoker列表已发生变化.
19:         // 注意：如果列表发生了变化，那么invoked判断会失效，因为invoker示例已经改变
20:         if (i > 0) {
21:             checkWhetherDestroyed();
22:             // 根据Invocation调用信息从Directory中获取所有可用Invoker
23:             copyinvokers = list(invocation);
24:             // check again
25:             // 重新检查一下
26:             checkInvokers(copyinvokers, invocation);
27:         }
28:         // 根据负载均衡机制从copyinvokers中选择一个Invoker
29:         Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);
30:         // 保存每次调用的Invoker
31:         invoked.add(invoker);
32:         // 设置已经调用的 Invoker 集合，到 Context 中
33:         RpcContext.getContext().setInvokers((List) invoked);
34:         try {
35:             // RPC 调用得到 Result
36:             Result result = invoker.invoke(invocation);
37:             // 重试过程中，将最后一次调用的异常信息以 warn 级别日志输出
38:             if (le != null && logger.isWarnEnabled()) {
39:                 logger.warn("Although retry the method " + invocation.getMethodName()
40:                         + " in the service " + getInterface().getName()
41:                         + " was successful by the provider " + invoker.getUrl().getAddress()
42:                         + ", but there have been failed providers " + providers
43:                         + " (" + providers.size() + "/" + copyinvokers.size()
44:                         + ") from the registry " + directory.getUrl().getAddress()
45:                         + " on the consumer " + NetUtils.getLocalHost()
46:                         + " using the dubbo version " + Version.getVersion() + ". Last error is: "
47:                         + le.getMessage(), le);
48:             }
49:             return result;
50:         } catch (RpcException e) {
51:             // 如果是业务性质的异常，不再重试，直接抛出
52:             if (e.isBiz()) { // biz exception.
53:                 throw e;
54:             }
55:             // 其他性质的异常统一封装成RpcException
56:             le = e;
57:         } catch (Throwable e) {
58:             le = new RpcException(e.getMessage(), e);
59:         } finally {
60:             providers.add(invoker.getUrl().getAddress());
61:         }
62:     }
63:     // 最大可调用次数用完还得到Result的话，抛出RpcException异常：重试了N次还是失败，并输出最后一次异常信息
64:     throw new RpcException(le != null ? le.getCode() : 0, "Failed to invoke the method "
65:             + invocation.getMethodName() + " in the service " + getInterface().getName()
66:             + ". Tried " + len + " times of the providers " + providers
67:             + " (" + providers.size() + "/" + copyinvokers.size()
68:             + ") from the registry " + directory.getUrl().getAddress()
69:             + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
70:             + Version.getVersion() + ". Last error is: "
71:             + (le != null ? le.getMessage() : ""), le != null && le.getCause() != null ? le.getCause() : le);
72: }
```

- 第 3 行：`copyinvokers` 变量，候选的 Invoker 集合。

- 第 5 行：调用**父** `#checkInvokers(copyinvokers, invocation)` 方法，**校验**候选的 Invoker 集合**非空**。如果为空，抛出 RpcException 异常。

- 第 6 至 10 行：获得**最大可调用次数**：最大**可重试**次数 +1 。默认最大可重试次数`Constants.DEFAULT_RETRIES = 2` 。

- 第 12 行：`le` 变量，保存最后一次调用的**异常**。

- 第 14 行：`invoked` 变量，保存已经调用的 Invoker 集合。

- 第 15 行：`providers` 变量，保存已经调用的**网络地址**集合。

- 第 16 至 62 行：

  failover 机制核心实现：如果出现调用失败，那么重试其他服务器

  。

  - 第 20 至 27 行：**重试时**( `i > 0` )， 进行重新选择，避免重试时，候选 Invoker 集合，已发生变化。
  - 【重要】第 29 行：调用**父** `#select(loadbalance, invocation, copyinvokers, invoked)` 方法，根据 Loadbalance 负载均衡机制，从 `copyinvokers` 中，选择一个被调用的 Invoker 对象。
  - 第 31 行：保存每次调用的 Invoker 对象，到 `invoked` 中。
  - 第 33 行：保存已经调用的 Invoker 集合，到 Context 中。
  - 【重要】第 36 行：调用 `Invoker#invoke(invocation)` 方法，**发起 RPC 调用**。
  - 第 37 至 48 行：若 `le` 非空，说明此时是**重试调用成功**，将最后一次调用的异常信息以 **warn** 级别日志输出，方便未来追溯。
  - ========== 异常相关 ===========
  - 第 55 至 54 行：如果是业务性质的异常，不再重试，直接抛出。
  - 第 56 行：保存异常到 `le` 。
  - 第 58 行：非 RpcException 异常，**封装**成 RpcException 异常。
  - 第 59 至 61 行：保存每次调用的**网络地址**，到 `providers` 中。

- 第 63 至 71 行：超过最大调用次数，抛出 RpcException 异常。该异常中，带有最后一次调用异常的信息。

# 2、Cluster 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self) 一文，分享 `dubbo-cluster` 模块， `support` 包，**各种 Cluster 实现类**。

Cluster 子类如下图：

[![Cluster 子类](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)Cluster 子类

我们可以看到，每个 Cluster 实现类，对应一个**专属**于其的 Invoker 实现类。下面，我们一个一个子类往下看。

> 老艿艿：本文对应 [《Dubbo 用户指南 —— 集群容错》](http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html) 文档。

## 2. AvailableCluster

`com.alibaba.dubbo.rpc.cluster.support.AvailableCluster` ，实现 Cluster 接口，调用**首个可用**服务器，目前用于[多注册中心引用](http://dubbo.apache.org/zh-cn/docs/user/demos/multi-registry.html#多注册中心注册)。代码如下：

```
public class AvailableCluster implements Cluster {

    public static final String NAME = "available";

    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new AvailableClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 AvailableClusterInvoker 。

#### 2.1 AvailableClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.AvailableClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，AvailableCluster Invoker 实现类。代码如下：

```
public class AvailableClusterInvoker<T> extends AbstractClusterInvoker<T> {

    public AvailableClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // 循环候选的 Invoker 集合，调用首个可用的 Invoker 对象。
        for (Invoker<T> invoker : invokers) {
            if (invoker.isAvailable()) { // 可用
                // 发起 RPC 调用
                return invoker.invoke(invocation);
            }
        }
        throw new RpcException("No provider available in " + invokers);
    }

}
```

## 3. BroadcastCluster

`com.alibaba.dubbo.rpc.cluster.support.BroadcastCluster` ，实现 Cluster 接口，广播调用**所有**提供者，逐个调用，**任意**一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。代码如下：

```
public class BroadcastCluster implements Cluster {

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new BroadcastClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 BroadcastClusterInvoker 。

#### 3.1 BroadcastClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.BroadcastClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，BroadcastCluster Invoker 实现类。代码如下：

```
public class BroadcastClusterInvoker<T> extends AbstractClusterInvoker<T> {

    private static final Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker.class);

    public BroadcastClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    @SuppressWarnings({"unchecked", "rawtypes"})
    public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常
        checkInvokers(invokers, invocation);
        // 设置已经调用的 Invoker 集合，到 Context 中
        RpcContext.getContext().setInvokers((List) invokers);
        // 保存最后一次调用的异常
        RpcException exception = null;
        // 保存最后一次调用的结果
        Result result = null;
        // 循环候选的 Invoker 集合，调用所有 Invoker 对象。
        for (Invoker<T> invoker : invokers) {
            try {
                // 发起 RPC 调用
                result = invoker.invoke(invocation);
            } catch (RpcException e) {
                exception = e;
                logger.warn(e.getMessage(), e);
            } catch (Throwable e) {
                exception = new RpcException(e.getMessage(), e); // 封装成 RpcException 异常
                logger.warn(e.getMessage(), e);
            }
        }
        // 若存在一个异常，抛出该异常
        if (exception != null) {
            throw exception;
        }
        return result;
    }

}
```

## 4. FailbackCluster

`com.alibaba.dubbo.rpc.cluster.support.FailbackCluster` ，实现 Cluster 接口，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。代码如下：

```
public class FailbackCluster implements Cluster {

    public final static String NAME = "failback";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailbackClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 FailbackClusterInvoker 。

#### 4.1 FailbackClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，FailbackCluster Invoker 实现类。

###### 4.1.1 构造方法

```
/**
 * 重试频率
 */
private static final long RETRY_FAILED_PERIOD = 5 * 1000;

/**
 * ScheduledExecutorService 对象
 */
private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2, new NamedThreadFactory("failback-cluster-timer", true));
/**
 * 失败任务集合
 */
private final ConcurrentMap<Invocation, AbstractClusterInvoker<?>> failed = new ConcurrentHashMap<Invocation, AbstractClusterInvoker<?>>();
/**
 * 重试任务 Future
 */
private volatile ScheduledFuture<?> retryFuture;

public FailbackClusterInvoker(Directory<T> directory) {
    super(directory);
}
```

- 所有字段，都是和重试相关，胖友看下注释。

###### 4.1.2 doInvoke

```
@Override
protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    try {
        // 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常
        checkInvokers(invokers, invocation);
        // 根据负载均衡机制从 invokers 中选择一个Invoker
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        // RPC 调用得到 Result
        return invoker.invoke(invocation);
    } catch (Throwable e) {
        logger.error("Failback to invoke method " + invocation.getMethodName() + ", wait for retry in background. Ignored exception: " + e.getMessage() + ", ", e);
        // 添加到失败任务
        addFailed(invocation, this);
        return new RpcResult(); // ignore
    }
}
```

- 若 RPC 调用失败，则调用 `#addFailed(invocation, this)` 方法，添加到 `failed` 中，后台定时重试。

###### 4.1.3 addFailed

```
private void addFailed(Invocation invocation, AbstractClusterInvoker<?> router) {
    // 若定时任务未初始化，进行创建
    if (retryFuture == null) {
        synchronized (this) {
            if (retryFuture == null) {
                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {

                    public void run() {
                        // collect retry statistics
                        try {
                            retryFailed();
                        } catch (Throwable t) { // Defensive fault tolerance
                            logger.error("Unexpected error occur at collect statistic", t);
                        }
                    }
                }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);
            }
        }
    }
    // 添加到失败任务
    failed.put(invocation, router);
}
```

- 创建的定时任务，会调用 `#retryFailed()` 方法，重试任务，发起 RCP 调用。

###### 4.1.4 retryFailed

```
void retryFailed() {
    if (failed.size() == 0) {
        return;
    }
    // 循环重试任务，逐个调用
    for (Map.Entry<Invocation, AbstractClusterInvoker<?>> entry : new HashMap<Invocation, AbstractClusterInvoker<?>>(failed).entrySet()) { // 创建集合
        Invocation invocation = entry.getKey();
        Invoker<?> invoker = entry.getValue();
        try {
            // RPC 调用得到 Result
            invoker.invoke(invocation);
            // 移除失败任务
            failed.remove(invocation);
        } catch (Throwable e) {
            logger.error("Failed retry to invoke method " + invocation.getMethodName() + ", waiting again.", e);
        }
    }
}
```

- 循环重试任务，逐个发起 RPC 调用。若调用成功，移除该失败任务出 `failed` 集合。

在极端情况下，存在一个 BUG ，复现步骤如下：

1. 假设目前有两个服务提供者 A、B 。
2. 首先调用 A 服务，假设超时，添加到 `failed` 中。
3. 重试调用 B 服务（A 服务亦可），假设再次超时，添加到 `failed` 中。
4. 因为 `#doInvoker(...)` 方法，调用失败，不会抛出异常（当然也不能），导致 `#retryFailed(...)` 方法，**误以为**调用成功，错误的移除该失败任务出 `failed` 集合。

那么能不能在 `#retryFailed(...)` 方法中，先移除该失败任务出 `failed` 集合呢，再发起 PRC 调用呢？答案是**不可以**，因为在调用 `#doInvoke(...)` 方法之前，可能发生异常，导致失败任务的丢失。

那么该怎么办？有两种方式：

1. 上述方案的基础上，在 `#retryFailed(...)` 方法的移除处理中，增加调用 `#addFailed(...)` 方法。
2. 枚举一个 `FAILED_RESULT` 对象，让 `#doInvoke(...)` 方法发生异常时，返回该对象。这样 `#retryFailed(...)` 方法，在移除出 `failed` 集合时，增加下是否执行成功的判断。

笔者倾向第二种，逻辑更加线性和易懂。

## 5. FailfastCluster

`com.alibaba.dubbo.rpc.cluster.support.FailfastCluster` ，实现 Cluster 接口，快速失败，只发起一次调用，**失败立即报错**。通常用于**非幂等性的写操作**，比如新增记录。代码如下：

```
public class FailfastCluster implements Cluster {

    public final static String NAME = "failfast";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailfastClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 FailfastClusterInvoker 。

#### 5.1 FailfastInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，Failfast Invoker 实现类。代码如下：

```
public class FailfastClusterInvoker<T> extends AbstractClusterInvoker<T> {

    public FailfastClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常
        checkInvokers(invokers, invocation);
        // 根据负载均衡机制从 invokers 中选择一个Invoker
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        try {
            // RPC 调用得到 Result
            return invoker.invoke(invocation);
        } catch (Throwable e) {
            // 若是业务性质的异常，直接抛出
            if (e instanceof RpcException && ((RpcException) e).isBiz()) { // biz exception.
                throw (RpcException) e;
            }
            // 封装 RpcException 异常，并抛出
            throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,
                    "Failfast invoke providers " + invoker.getUrl() + " " + loadbalance.getClass().getSimpleName() + " select from all providers " + invokers + " for service " + getInterface().getName() + " method " + invocation.getMethodName() + " on consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e.getCause() != null ? e.getCause() : e);
        }
    }

}
```

- 和 FailbackClusterInvoker 差异点，在于对异常的处理。

## 6. FailsafeCluster

`com.alibaba.dubbo.rpc.cluster.support.FailsafeCluster` ，实现 Cluster 接口，失败安全，**出现异常时，直接忽略**。通常用于写入审计日志等操作。

代码如下：

```
public class FailfastCluster implements Cluster {

    public final static String NAME = "failfast";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailfastClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 FailsafeClusterInvoker 。

#### 6.1 FailsafeClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailsafeClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，Failsafe Invoker 实现类。代码如下：

```
public class FailsafeClusterInvoker<T> extends AbstractClusterInvoker<T> {

    private static final Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker.class);

    public FailsafeClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        try {
            // 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常
            checkInvokers(invokers, invocation);
            // 根据负载均衡机制从 invokers 中选择一个Invoker
            Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
            // RPC 调用得到 Result
            return invoker.invoke(invocation);
        } catch (Throwable e) {
            // 打印异常日志
            logger.error("Failsafe ignore exception: " + e.getMessage(), e);
            // 忽略异常
            return new RpcResult(); // ignore
        }
    }

}
```

- 和 FailfastInvoker 差异点，在于对异常的处理。

## 7. ForkingCluster

`com.alibaba.dubbo.rpc.cluster.support.ForkingCluster` ，实现 Cluster 接口，并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 `forks="2"` 来设置最大并行数。

代码如下：

```
public class ForkingCluster implements Cluster {

    public final static String NAME = "forking";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new ForkingClusterInvoker<T>(directory);
    }

}
```

#### 7.1 ForkingClusterInvoker

> 老艿艿：BlockQueue 的使用，非常精髓！

`com.alibaba.dubbo.rpc.cluster.support.ForkingClusterInvoker` ，实现 AbstractClusterInvoker 抽象类，ForkingCluster Invoker 实现类。代码如下：

```
 1: public class ForkingClusterInvoker<T> extends AbstractClusterInvoker<T> {
 2: 
 3:     /**
 4:      * ExecutorService 对象，并且为 CachedThreadPool 。
 5:      */
 6:     private final ExecutorService executor = Executors.newCachedThreadPool(new NamedThreadFactory("forking-cluster-timer", true));
 7: 
 8:     public ForkingClusterInvoker(Directory<T> directory) {
 9:         super(directory);
10:     }
11: 
12:     @Override
13:     @SuppressWarnings({"unchecked", "rawtypes"})
14:     public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
15:         // 检查 invokers 即可用Invoker集合是否为空，如果为空，那么抛出异常
16:         checkInvokers(invokers, invocation);
17:         // 保存选择的 Invoker 集合
18:         final List<Invoker<T>> selected;
19:         // 得到最大并行数，默认为 Constants.DEFAULT_FORKS = 2
20:         final int forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);
21:         // 获得调用超时时间，默认为 DEFAULT_TIMEOUT = 1000 毫秒
22:         final int timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
23:         // 若最大并行书小于等于 0，或者大于 invokers 的数量，直接使用 invokers
24:         if (forks <= 0 || forks >= invokers.size()) {
25:             selected = invokers;
26:         } else {
27:             // 循环，根据负载均衡机制从 invokers，中选择一个个Invoker ，从而组成 Invoker 集合。
28:             // 注意，因为增加了排重逻辑，所以不能保证获得的 Invoker 集合的大小，小于最大并行数
29:             selected = new ArrayList<Invoker<T>>();
30:             for (int i = 0; i < forks; i++) {
31:                 // 在invoker列表(排除selected)后,如果没有选够,则存在重复循环问题.见select实现.
32:                 Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);
33:                 if (!selected.contains(invoker)) { //Avoid add the same invoker several times. //防止重复添加invoker
34:                     selected.add(invoker);
35:                 }
36:             }
37:         }
38:         // 设置已经调用的 Invoker 集合，到 Context 中
39:         RpcContext.getContext().setInvokers((List) selected);
40:         // 异常计数器
41:         final AtomicInteger count = new AtomicInteger();
42:         // 创建阻塞队列
43:         final BlockingQueue<Object> ref = new LinkedBlockingQueue<Object>();
44:         // 循环 selected 集合，提交线程池，发起 RPC 调用
45:         for (final Invoker<T> invoker : selected) {
46:             executor.execute(new Runnable() {
47:                 public void run() {
48:                     try {
49:                         // RPC 调用，获得 Result 结果
50:                         Result result = invoker.invoke(invocation);
51:                         // 添加 Result 到 `ref` 阻塞队列
52:                         ref.offer(result);
53:                     } catch (Throwable e) {
54:                         // 异常计数器 + 1
55:                         int value = count.incrementAndGet();
56:                         // 若 RPC 调用结果都是异常，则添加异常到 `ref` 阻塞队列
57:                         if (value >= selected.size()) {
58:                             ref.offer(e);
59:                         }
60:                     }
61:                 }
62:             });
63:         }
64:         try {
65:             // 从 `ref` 队列中，阻塞等待结果
66:             Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);
67:             // 若是异常结果，抛出 RpcException 异常
68:             if (ret instanceof Throwable) {
69:                 Throwable e = (Throwable) ret;
70:                 throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, "Failed to forking invoke provider " + selected + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e.getCause() != null ? e.getCause() : e);
71:             }
72:             // 若是正常结果，直接返回
73:             return (Result) ret;
74:         } catch (InterruptedException e) {
75:             throw new RpcException("Failed to forking invoke provider " + selected + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e);
76:         }
77:     }
78: 
79: }
```

- 第 15 至 39 行：胖友自己看代码注释，比较易懂。

- 第 41 行：`count` 变量，**异常**计数器。

- 第 43 行：`ref` 变量，阻塞队列。通过它，实现线程池异步执行任务的**结果通知**，非常亮眼。

- 第 44 至 63 行：循环

   

  ```
  selected
  ```

   

  集合，提交线程池，发起 RPC 调用。

  - 第 49 至 52 行：调用 `Invoker#invoke(invocation)` 方法，RPC 调用，**成功**获得 Result 结果，并将 Result 添加到 `ref` 阻塞队列中。
  - 第 53 至 59 行：若调用**失败**，异常计数器 `count` 加一。当所有的 RPC 调用都完成，并且都是异常时，则添加**最后一个**异常到 `ref` 阻塞队列。🙂 细节处理很到位。

- 第 66 行：从 `ref` 队列中，**阻塞**等待，直到获得到结果或者超时。至此，ForkingClusterInvoker 实现了并行调用，且只要一个成功即返回。当然，还有一个隐性的，**所有都失败才返回**。

- 第 67 至 76 行：处理等待的“结果”。

## 8. FailoverCluster

FailoverCluster ，在 [《精尽 Dubbo 源码解析 —— 集群容错（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self) 一文中，我们已经详细解析。

## 9. MergeableCluster

MergeableCluster ，对应 [《Dubbo 用户指南 —— 分组聚合》](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) 文档，我们后续单独写文章分享。

## 10. MockClusterWrapper

MockClusterWrapper ，对应 [《Dubbo 用户指南 ——本地伪装 》](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) 文档，我们后续单独写文章分享。

# 3、Directory 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（二）之 Cluster 实现》](http://svip.iocoder.cn/Dubbo/cluster-2-impl-cluster/?self) 一文，分享 `dubbo-cluster` 模块， `directory` 包，**各种 Directory 实现类**。

Directory ，中文直译为**目录**，代表了**多个** Invoker ，可以把它看成 `List<Invoker>` 。但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更。

Directory 子类如下图：

[![Directory 子类](http://static.iocoder.cn/images/Dubbo/2019_04_10/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/01.png)Directory 子类

我们看到有两个实现类：

- StaticDirectory ，**静态** Directory 实现类，从命名上看出它是**静态**的 `List<Invoker>` 。
- RegistryDirectory ，基于**注册中心**的**动态** Directory 实现类，从命名上看出它是**动态**的，会根据注册中心的推送变更 `List<Invoker>` 。

## 2. Directory

`com.alibaba.dubbo.rpc.cluster.Directory` ，继承 Node 接口，Directory 接口。代码如下：

```
public interface Directory<T> extends Node {

    /**
     * get service type.
     *
     * 获得服务类型，例如：com.alibaba.dubbo.demo.DemoService
     *
     * @return service type.
     */
    Class<T> getInterface();

    /**
     * list invokers.
     *
     * 获得所有服务 Invoker 集合
     *
     * @return invokers
     */
    List<Invoker<T>> list(Invocation invocation) throws RpcException;

}
```

- 定义了**两个**接口方法，分别返回服务的**类型**和 **Invoker 集合**。
- 一个 Directory **只对应**一个服务类型。

## 3. AbstractDirectory

`com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory` ，实现 Directory 接口，Directory 抽象实现类，实现了公用的**路由规则( Router )**的逻辑。

#### 3.1 构造方法

```
/**
 * 是否已经销毁
 */
private volatile boolean destroyed = false;
/**
 * 注册中心 URL
 */
private final URL url;
/**
 * 消费者 URL
 *
 * 若未显示调用 {@link #AbstractDirectory(URL, URL, List)} 构造方法，consumerUrl 等于 {@link #url}
 */
private volatile URL consumerUrl;
/**
 * Router 数组
 */
private volatile List<Router> routers;

public AbstractDirectory(URL url) {
    this(url, null);
}

public AbstractDirectory(URL url, List<Router> routers) {
    this(url, url, routers);
}

public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers) {
    if (url == null) {
        throw new IllegalArgumentException("url == null");
    }
    this.url = url;
    this.consumerUrl = consumerUrl;
    // 设置 Router 数组
    setRouters(routers);
}
```

- `consumerUrl` 字段，认真看下注释和构造方法。
- 调用 `#setRouters(routers)` 方法，初始化并设置 Router 数组。

#### 3.2 setRouters

`#setRouters(routers)` 方法，初始化并设置 Router 数组。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router?self) 中。

#### 3.3 list

`#list(Invocation)` **实现**方法，获得所有服务 Invoker 集合。代码如下：

```
 1: @Override
 2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
 3:     if (destroyed) {
 4:         throw new RpcException("Directory already destroyed .url: " + getUrl());
 5:     }
 6:     // 获得所有 Invoker 集合
 7:     List<Invoker<T>> invokers = doList(invocation);
 8:     // 根据路由规则，筛选 Invoker 集合
 9:     List<Router> localRouters = this.routers; // local reference 本地引用，避免并发问题
10:     if (localRouters != null && !localRouters.isEmpty()) {
11:         for (Router router : localRouters) {
12:             try {
13:                 if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14:                     invokers = router.route(invokers, getConsumerUrl(), invocation);
15:                 }
16:             } catch (Throwable t) {
17:                 logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18:             }
19:         }
20:     }
21:     return invokers;
22: }
```

- 第 7 行：调用 `#doList(invocation)` **抽象**方法，获得所有 Invoker 集合。代码如下：

  ```
  protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;
  ```

- 第 9 至 20 行：根据**路由规则( Router )**，进一步筛选合适的 Invoker 集合。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) 。

## 4. RegistryDirectory

`com.alibaba.dubbo.registry.integration.RegistryDirectory` ，实现 NotifyListener 接口，实现 AbstractDirectory 抽象类，基于**注册中心**的 Directory 实现类。

1. RegistryDirectory 在 `dubbo-registry` 模块，`integration` 包下，是 Dubbo 注册中心模块集成 Directory 的实现类。
2. RegistryDirectory 作为一个 NotifyListener ，**订阅**注册中心( Registry ) 的数据，实现对变更的**监听**。

#### 4.1 构造方法

> RegistryDirectory 的字段有 **17** 个，比较多，所以胖友请耐心。

```
// ========== Dubbo SPI Adaptive 对象 BEGIN ==========

/**
 * Cluster$Adaptive 对象
 */
private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();
/**
 * RouterFactory$Adaptive 对象
 */
private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension();
/**
 * ConfiguratorFactory$Adaptive 对象
 */
private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();

// ========== 服务消费者相关 BEGIN ==========

/**
 * 服务类型，例如：com.alibaba.dubbo.demo.DemoService
 */
private final Class<T> serviceType; // Initialization at construction time, assertion not null
/**
 * Consumer URL 的配置项 Map
 */
private final Map<String, String> queryMap; // Initialization at construction time, assertion not null
/**
 * 服务方法数组
 */
private final String[] serviceMethods;
/**
 * 是否引用多分组
 *
 * 服务分组：http://dubbo.apache.org/zh-cn/docs/user/demos/service-group.html
 */
private final boolean multiGroup;

// ========== 注册中心相关 BEGIN ==========

/**
 * 注册中心的 Protocol 对象
 */
private Protocol protocol; // Initialization at the time of injection, the assertion is not null
/**
 * 注册中心
 */
private Registry registry; // Initialization at the time of injection, the assertion is not null
/**
 * 注册中心的服务类，目前是 com.alibaba.dubbo.registry.RegistryService
 *
 * 通过 {@link #url} 的 {@link URL#getServiceKey()} 获得
 */
private final String serviceKey; // Initialization at construction time, assertion not null
/**
 * 是否禁止访问。
 *
 * 有两种情况会导致：
 *
 * 1. 没有服务提供者
 * 2. 服务提供者被禁用
 */
private volatile boolean forbidden = false;

// ========== 配置规则相关 BEGIN ==========

/**
 * 原始的目录 URL
 *
 * 例如：zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&callbacks=1000&check=false&client=netty4&cluster=failback&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,saves&payload=1000&pid=63400&qos.port=33333&register.ip=192.168.16.23&sayHello.async=true&side=consumer&timeout=10000&timestamp=1527056491064
 */
private final URL directoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
/**
 * 覆写的目录 URL ，结合配置规则
 */
private volatile URL overrideDirectoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
/**
 * 配置规则数组
 *
 * override rules
 * Priority: override>-D>consumer>provider
 * Rule one: for a certain provider <ip:port,timeout=100>
 * Rule two: for all providers <* ,timeout=5000>
 */
private volatile List<Configurator> configurators; // The initial value is null and the midway may be assigned to null, please use the local variable reference

// ========== 服务提供者相关 BEGIN ==========

/**
 * [url]与[服务提供者 Invoker 集合]的映射缓存
 */
// Map<url, Invoker> cache service url to invoker mapping.
private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
/**
 * [方法名]与[服务提供者 Invoker 集合]的映射缓存
 */
// Map<methodName, Invoker> cache service method to invokers mapping.
private volatile Map<String, List<Invoker<T>>> methodInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
/**
 * [服务提供者 Invoker 集合]缓存
 */
// Set<invokerUrls> cache invokeUrls to invokers mapping.
private volatile Set<URL> cachedInvokerUrls; // The initial value is null and the midway may be assigned to null, please use the local variable reference

public RegistryDirectory(Class<T> serviceType, URL url) {
    super(url);
    if (serviceType == null) {
        throw new IllegalArgumentException("service type is null.");
    }
    if (url.getServiceKey() == null || url.getServiceKey().length() == 0) {
        throw new IllegalArgumentException("registry serviceKey is null.");
    }
    this.serviceType = serviceType;
    this.serviceKey = url.getServiceKey();
    // 获得 queryMap
    this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
    // 获得 overrideDirectoryUrl 和 directoryUrl
    this.overrideDirectoryUrl = this.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);
    // 初始化 multiGroup
    String group = directoryUrl.getParameter(Constants.GROUP_KEY, "");
    this.multiGroup = group != null && ("*".equals(group) || group.contains(","));
    // 初始化 serviceMethods
    String methods = queryMap.get(Constants.METHODS_KEY);
    this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);
}
```

- 分成**五类**变量。胖友自己看注释。
- 如果不理解，可以结合下面的具体方法的使用。🙂 当然也可以给我留言，因为确实变量有点多和复杂。

#### 4.2 subscribe

`#subscribe(URL)` 方法，向**注册中心**发起订阅。代码如下：

```
public void subscribe(URL url) {
    // 设置消费者 URL
    setConsumerUrl(url);
    // 向注册中心，发起订阅
    registry.subscribe(url, this);
}
```

- 调用**父** `#setConsumerUrl(url)` 方法，设置 `consumerUrl` 消费者 URL 。
- 调用 `Registry#subscribe(url, NotifyListener)` 方法，向注册中心，发起订阅。

服务消费者，再引用服务时，会创建 RegistryDirectory 对象，并发起**1）服务提供者 + 2）路由规则 + 3）配置规则**的数据订阅。如下图：

[![doRefer](http://static.iocoder.cn/images/Dubbo/2019_04_10/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/02.png)doRefer

- 对应为 `RegistryProtocol#doRefer(Cluster, Registry, Class<T> type, URL url)` 方法。

#### 4.3 notify

在注册中心( Registry )发现数据发生变化时，会通知对应的 NotifyListener 们。如下图：

[![notify](http://static.iocoder.cn/images/Dubbo/2019_04_10/03.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/03.png)notify

- 对应为 `AbstractRegistry#notify(URL url, NotifyListener, List<URL> urls)` 方法。
- 因为 RegistryDirectory 作为一个 NotifyListener ，向注册中心( Registry )发起了订阅，所以此时会被通知。**注意，是按照分类循环通知的**，也就是说，**一次只有一类 URL** 。

`#notify(List<URL> urls)` **实现**方法，代码如下：

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // 根据 URL 的分类或协议，分组成三个集合 。
 4:     List<URL> invokerUrls = new ArrayList<URL>(); // 服务提供者 URL 集合
 5:     List<URL> routerUrls = new ArrayList<URL>();
 6:     List<URL> configuratorUrls = new ArrayList<URL>();
 7:     for (URL url : urls) {
 8:         String protocol = url.getProtocol();
 9:         String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
10:         if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) {
11:             routerUrls.add(url);
12:         } else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {
13:             configuratorUrls.add(url);
14:         } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {
15:             invokerUrls.add(url);
16:         } else {
17:             logger.warn("Unsupported category " + category + " in notified url: " + url + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost());
18:         }
19:     }
20:     // 处理配置规则 URL 集合
21:     // configurators
22:     if (!configuratorUrls.isEmpty()) {
23:         this.configurators = toConfigurators(configuratorUrls);
24:     }
25:     // 处理路由规则 URL 集合
26:     // routers
27:     if (!routerUrls.isEmpty()) {
28:         List<Router> routers = toRouters(routerUrls);
29:         if (routers != null) { // null - do nothing
30:             setRouters(routers);
31:         }
32:     }
33:     // 合并配置规则，到 `directoryUrl` 中，形成 `overrideDirectoryUrl` 变量。
34:     List<Configurator> localConfigurators = this.configurators; // local reference
35:     // merge override parameters
36:     this.overrideDirectoryUrl = directoryUrl;
37:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
38:         for (Configurator configurator : localConfigurators) {
39:             this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);
40:         }
41:     }
42:     // 处理服务提供者 URL 集合
43:     refreshInvoker(invokerUrls);
44: }
```

- **注意**，这是一个**同步**的方法。

- 第 3 至 19 行：根据 URL 的**分类**或协议，分成组**三个**集合：**1）服务提供者 + 2）路由规则 + 3）配置规则**。

- 第 20 至 24 行：非空，调用 `#toConfigurators(configuratorUrls)` 方法，处理**配置规则** URL 集合。详细解析，见 [「4.3.1 toConfigurators」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 25 至 32 行：非空，调用

   

  ```
  #toRouters(routerUrls)
  ```

   

  方法，处理

  路由规则

   

  URL 集合。详细解析，见

   

  「4.3.2 toRouters」

   

  。

  - 若转换到 `routers` 非空，调用**父** `#setRouters(routers)` 方法，设置路由规则。

- 第 33 至 41 行：合并配置规则，到 `directoryUrl` 中，形成 `overrideDirectoryUrl` 变量。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（六）之 Configurator 实现》](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) 的 [「4.1.2 mergeUrl」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 43 行：调用 `#refreshInvoker(invokerUrls)` 方法，处理**服务提供者** URL 集合。详细解析，见 [「4.3.3 refreshInvoker」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

###### 4.3.1 toConfigurators

详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（六）之 Configurator 实现》](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) 的 [「4.1.1 toConfigurators」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

###### 4.3.2 toRouters

详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) 。

#### 4.7 内部类

###### 4.7.1 InvokerDelegate

InvokerDelegate ，实现 `com.alibaba.dubbo.rpc.protocol.InvokerWrapper` 类，Invoker 代理类，主要用于存储**注册中心下发的 url 地址**( `providerUrl` )，用于重新重新 refer 时能够根据 `providerURL` queryMap overrideMap 重新组装。 代码如下：

> 老艿艿：目前貌似没看到这块逻辑噢 😯😯😯

```
private static class InvokerDelegate<T> extends InvokerWrapper<T> {

    /**
     * 服务提供者 URL
     *
     * 未经过配置合并
     */
    private URL providerUrl;

    public InvokerDelegate(Invoker<T> invoker, URL url, URL providerUrl) {
        super(invoker, url);
        this.providerUrl = providerUrl;
    }

    public URL getProviderUrl() {
        return providerUrl;
    }

}
```

###### 4.7.2 InvokerComparator

InvokerComparator ，实现 Comparator 接口，Invoker 排序器实现类，**根据 URL 升序** 。代码如下：

```
private static class InvokerComparator implements Comparator<Invoker<?>> {

    /**
     * 单例
     */
    private static final InvokerComparator comparator = new InvokerComparator();

    private InvokerComparator() {
    }

    public static InvokerComparator getComparator() {
        return comparator;
    }

    @Override
    public int compare(Invoker<?> o1, Invoker<?> o2) {
        return o1.getUrl().toString().compareTo(o2.getUrl().toString());
    }

}
```

###### 4.3.3 refreshInvoker

`#refreshInvoker(List<URL> invokerUrls)` 方法，官方注释其如下：

> 根据 invokerURL 列表转换为 invoker 列表。转换规则如下：
>
> 1. 如果 url 已经被转换为 invoker ，则不在重新引用，直接从缓存中获取，注意如果 url 中任何一个参数变更也会重新引用
> 2. 如果传入的 invoker 列表不为空，则表示最新的 invoker 列表
> 3. 如果传入的 invokerUrl 列表是空，则表示只是下发的 override 规则或 route 规则，需要重新交叉对比，决定是否需要重新引用。

- 是不是看起来有点点懵逼？淡定，我们来看看代码。

```
 1: private void refreshInvoker(List<URL> invokerUrls) {
 2:     if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null
 3:             && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
 4:         // 设置禁止访问
 5:         this.forbidden = true; // Forbid to access
 6:         // methodInvokerMap 置空
 7:         this.methodInvokerMap = null; // Set the method invoker map to null
 8:         // 销毁所有 Invoker 集合
 9:         destroyAllInvokers(); // Close all invokers
10:     } else {
11:         // 设置允许访问
12:         this.forbidden = false; // Allow to access
13:         // 引用老的 urlInvokerMap
14:         Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
15:         // 传入的 invokerUrls 为空，说明是路由规则或配置规则发生改变，此时 invokerUrls 是空的，直接使用 cachedInvokerUrls 。
16:         if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
17:             invokerUrls.addAll(this.cachedInvokerUrls);
18:         // 传入的 invokerUrls 非空，更新 cachedInvokerUrls 。
19:         } else {
20:             this.cachedInvokerUrls = new HashSet<URL>();
21:             this.cachedInvokerUrls.addAll(invokerUrls); //Cached invoker urls, convenient for comparison //缓存invokerUrls列表，便于交叉对比
22:         }
23:         // 忽略，若无 invokerUrls
24:         if (invokerUrls.isEmpty()) {
25:             return;
26:         }
27:         // 将传入的 invokerUrls ，转成新的 urlInvokerMap
28:         Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
29:         // 转换出新的 methodInvokerMap
30:         Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map
31:         // state change
32:         // If the calculation is wrong, it is not processed. 如果计算错误，则不进行处理.
33:         if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
34:             logger.error(new IllegalStateException("urls to invokers error .invokerUrls.size :" + invokerUrls.size() + ", invoker.size :0. urls :" + invokerUrls.toString()));
35:             return;
36:         }
37:         // 若服务引用多 group ，则按照 method + group 聚合 Invoker 集合
38:         this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;
39:         this.urlInvokerMap = newUrlInvokerMap;
40:         // 销毁不再使用的 Invoker 集合
41:         try {
42:             destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
43:         } catch (Exception e) {
44:             logger.warn("destroyUnusedInvokers error. ", e);
45:         }
46:     }
47: }
```

- ========== 第一部分 ==========

- 第 2 至 3 行：当 `invokerUrls` 集合大小为 **1** ，并且协议为 `empty://` ，说明所有服务提供者都已经**下线**。若注册中心为 Zookeeper ，可参见 `ZookeeperRegistry#toUrlsWithEmpty(URL consumer, String path, List<String> providers)` 方法。

- 第 5 行：设置**禁止**访问，因为没有服务提供者了。

- 第 7 行：`methodInvokerMap` 置空。

- 第 9 行：调用 `#destroyAllInvokers()` 方法，销毁所有服务提供者 Invoker 集合。详细解析，见 [「4.3.3.5 destroyAllInvokers」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- ========== 第二部分 ==========

- 第 12 行：设置**允许**访问，因为有服务提供者了。

- 第 15 至 17 行：传入的 `invokerUrls` 为空，**说明是路由规则或配置规则发生改变**，此时 `invokerUrls` 是空的，直接使用 `cachedInvokerUrls` 。对应官方注释【第 3 点】（部分，不包括“需要重新交叉对比，决定是否需要重新引用”）。

- 第 18 至 22 行：传入的

   

  ```
  invokerUrls
  ```

   

  非空，更新

   

  ```
  cachedInvokerUrls
  ```

   

  。考虑到并发的问题，更新的方式为创建

  新的

   

  HashSet 。对应官方注释【第 2 点】。

  - 为什么【第 15 至 17 行】**不需要更新**呢？因为 `invokerUrls` 为空，直接使用 `cachedInvokerUrls` ，相当于进行了“更新”。

- 第 23 至 26 行：忽略，若无 `invokerUrls` 。出现情况为，初始是按照 `configurators => routers => providers` ，所以前两个会出现这个情况。关于这一点，胖友可以调试感受下。

- 第 28 行：调用 `#toInvokers(List<URL> urls)` 方法，将传入的 `invokerUrls` ，转换成**新的** `urlInvokerMap` 。详细解析，见 [「4.3.3.1 toInvokers」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 30 行：调用 `#toMethodInvokers(newUrlInvokerMap)` 方法，将 `urlInvokerMap` 转成与方法的映射关系，即**新的** `methodInvokerMap` 。详细解析，见 [「4.3.3.2 toMethodInvokers」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 31 至 36 行：如果计算错误，则不进行处理。一般来说，是防御性编程。

- 第 38 行：若服务引用**多** group ，则调用 `#toMergeMethodInvokerMap(newMethodInvokerMap)` 方法，按照 **method + group** 聚合 Invoker 集合。详细解析，见 [「4.3.3.3 toMethodInvokers」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 39 行：赋值 `urlInvokerMap` 属性。

- 第 40 至 45 行：调用 `#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)` 方法，**销毁**不再使用的 Invoker 集合。详细解析，见 [「4.3.3.4 toMethodInvokers」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

####### 4.3.3.1 toInvokers

`#toInvokers(List<URL> urls)` 方法，

```
 1: private Map<String, Invoker<T>> toInvokers(List<URL> urls) {
 2:     // 新的 `newUrlInvokerMap`
 3:     Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();
 4:     // 若为空，直接返回
 5:     if (urls == null || urls.isEmpty()) {
 6:         return newUrlInvokerMap;
 7:     }
 8:     // 已初始化的服务器提供 URL 集合
 9:     Set<String> keys = new HashSet<String>();
10:     // 获得引用服务的协议
11:     String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);
12:     // 循环服务提供者 URL 集合，转成 Invoker 集合
13:     for (URL providerUrl : urls) {
14:         // If protocol is configured at the reference side, only the matching protocol is selected
15:         // 如果 reference 端配置了 protocol ，则只选择匹配的 protocol
16:         if (queryProtocols != null && queryProtocols.length() > 0) {
17:             boolean accept = false;
18:             String[] acceptProtocols = queryProtocols.split(","); // 可配置多个协议
19:             for (String acceptProtocol : acceptProtocols) {
20:                 if (providerUrl.getProtocol().equals(acceptProtocol)) {
21:                     accept = true;
22:                     break;
23:                 }
24:             }
25:             if (!accept) {
26:                 continue;
27:             }
28:         }
29:         // 忽略，若为 `empty://` 协议
30:         if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
31:             continue;
32:         }
33:         // 忽略，若应用程序不支持该协议
34:         if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
35:             logger.error(new IllegalStateException("Unsupported protocol " + providerUrl.getProtocol() + " in notified url: " + providerUrl + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost()
36:                     + ", supported protocol: " + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
37:             continue;
38:         }
39:         // 合并 URL 参数
40:         URL url = mergeUrl(providerUrl);
41:         // 忽略，若已经初始化
42:         String key = url.toFullString(); // The parameter urls are sorted
43:         if (keys.contains(key)) { // Repeated url
44:             continue;
45:         }
46:         // 添加到 `keys` 中
47:         keys.add(key);
48:         // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
49:         // 如果服务端 URL 发生变化，则重新 refer 引用
50:         Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference
51:         Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
52:         if (invoker == null) { // Not in the cache, refer again 未在缓存中，重新引用
53:             try {
54:                 // 判断是否开启
55:                 boolean enabled;
56:                 if (url.hasParameter(Constants.DISABLED_KEY)) {
57:                     enabled = !url.getParameter(Constants.DISABLED_KEY, false);
58:                 } else {
59:                     enabled = url.getParameter(Constants.ENABLED_KEY, true);
60:                 }
61:                 // 若开启，创建 Invoker 对象
62:                 if (enabled) {
63:                     // 注意，引用服务
64:                     invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);
65:                 }
66:             } catch (Throwable t) {
67:                 logger.error("Failed to refer invoker for interface:" + serviceType + ",url:(" + url + ")" + t.getMessage(), t);
68:             }
69:             // 添加到 newUrlInvokerMap 中
70:             if (invoker != null) { // Put new invoker in cache
71:                 newUrlInvokerMap.put(key, invoker);
72:             }
73:         } else { // 在缓存中，直接使用缓存的 Invoker 对象，添加到 newUrlInvokerMap 中
74:             newUrlInvokerMap.put(key, invoker);
75:         }
76:     }
77:     // 清空 keys
78:     keys.clear();
79:     return newUrlInvokerMap;
80: }
```

- 第 3 行：`newUrlInvokerMap` 变量，新的 `urlInvokerMap` 字段，后面会赋值给它。

- 第 4 至 7 行：若 `urls` 为空，直接返回，防御性编程。

- 第 9 行：`keys` 变量，**已初始化**的服务器提供 URL 集合，即服务提供者 URL 已经处理。

- 第 11 行：获得引用服务的协议。一般情况下，我们不会设置 `<dubbo:reference protocol=""/>` 配置项。

- 第 13 行：**循环** `urls` 集合，转成 Invoker 集合。

- 协议处理相关

  - 第 14 至 28 行：如果 reference 端配置了 protocol ，则**只选择匹配**的 protocol 。
  - 第 29 至 32 行：**忽略**，若为 `empty://` 协议。
  - 第 33 至 38 行：**忽略**，若应用程序不支持该协议。

- 第 40 行：调用 `#mergeUrl(providerUrl)` 方法，**合并** URL 参数。详细解析，见 [「4.3.3.1 mergeUrl」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

- 第 41 至 47 行：

  忽略

  ，通过

   

  ```
  keys
  ```

   

  判断已经初始化。

  - 若未初始化，添加到 `keys` 中。

- 第 48 至 75 行：“创建”服务 Invoker 对象。

  - 第 50 至 51 行：获得 `url` 对应在 `localUrlInvokerMap` 缓存的 Invoker 对象。
  - 第 52 至 72 行：不在缓存中，需要重新 refer 引用，创建 Invoker 对象。
    - 第 54 至 60 行：通过配置项 `enable` 和 `disable` 判断，服务是否开启。
    - 第 61 至 65 行： 若开启，创建 Invoker 对象。
      - 【重要】**第 64 行：调用 `Protocol$Adaptive#refer(serviceType, url)` 方法，引用服务，创建服务提供者 Invoker 对象**。详细解析，在 [《精尽 Dubbo 源码解析 —— 服务引用》](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 已经有了。
      - 第 64 行：创建 InvokerDelegate 对象。详细解析，见 [「4.7.1 InvokerDelegate」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。
  - 第 73 至 75 行：在缓存中，直接使用缓存的 Invoker 对象，添加到 `newUrlInvokerMap` 中。

- 第 78 行：清空 `keys` 。

- 第 79 行：返回结果 `newUrlInvokerMap` 。

######## 4.3.3.1.1 mergeUrl

`#mergeUrl(providerUrl)` 方法，合并 URL 参数，**优先级**为配置规则 > 服务消费者配置 > 服务提供者配置。代码如下：

```
 1: private URL mergeUrl(URL providerUrl) {
 2:     // 合并消费端参数
 3:     providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
 4: 
 5:     // 合并配置规则
 6:     List<Configurator> localConfigurators = this.configurators; // local reference
 7:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
 8:         for (Configurator configurator : localConfigurators) {
 9:             providerUrl = configurator.configure(providerUrl);
10:         }
11:     }
12: 
13:     // 不检查连接是否成功，总是创建 Invoker ！
14:     providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15: 
16:     // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17:     // 仅合并提供者参数，因为 directoryUrl 与 override 合并是在 notify 的最后，这里不能够处理
18:     this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters // 合并提供者参数
19: 
20:     // 【忽略】因为是对 1.0 版本的兼容
21:     if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22:             && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23:         //fix by tony.chenl DUBBO-44
24:         String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25:         if (path != null) {
26:             int i = path.indexOf('/');
27:             if (i >= 0) {
28:                 path = path.substring(i + 1);
29:             }
30:             i = path.lastIndexOf(':');
31:             if (i >= 0) {
32:                 path = path.substring(0, i);
33:             }
34:             providerUrl = providerUrl.setPath(path);
35:         }
36:     }
37: 
38:     // 返回服务提供者 URL
39:     return providerUrl;
40: }
```

- 【**重要**】第 3 行：调用 `ClusterUtils#mergeUrl(providerUrl, queryMap)` 方法，合并服务消费者配置到 `providerUrl` 。详细解析，见 [「6. ClusterUtils」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。
- 第 5 至 11 行：合并**配置规则**到 `providerUrl` 中。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（六）之 Configurator 实现》](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
- 第 14 行：设置 `providerUrl` 不检查连接是否成功，总是创建 Invoker ！
- 第 18 行：仅合并提供者参数。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（六）之 Configurator 实现》](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
- 第 20 至 36 行：【**忽略**】因为是对 1.0 版本的兼容。

####### 4.3.3.2 toMethodInvokers

`#toMethodInvokers(Map<String, Invoker<T>> invokersMap)` 方法，将 `invokersMap` 转成**与方法**的映射关系。代码如下：

```
 1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
 2:     // 创建新的 `methodInvokerMap`
 3:     Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
 4:     // 创建 Invoker 集合
 5:     List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
 6:     // According to the methods classification declared by the provider URL, the methods is compatible with the registry to execute the filtered methods
 7:     // 按服务提供者 URL 所声明的 methods 分类，兼容注册中心执行路由过滤掉的 methods
 8:     if (invokersMap != null && invokersMap.size() > 0) {
 9:         // 循环每个服务提供者 Invoker
10:         for (Invoker<T> invoker : invokersMap.values()) {
11:             String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY); // methods
12:             if (parameter != null && parameter.length() > 0) {
13:                 String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);
14:                 if (methods != null && methods.length > 0) {
15:                     // 循环每个方法，按照方法名为维度，聚合到 `methodInvokerMap` 中
16:                     for (String method : methods) {
17:                         if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) { // 当服务提供者的方法为 "*" ，代表泛化调用
18:                             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
19:                             if (methodInvokers == null) {
20:                                 methodInvokers = new ArrayList<Invoker<T>>();
21:                                 newMethodInvokerMap.put(method, methodInvokers);
22:                             }
23:                             methodInvokers.add(invoker);
24:                         }
25:                     }
26:                 }
27:             }
28:             // 添加到 `invokersList` 中
29:             invokersList.add(invoker);
30:         }
31:     }
32:     // 路由全 `invokersList` ，匹配合适的 Invoker 集合。
33:     List<Invoker<T>> newInvokersList = route(invokersList, null);
34:     // 添加 `newInvokersList` 到 `newMethodInvokerMap` 中，表示该服务提供者的全量 Invoker 集合
35:     newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
36:     // 循环，基于每个方法路由，匹配合适的 Invoker 集合
37:     if (serviceMethods != null && serviceMethods.length > 0) {
38:         for (String method : serviceMethods) {
39:             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
40:             if (methodInvokers == null || methodInvokers.isEmpty()) {
41:                 methodInvokers = newInvokersList;
42:             }
43:             newMethodInvokerMap.put(method, route(methodInvokers, method));
44:         }
45:     }
46:     // 循环排序每个方法的 Invoker 集合，并设置为不可变
47:     // sort and unmodifiable
48:     for (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {
49:         List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
50:         Collections.sort(methodInvokers, InvokerComparator.getComparator());
51:         newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));
52:     }
53:     return Collections.unmodifiableMap(newMethodInvokerMap);
54: }
```

- 第 3 行：`newMethodInvokerMap` 变量，新的 `methodInvokerMap` 字段，后面会赋值给它。
- 第 5 行：创建 Invoker 集合。在【第 29 行】，我们可以看到，实际就是 `invokersMap` 的值的集合。
- 第 8 至 31 行：按照方法名为**维度**( KEY ) ，聚合**对应的 Invoker 集合**到 `newMethodInvokerMap` 中。
- 第 33 行：路由全 `invokersList` ，匹配合适的 Invoker 集合。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) 。
- 第 35 行：添加 `newInvokersList` 到 `newMethodInvokerMap` 中，表示该服务提供者的**全量** Invoker 集合。
- 第 36 至 45 行：**循环**，基于每个方法路由，匹配合适的 Invoker 集合。详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) 。
- 第 46 至 53 行：循环**排序**每个方法的 Invoker 集合，并设置为**不可变**。

####### 4.3.3.3 toMergeMethodInvokerMap

`#toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap)` ，按照 **method + group** 聚合 Invoker 集合。代码如下：

```
 1: private Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {
 2:     Map<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();
 3:     // 循环方法，按照 method + group 聚合 Invoker 集合
 4:     for (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {
 5:         String method = entry.getKey();
 6:         List<Invoker<T>> invokers = entry.getValue();
 7:         // 按照 Group 聚合 Invoker 集合的结果。其中，KEY：group VALUE：Invoker 集合。
 8:         Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();
 9:         // 循环 Invoker 集合，按照 group 聚合 Invoker 集合
10:         for (Invoker<T> invoker : invokers) {
11:             String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, "");
12:             List<Invoker<T>> groupInvokers = groupMap.get(group);
13:             if (groupInvokers == null) {
14:                 groupInvokers = new ArrayList<Invoker<T>>();
15:                 groupMap.put(group, groupInvokers);
16:             }
17:             groupInvokers.add(invoker);
18:         }
19:         // 大小为 1，使用第一个
20:         if (groupMap.size() == 1) {
21:             result.put(method, groupMap.values().iterator().next());
22:         // 大于 1，将每个 Group 的 Invoker 集合，创建成 Cluster Invoker 对象。
23:         } else if (groupMap.size() > 1) {
24:             List<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();
25:             for (List<Invoker<T>> groupList : groupMap.values()) {
26:                 groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));
27:             }
28:             result.put(method, groupInvokers);
29:         // 大小为 0 ，使用原有值
30:         } else {
31:             result.put(method, invokers);
32:         }
33:     }
34:     return result;
35: }
```

- 第 2 行：`result` 属性，**新的** `methodInvokerMap` 字段，后面会赋值给它。

- 第 3 终 33 行：

  循环

  ，按照

   

  method + group

   

  聚合 Invoker 集合。

  - 第 8 行： 按照 Group 聚合 Invoker 集合的结果。其中，**KEY**：group ，**VALUE**：Invoker 集合。

  - 第 9 至 18 行：**循环** Invoker 集合，按照 **group** 聚合 Invoker 集合。

  - ========== 结果 `groupMap` 处理 ==========

  - 第 19 至 21 行：若数量为 1 ，使用第一个。

  - 第 29 至 32 行：若数量为 0 ，使用原有值 `invokers` 。实际上，和【第 19 至 21 行】**等价**。

  - 第 22 至 28 行：若数量

    大于

     

    1 ，循环

    每个

     

    Group 的 Invoker 集合，调用

     

    ```
    Cluster$Adaptive#join(Directory)
    ```

     

    方法，创建对应的 Cluster Invoker 对象。

    - 我们发现，此处创建 **StaticDirectory** 对象。详细解析，见 [「5. StaticDirectory」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 。

那么，引用多个服务分组有什么用呢？为什么要按照 **group** 进行聚合，直接调用不可以么？让我们来打开 `ProtocolRegistry#refer(Class<T> type, URL url)` 方法，如下图所示：

[![refer](http://static.iocoder.cn/images/Dubbo/2019_04_10/04.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/04.png)refer

- 当引用多个服务分组时，会**自动**使用到**分组聚合**的特性。那么之后 MergeableCluster 会怎么做呢？详细解析，见后文 😈。

####### 4.3.3.4 destroyUnusedInvokers

`#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)` 方法，**销毁**不再使用的 Invoker 集合。代码如下：

```
private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map<String, Invoker<T>> newUrlInvokerMap) {
    // 防御性编程，目前不存在这个情况
    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
        // 销毁所有服务提供者 Invoker
        destroyAllInvokers();
        return;
    }
    // check deleted invoker
    // 对比新老集合，计算需要销毁的 Invoker 集合
    List<String> deleted = null;
    if (oldUrlInvokerMap != null) {
        Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();
        for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {
            // 若不存在，添加到 `deleted` 中
            if (!newInvokers.contains(entry.getValue())) {
                if (deleted == null) {
                    deleted = new ArrayList<String>();
                }
                deleted.add(entry.getKey());
            }
        }
    }

    // 若有需要销毁的 Invoker ，则进行销毁
    if (deleted != null) {
        for (String url : deleted) {
            if (url != null) {
                // 移除出 `urlInvokerMap`
                Invoker<T> invoker = oldUrlInvokerMap.remove(url);
                if (invoker != null) {
                    try {
                        // 销毁 Invoker
                        invoker.destroy();
                        if (logger.isDebugEnabled()) {
                            logger.debug("destroy invoker[" + invoker.getUrl() + "] success. ");
                        }
                    } catch (Exception e) {
                        logger.warn("destroy invoker[" + invoker.getUrl() + "] failed. " + e.getMessage(), e);
                    }
                }
            }
        }
    }
}
```

####### 4.3.3.5 destroyAllInvokers

`#destroyAllInvokers()` 方法，销毁所有服务提供者 Invoker 。代码如下：

```
private void destroyAllInvokers() {
    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference 本地引用，避免并发问题
    if (localUrlInvokerMap != null) {
        // 循环 urlInvokerMap ，销毁所有服务提供者 Invoker
        for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
            try {
                invoker.destroy();
            } catch (Throwable t) {
                logger.warn("Failed to destroy service " + serviceKey + " to provider " + invoker.getUrl(), t);
            }
        }
        // urlInvokerMap 清空
        localUrlInvokerMap.clear();
    }
    // methodInvokerMap 置空
    methodInvokerMap = null;
}
```

#### 4.4 doList

`#doList(Invocation)` **实现**方法，获得对应的 Invoker 集合。代码如下：

```
 1: @Override
 2: public List<Invoker<T>> doList(Invocation invocation) {
 3:     if (forbidden) {
 4:         // 1. No service provider 2. Service providers are disabled
 5:         throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,
 6:             "No provider available from registry " + getUrl().getAddress() + " for service " + getConsumerUrl().getServiceKey() + " on consumer " +  NetUtils.getLocalHost()
 7:                     + " use dubbo version " + Version.getVersion() + ", please check status of providers(disabled, not registered or in blacklist).");
 8:     }
 9:     List<Invoker<T>> invokers = null;
10:     Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap; // local reference
11:     // 获得 Invoker 集合
12:     if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {
13:         // 获得方法名、方法参数
14:         String methodName = RpcUtils.getMethodName(invocation);
15:         Object[] args = RpcUtils.getArguments(invocation);
16:         // 【第一】可根据第一个参数枚举路由
17:         if (args != null && args.length > 0 && args[0] != null
18:                 && (args[0] instanceof String || args[0].getClass().isEnum())) {
19: //            invokers = localMethodInvokerMap.get(methodName + "." + args[0]); // The routing can be enumerated according to the first parameter
20:             invokers = localMethodInvokerMap.get(methodName + args[0]); // The routing can be enumerated according to the first parameter
21:         }
22:         // 【第二】根据方法名获得 Invoker 集合
23:         if (invokers == null) {
24:             invokers = localMethodInvokerMap.get(methodName);
25:         }
26:         // 【第三】使用全量 Invoker 集合。例如，`#$echo(name)` ，回声方法
27:         if (invokers == null) {
28:             invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);
29:         }
30:         // 【第四】使用 `methodInvokerMap` 第一个 Invoker 集合。防御性编程。
31:         if (invokers == null) {
32:             Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();
33:             if (iterator.hasNext()) {
34:                 invokers = iterator.next();
35:             }
36:         }
37:     }
38:     return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;
39: }
```

- 通过四种方式，从 `methodInvokerMap` 中，获得对应的 Invoker 集合。

- 第一种，可根据**第一个参数**枚举路由。这是个非常小众的场景，胖友不必理解。例子如下：

  ```
  // DemoService 接口定义
  public interface DemoService {
      void hello(String name);
  
      void hello01(String name);
  
      void hello02(String name);
  }
  
  // 消费者调用
  DemoService demoService = (DemoService) context.getBean("demoService");
  demoService.hello("01");
  ```

  - 通过这样的方式，调用到的服务提供者的 `DemoServiceImpl#hello01(name)` 方法。

  - 如果使用该**特性**，注意避免出现**无关**的几个方法，例如 `#hello(name)` 和 `#hello01(name)` 是毫无关系的两个方法，而我真的想调用 `#hello(name)` 方法，结果调用到了 `#hello01(name)` 方法。

  - 如下是 Dubbo Commiter **诣极** 的解惑，非常感谢。

    > 动态的方法名本身就是接口中已经定义的
    >
    > 举个例子吧借口定义了 method, method1,method2， 如果我发起rpc调用method(1, 2, 3), 这个时候会去查找方法method1的invokers， 如果我这个时候发起rpc method(2, 1, 3), 这个时候会去查找方法method2的invokers， 然后调用invokers的method方法

    - 另外，经过沟通，【第 19 行】的 `"."` 是个 BUG ，方法里不能包含该字符，因此，笔者改成了【第 20 行】，去掉了 `"."` 进行测试。

- 第二种，根据**方法名**获得 Invoker 集合。一般情况下，都能匹配到。

- 第三种，使用全量 Invoker 集合。例如，`#$echo(name)` 回声方法。

- 第四种，使用 `methodInvokerMap` 第一个 Invoker 集合。防御性编程。

#### 4.5 isAvailable

```
@Override
public boolean isAvailable() {
    // 若已销毁，返回不可用
    if (isDestroyed()) {
        return false;
    }
    // 任意一个 Invoker 可用，则返回可用
    Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;
    if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {
        for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
            if (invoker.isAvailable()) {
                return true;
            }
        }
    }
    return false;
}
```

#### 4.6 destroy

```
@Override
public void destroy() {
    if (isDestroyed()) {
        return;
    }
    // 取消订阅
    // unsubscribe.
    try {
        if (getConsumerUrl() != null && registry != null && registry.isAvailable()) {
            registry.unsubscribe(getConsumerUrl(), this);
        }
    } catch (Throwable t) {
        logger.warn("unexpeced error when unsubscribe service " + serviceKey + "from registry" + registry.getUrl(), t);
    }
    // 标记已经销毁
    super.destroy(); // must be executed after unsubscribing
    // 销毁所有 Invoker 
    try {
        destroyAllInvokers();
    } catch (Throwable t) {
        logger.warn("Failed to destroy service " + serviceKey, t);
    }
}
```

## 5. StaticDirectory

`com.alibaba.dubbo.rpc.cluster.directory.StaticDirectory` ，实现 AbstractDirectory 抽象类，**静态** Directory 实现类。逻辑比较简单，将传入的 `invokers` 集合，封装成静态的 Directory 对象。代码如下：

```
public class StaticDirectory<T> extends AbstractDirectory<T> {

    /**
     * Invoker 集合
     */
    private final List<Invoker<T>> invokers;

    public StaticDirectory(List<Invoker<T>> invokers) {
        this(null, invokers, null);
    }

    public StaticDirectory(List<Invoker<T>> invokers, List<Router> routers) {
        this(null, invokers, routers);
    }

    public StaticDirectory(URL url, List<Invoker<T>> invokers) {
        this(url, invokers, null);
    }

    public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers) {
        // 默认使用 `url` 参数。当它为空时，使用 `invokers[0].url` 。
        super(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);
        if (invokers == null || invokers.isEmpty()) {
            throw new IllegalArgumentException("invokers == null");
        }
        this.invokers = invokers;
    }

    @Override
    public Class<T> getInterface() {
        return invokers.get(0).getInterface();
    }

    @Override
    public boolean isAvailable() {
        // 若已经销毁，则不可用
        if (isDestroyed()) {
            return false;
        }
        // 任一一个 Invoker 可用，则为可用
        for (Invoker<T> invoker : invokers) {
            if (invoker.isAvailable()) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void destroy() {
        // 若已经销毁， 跳过
        if (isDestroyed()) {
            return;
        }
        // 销毁
        super.destroy();
        // 销毁每个 Invoker
        for (Invoker<T> invoker : invokers) {
            invoker.destroy();
        }
        // 清空 Invoker 集合
        invokers.clear();
    }

    @Override
    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
        return invokers;
    }

}
```

- 代码比较易懂，胖友自己看下。

------

除了在 [「4.3.3.3 toMergeMethodInvokerMap」](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) 方法中，使用到了 StaticDirectory 对象。我们来看看 `ReferenceConfig#createProxy(Map<String, String> map)` 的使用，代码如下图：

[![createProxy](http://static.iocoder.cn/images/Dubbo/2019_04_10/05.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/05.png)createProxy

- 第 522 至 527 行：当 `registryURL` 非空时，意味着**有注册中心**，使用 `cluster=available` 集群方式，并调用 `Cluster$Adaptive#join(StaticDirectory)` 方法，创建对应的 Cluster Invoker 对象。这意味着，服务调用时，因为使用的是 `cluster=available` ，**仅调用第一个可用的 Invoker 对象**。下面，我们来做一个 YY ：

  - 目前我们有 A , B 两个机房，分别对应 zk01 集群，zk02 集群。这两个 zk 集群**不互通** 。

  - A , B 机房，分别部署了 **User 服务提供者**，仅注册到自己机房的 zk 集群。

  - A , B 机房，部署了对应的 **User 服务消费**，那么如果我们希望优先调用本机房。当本机房 **User 服务提供者**全挂的情况下，使用另外一个机房，该如何配置呢？

    ```
    // A 机房
    <dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk01,zk02" />
    // B 机房
    <dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk02,zk01" />
    ```

    - 即在 `"registry"` 配置项中，将自己的 zk 集群放在前面。
    - 当然，大多数情况下，很少会出现一个机房服务提供者全挂，zk 集群还存活着。

## 6. ClusterUtils

`com.alibaba.dubbo.rpc.cluster.support.ClusterUtils` ，Cluster 工具类。代码如下：

```
 1: public class ClusterUtils {
 2:
 3:     private ClusterUtils() {
 4:     }
 5:
 6:     public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
 7:         // 合并配置 Map 结果
 8:         Map<String, String> map = new HashMap<String, String>();
 9:         // 远程配置 Map 结果
10:         Map<String, String> remoteMap = remoteUrl.getParameters();
11:
12:         // 添加 `remoteMap` 到 `map` 中，并移除不必要的配置
13:         if (remoteMap != null && remoteMap.size() > 0) {
14:             map.putAll(remoteMap);
15:
16:             // Remove configurations from provider, some items should be affected by provider. 线程池配置不使用提供者的
17:             map.remove(Constants.THREAD_NAME_KEY);
18:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREAD_NAME_KEY);
19:
20:             map.remove(Constants.THREADPOOL_KEY);
21:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADPOOL_KEY);
22:
23:             map.remove(Constants.CORE_THREADS_KEY);
24:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.CORE_THREADS_KEY);
25:
26:             map.remove(Constants.THREADS_KEY);
27:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADS_KEY);
28:
29:             map.remove(Constants.QUEUES_KEY);
30:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.QUEUES_KEY);
31:
32:             map.remove(Constants.ALIVE_KEY);
33:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.ALIVE_KEY);
34:
35:             map.remove(Constants.TRANSPORTER_KEY);
36:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.TRANSPORTER_KEY);
37:         }
38:         // 添加 `localMap` 到 `map` 中
39:         if (localMap != null && localMap.size() > 0) {
40:             map.putAll(localMap);
41:         }
42:
43:         // 添加指定的 `remoteMap` 的配置项到 `map` 中，因为上面被 `localMap` 覆盖了。
44:         if (remoteMap != null && remoteMap.size() > 0) {
45:             // Use version passed from provider side
46:             String dubbo = remoteMap.get(Constants.DUBBO_VERSION_KEY);
47:             if (dubbo != null && dubbo.length() > 0) {
48:                 map.put(Constants.DUBBO_VERSION_KEY, dubbo);
49:             }
50:             String version = remoteMap.get(Constants.VERSION_KEY);
51:             if (version != null && version.length() > 0) {
52:                 map.put(Constants.VERSION_KEY, version);
53:             }
54:             String group = remoteMap.get(Constants.GROUP_KEY);
55:             if (group != null && group.length() > 0) {
56:                 map.put(Constants.GROUP_KEY, group);
57:             }
58:             String methods = remoteMap.get(Constants.METHODS_KEY);
59:             if (methods != null && methods.length() > 0) {
60:                 map.put(Constants.METHODS_KEY, methods);
61:             }
62:             // Reserve timestamp of provider url. 保留 provider 的启动 timestamp
63:             String remoteTimestamp = remoteMap.get(Constants.TIMESTAMP_KEY);
64:             if (remoteTimestamp != null && remoteTimestamp.length() > 0) {
65:                 map.put(Constants.REMOTE_TIMESTAMP_KEY, remoteMap.get(Constants.TIMESTAMP_KEY));
66:             }
67:             // Combine filters and listeners on Provider and Consumer 合并 filter 和 listener
68:             String remoteFilter = remoteMap.get(Constants.REFERENCE_FILTER_KEY);
69:             String localFilter = localMap.get(Constants.REFERENCE_FILTER_KEY);
70:             if (remoteFilter != null && remoteFilter.length() > 0
71:                     && localFilter != null && localFilter.length() > 0) {
72:                 localMap.put(Constants.REFERENCE_FILTER_KEY, remoteFilter + "," + localFilter);
73:             }
74:             String remoteListener = remoteMap.get(Constants.INVOKER_LISTENER_KEY);
75:             String localListener = localMap.get(Constants.INVOKER_LISTENER_KEY);
76:             if (remoteListener != null && remoteListener.length() > 0
77:                     && localListener != null && localListener.length() > 0) {
78:                 localMap.put(Constants.INVOKER_LISTENER_KEY, remoteListener + "," + localListener);
79:             }
80:         }
81:
82:         // 清空原有配置，使用合并的配置覆盖
83:         return remoteUrl.clearParameters().addParameters(map);
84:     }
85:
86: }
```

- 将 `localMap` 和 `remoteUrl.parameters` **合并**成 `map` ，大多数以**前者**为主【第 12 至 41 行】，部分**指定**以后者为主【第 43 至 80 行】。
- 将合并的 `map` 的结果，**覆盖**设置到 `remoteUrl` 中。

# 4、LoadBalance 

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（三）之 Directory 实现》](http://www.iocoder.cn.dubbo/cluster-3-impl-directory/?self) 一文，分享 `dubbo-cluster` 模块， `loadbalance` 包，**各种 LoadBalance 实现类**。

LoadBalance 子类如下图：

[![LoadBalance 子类](http://static.iocoder.cn/images/Dubbo/2019_04_15/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_15/01.png)LoadBalance 子类

我们可以看到，目前一共有四个子类，意味着**内置**了四种负载均衡的选择算法。

> 老艿艿：本文对应 [《Dubbo 用户指南 —— 负载均衡》](http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html) 文档。

## 2. LoadBalance

`com.alibaba.dubbo.rpc.cluster.LoadBalance` ， LoadBalance **接口**。代码如下：

```
@SPI(RandomLoadBalance.NAME)
public interface LoadBalance {

    /**
     * select one invoker in list.
     *
     * 从 Invoker 集合中，选择一个
     *
     * @param invokers   invokers.
     * @param url        refer url
     * @param invocation invocation.
     * @return selected invoker.
     */
    @Adaptive("loadbalance")
    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;

}
```

- `@SPI(RandomLoadBalance.NAME)` 注解，Dubbo SPI **拓展点**，默认为 `"random"` ，即**随机**。
- `@Adaptive` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Cluster 实现，使用 `URL.loadbalance` 属性。
- `#selectList<Invoker<T>>, URL, Invocation)` 接口方法，从 Invoker 集合中，选择一个。

## 3. AbstractLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance` ，实现 LoadBalance 接口，LoadBalance 抽象类，提供了权重计算的功能。

#### 3.1 select

`#select(List<Invoker<T>>, URL, Invocation)` **实现**方法，默认只有一个 Invoker 时，直接选择返回。代码如下：

```
    @Override
public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    if (invokers == null || invokers.isEmpty()) {
        return null;
    }
    if (invokers.size() == 1) {
        return invokers.get(0);
    }
    return doSelect(invokers, url, invocation);
}
```

- 子类实现 `#doSelect(List<Invoker<T>>, URL, Invocation)` **抽象**方法，提供自定义的负载均衡策略。

  ```
  protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);
  ```

#### 3.2 getWeight

```
protected int getWeight(Invoker<?> invoker, Invocation invocation) {
    // 获得 weight 配置，即服务权重。默认为 100
    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
    if (weight > 0) {
        long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);
        if (timestamp > 0L) {
            // 获得启动总时长
            int uptime = (int) (System.currentTimeMillis() - timestamp);
            // 获得预热需要总时长。默认为 10 * 60 * 1000 = 10 分钟
            int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);
            // 处于预热中，计算当前的权重
            if (uptime > 0 && uptime < warmup) {
                weight = calculateWarmupWeight(uptime, warmup, weight);
            }
        }
    }
    return weight;
}
```

- 考虑到 JVM 自身会有**预热**的过程，所以服务提供者一启动就直接承担 100% 的流量，可能会出现很吃力的情况。因此权重的计算，**默认自带了预热的过程**。`#calculateWarmupWeight(uptime, warmup, weight)` **静态**方法，代码如下：

  ```
  static int calculateWarmupWeight(int uptime, int warmup, int weight) {
      // 计算权重
      int ww = (int) ((float) uptime / ((float) warmup / (float) weight));
      // 权重范围为 [0, weight] 之间
      return ww < 1 ? 1 : (ww > weight ? weight : ww);
  }
  ```

  - 计算权重的代码这么写看起来比较“绕”，我们来修改成 `(uptime / warmup) * weight` ，是否就好理解多了，相当于**进度百分比 \* 权重**。

  - 如下是我飞哥举的一个例子，感觉非常赞。

    > 根据calculateWarmupWeight()方法实现可知，随着provider的启动时间越来越长，慢慢提升权重直到weight，且权重最小值为1，所以：
    >
    > - 如果 provider 运行了 1 分钟，那么 weight 为 10，即只有最终需要承担的 10% 流量；
    > - 如果 provider 运行了 2 分钟，那么 weight 为 20，即只有最终需要承担的 20% 流量；
    > - 如果 provider 运行了 5 分钟，那么 weight 为 50，即只有最终需要承担的 50% 流量；
    >   … …
    > - 如果 provider 运行了 10 分钟，那么 weight 为 100，即只有最终需要承担的 100% 流量；

- `"weight"` 配置项，默认为 100 。

- `"warmup"` 配置项，默认为 10 `*` 60 `*` 1000 = 10 分钟。

## 4. RandomLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance` ，实现 AbstractLoadBalance 抽象类，**随机**，按权重设置随机概率。

> 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

```
 1: public class RandomLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "random";
 4: 
 5:     private final Random random = new Random();
 6: 
 7:     @Override
 8:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
 9:         int length = invokers.size(); // Number of invokers
10:         int totalWeight = 0; // The sum of weights
11:         boolean sameWeight = true; // Every invoker has the same weight?
12:         // 计算总权限
13:         for (int i = 0; i < length; i++) {
14:             int weight = getWeight(invokers.get(i), invocation); // 获得权重
15:             totalWeight += weight; // Sum
16:             if (sameWeight && i > 0 && weight != getWeight(invokers.get(i - 1), invocation)) {
17:                 sameWeight = false;
18:             }
19:         }
20:         // 权重不相等，随机后，判断在哪个 Invoker 的权重区间中
21:         if (totalWeight > 0 && !sameWeight) {
22:             // 随机
23:             // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.
24:             int offset = random.nextInt(totalWeight);
25:             // Return a invoker based on the random value.
26:             // 区间判断
27:             for (Invoker<T> invoker : invokers) {
28:                 offset -= getWeight(invoker, invocation);
29:                 if (offset < 0) {
30:                     return invoker;
31:                 }
32:             }
33:         }
34:         // 权重相等，平均随机
35:         // If all invokers have the same weight value or totalWeight=0, return evenly.
36:         return invokers.get(random.nextInt(length));
37:     }
38: 
39: }
```

- 第 12 至 19 行：计算**总**权重，并判断所有 Invoker 是否**相同**权重。
- 第 20 至 33 行：权重**不相等**，随机权重后，判断在哪个 Invoker 的权重区间中。
- 第 36 行：权重**相等**，直接随机选择 Invoker 即可。相等于对【第 20 至 33 行】的**优化**。

**算法说明**

> FROM 飞哥的 [《dubbo源码-负载均衡》](https://www.jianshu.com/p/10c30d7b8b6a)
>
> 假定有3台dubbo provider:
>
> - 10.0.0.1:20884, weight=2
> - 10.0.0.1:20886, weight=3
> - 10.0.0.1:20888, weight=4
>
> 随机算法的实现：
> totalWeight=9;
>
> - 假设offset=1（即random.nextInt(9)=1）
>   1-2=-1<0？是，所以选中 10.0.0.1:20884, weight=2
> - 假设offset=4（即random.nextInt(9)=4）
>   4-2=2<0？否，这时候offset=2， 2-3<0？是，所以选中 10.0.0.1:20886, weight=3
> - 假设offset=7（即random.nextInt(9)=7）
>   7-2=5<0？否，这时候offset=5， 5-3=2<0？否，这时候offset=2， 2-4<0？是，所以选中 10.0.0.1:20888, weight=4

## 5. RoundRobinLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance` ，实现 AbstractLoadBalance 抽象类，**轮循**，按公约后的权重设置轮循比率。

> 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

```
 1: public class RoundRobinLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "roundrobin";
 4: 
 5:     /**
 6:      * 服务方法与计数器的映射
 7:      *
 8:      * KEY：serviceKey + "." + methodName
 9:      */
10:     private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
11: 
12:     @Override
13:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
14:         String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
15:         int length = invokers.size(); // Number of invokers
16:         int maxWeight = 0; // The maximum weight
17:         int minWeight = Integer.MAX_VALUE; // The minimum weight
18:         final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
19:         int weightSum = 0;
20:         // 计算最小、最大权重，总的权重和。
21:         for (int i = 0; i < length; i++) {
22:             int weight = getWeight(invokers.get(i), invocation);
23:             maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
24:             minWeight = Math.min(minWeight, weight); // Choose the minimum weight
25:             if (weight > 0) {
26:                 invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
27:                 weightSum += weight;
28:             }
29:         }
30:         // 获得 AtomicPositiveInteger 对象
31:         AtomicPositiveInteger sequence = sequences.get(key);
32:         if (sequence == null) {
33:             sequences.putIfAbsent(key, new AtomicPositiveInteger());
34:             sequence = sequences.get(key);
35:         }
36:         // 获得当前顺序号，并递增 + 1
37:         int currentSequence = sequence.getAndIncrement();
38:         // 权重不相等，顺序根据权重分配
39:         if (maxWeight > 0 && minWeight < maxWeight) {
40:             int mod = currentSequence % weightSum; // 剩余权重
41:             for (int i = 0; i < maxWeight; i++) { // 循环最大权重
42:                 for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) { // 循环 Invoker 集合
43:                     final Invoker<T> k = each.getKey();
44:                     final IntegerWrapper v = each.getValue();
45:                     // 剩余权重归 0 ，当前 Invoker 还有剩余权重，返回该 Invoker 对象
46:                     if (mod == 0 && v.getValue() > 0) {
47:                         return k;
48:                     }
49:                     // 若 Invoker 还有权重值，扣除它( value )和剩余权重( mod )。
50:                     if (v.getValue() > 0) {
51:                         v.decrement();
52:                         mod--;
53:                     }
54:                 }
55:             }
56:         }
57:         // 权重相等，平均顺序获得
58:         // Round robin
59:         return invokers.get(currentSequence % length);
60:     }
61:     
62: }
```

- 第 18 行：`invokerToWeightMap` 变量，Invoker 与其权重的映射。其中，IntegerWrapper 为 RoundRobinLoadBalance 的内部类。代码如下：

  ```
  private static final class IntegerWrapper {
  
      // 权重值
      private int value;
  
      // ... 省略 构造 / getting / setting 方法
  
      // 扣除一
      public void decrement() {
          this.value--;
      }
  
  }
  ```

- 第 20 至 29 行：计算最小、最大权重，总的权重和，并初始化 `invokerToWeightMap` 。

  - 其中，最小权重用来判断，所有 Invoker 的权重是否都相等。

- 第 30 至 35 行：获得**对应的** AtomicPositiveInteger 对象，作为**顺序计数器**。

- 第 37 行：获得当前顺序号，并递增 + 1 。**注意**，递增要放后面，不然就不是从**头**开始了。

- 第 38 至 56 行：权重

  不相等

  ，顺序根据权重分配。因为顺序分配的过程需要考虑

  权重

  ，所以看起来比较“绕”。我们可以理解成：

  - 顺序发 `mod` 次牌
  - 每向一个 Invoker 发一次牌，它的剩余 `weight` 减一。**当且仅当向有剩余 `weight` 的 Invoker 发牌**。
  - 当没有可发的 `mod` 牌时，选择该 Invoker 。

- 第 59 行：权重**相等**，直接平均顺序分配。相等于对【第 38 至 56 行】的优化。

> FROM 飞哥的 [《dubbo源码-负载均衡》](https://www.jianshu.com/p/10c30d7b8b6a)
>
> 假定有3台权重都一样的dubbo provider:
>
> - 10.0.0.1:20884, weight=100
> - 10.0.0.1:20886, weight=100
> - 10.0.0.1:20888, weight=100
>
> 轮询算法的实现：
> 其调用方法某个方法(key)的 sequence 从 0 开始：
>
> - sequence=0时，选择invokers.get(0%3)=10.0.0.1:20884
> - sequence=1时，选择invokers.get(1%3)=10.0.0.1:20886
> - sequence=2时，选择invokers.get(2%3)=10.0.0.1:20888
> - sequence=3时，选择invokers.get(3%3)=10.0.0.1:20884
> - sequence=4时，选择invokers.get(4%3)=10.0.0.1:20886
> - sequence=5时，选择invokers.get(5%3)=10.0.0.1:20888

> 如果有3台权重不一样的dubbo provider：
>
> - 10.0.0.1:20884, weight=50
> - 10.0.0.1:20886, weight=100
> - 10.0.0.1:20888, weight=150
>
> 调试过很多次，这种情况下有问题；留一个TODO；

## 6. LeastActiveLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance` ，实现 AbstractLoadBalance 抽象类，**最少活跃调用数**，相同活跃数的随机，活跃数指调用前后计数差。

> 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

相比来说，LeastActiveLoadBalance 是 RandomLoadBalance 的**加强版**，基**于最少活跃调用数**。

```
 1: public class LeastActiveLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "leastactive";
 4: 
 5:     private final Random random = new Random();
 6: 
 7:     @Override
 8:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
 9:         int length = invokers.size(); // 总个数
10:         int leastActive = -1; // 最小的活跃数
11:         int leastCount = 0; // 相同最小活跃数的个数
12:         int[] leastIndexes = new int[length]; // 相同最小活跃数的下标
13:         int totalWeight = 0; // 总权重
14:         int firstWeight = 0; // 第一个权重，用于于计算是否相同
15:         boolean sameWeight = true; // 是否所有权重相同
16:         // 计算获得相同最小活跃数的数组和个数
17:         for (int i = 0; i < length; i++) {
18:             Invoker<T> invoker = invokers.get(i);
19:             int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // 活跃数
20:             int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // 权重
21:             if (leastActive == -1 || active < leastActive) { // 发现更小的活跃数，重新开始
22:                 leastActive = active; // 记录最小活跃数
23:                 leastCount = 1; // 重新统计相同最小活跃数的个数
24:                 leastIndexes[0] = i; // 重新记录最小活跃数下标
25:                 totalWeight = weight; // 重新累计总权重
26:                 firstWeight = weight; // 记录第一个权重
27:                 sameWeight = true; // 还原权重相同标识
28:             } else if (active == leastActive) { // 累计相同最小的活跃数
29:                 leastIndexes[leastCount++] = i; // 累计相同最小活跃数下标
30:                 totalWeight += weight; // 累计总权重
31:                 // 判断所有权重是否一样
32:                 if (sameWeight && weight != firstWeight) {
33:                     sameWeight = false;
34:                 }
35:             }
36:         }
37:         // assert(leastCount > 0)
38:         if (leastCount == 1) {
39:             // 如果只有一个最小则直接返回
40:             return invokers.get(leastIndexes[0]);
41:         }
42:         if (!sameWeight && totalWeight > 0) {
43:             // 如果权重不相同且权重大于0则按总权重数随机
44:             int offsetWeight = random.nextInt(totalWeight);
45:             // 并确定随机值落在哪个片断上
46:             for (int i = 0; i < leastCount; i++) {
47:                 int leastIndex = leastIndexes[i];
48:                 offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
49:                 if (offsetWeight <= 0) {
50:                     return invokers.get(leastIndex);
51:                 }
52:             }
53:         }
54:         // 如果权重相同或权重为0则均等随机
55:         return invokers.get(leastIndexes[random.nextInt(leastCount)]);
56:     }
57: 
58: }
```

- 第 16 至 36 行：

  计算

  获得相同最小活跃数的数组(

   

  ```
  leastIndexes
  ```

   

  )和个数(

   

  ```
  leastCount
  ```

   

  )。

  注意

  ，

  ```
  leastIndexes
  ```

   

  是重用的，所以需要

   

  ```
  leastCount
  ```

   

  作为下标。

  - 每个 Invoker 的活跃数计算，通过 RpcStatus ，在 [《精尽 Dubbo 源码分析 —— 过滤器（四）之 ActiveLimitFilter && ExecuteLimitFilter》](http://svip.iocoder.cn/Dubbo/filter-method-limit-filter/?self) 已经有详细解析。

- 第 38 行：如果只有一个最小则直接返回。

- ========== 如下部分，和 RandomLoadBalance **类似** ==========

- 第 42 至 53 行：权重**不相等**，随机权重后，判断在哪个 Invoker 的权重区间中。

- 第 55 行：权重**相等**，直接随机选择 Invoker 即可。相等于对【第 42 至 53 行】的**优化**。

**算法说明**

> FROM 飞哥的 [《dubbo源码-负载均衡》](https://www.jianshu.com/p/10c30d7b8b6a)
>
> 最小活跃数算法实现：
> 假定有3台dubbo provider:
>
> - 10.0.0.1:20884, weight=2，active=2
> - 10.0.0.1:20886, weight=3，active=4
> - 10.0.0.1:20888, weight=4，active=3
>
> active=2最小，且只有一个2，所以选择10.0.0.1:20884
>
> 假定有3台dubbo provider:
>
> - 10.0.0.1:20884, weight=2，active=2
> - 10.0.0.1:20886, weight=3，active=2
> - 10.0.0.1:20888, weight=4，active=3
>   active=2最小，且有2个，所以从[10.0.0.1:20884,10.0.0.1:20886 ]中选择；
>
> 接下来的算法与随机算法类似：
>
> - 假设offset=1（即random.nextInt(5)=1）
>   1-2=-1<0？是，所以选中 10.0.0.1:20884, weight=2
> - 假设offset=4（即random.nextInt(5)=4）
>   4-2=2<0？否，这时候offset=2， 2-3<0？是，所以选中 10.0.0.1:20886, weight=3

## 7. ConsistentHashLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance` ，实现 AbstractLoadBalance 抽象类，**一致性 Hash**，相同参数的请求总是发到同一提供者。

> 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。

```
 1: public class ConsistentHashLoadBalance extends AbstractLoadBalance {
 2: 
 3:     /**
 4:      * 服务方法与一致性哈希选择器的映射
 5:      *
 6:      * KEY：serviceKey + "." + methodName
 7:      */
 8:     private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<String, ConsistentHashSelector<?>>();
 9: 
10:     @SuppressWarnings("unchecked")
11:     @Override
12:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
13:         String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
14:         // 基于 invokers 集合，根据对象内存地址来计算定义哈希值
15:         int identityHashCode = System.identityHashCode(invokers);
16:         // 获得 ConsistentHashSelector 对象。若为空，或者定义哈希值变更（说明 invokers 集合发生变化），进行创建新的 ConsistentHashSelector 对象
17:         ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);
18:         if (selector == null || selector.identityHashCode != identityHashCode) {
19:             selectors.put(key, new ConsistentHashSelector<T>(invokers, invocation.getMethodName(), identityHashCode));
20:             selector = (ConsistentHashSelector<T>) selectors.get(key);
21:         }
22:         return selector.select(invocation);
23:     }
24: }
```

- 第 15 行：调用 `System#identityHashCode(Object)` 方法，基于 `invokers` 集合，根据对象**内存地址**来计算定义哈希值。
- 第 16 至 21 行：获得 ConsistentHashSelector 对象。若为空，或者定义哈希值变更（**说明 `invokers` 集合发生变化**），进行创建**新的** ConsistentHashSelector 对象。
- 第 22 行：调用 `ConsistentHashSelector#select(invocation)` 方法，选择一个 Invoker 对象。

#### 7.1 ConsistentHashSelector

ConsistentHashSelector ，是 ConsistentHashLoadBalance 的**内部类**，一致性哈希选择器，基于 **Ketama** 算法。

> 老艿艿：下文参考 [《Ketama一致性Hash算法(含Java代码)》](http://langyu.iteye.com/blog/684087) 文章。从该文章中，我们可以看到，Spy Memcached Client 也采用这种算法。

###### 7.1.1 构造方法

```
/**
 * 虚拟节点与 Invoker 的映射关系
 */
private final TreeMap<Long, Invoker<T>> virtualInvokers;
/**
 * 每个Invoker 对应的虚拟节点数
 */
private final int replicaNumber;
/**
 * 定义哈希值
 */
private final int identityHashCode;
/**
 * 取值参数位置数组
 */
private final int[] argumentIndex;

  1: ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {
  2:     this.virtualInvokers = new TreeMap<Long, Invoker<T>>();
  3:     // 设置 identityHashCode
  4:     this.identityHashCode = identityHashCode;
  5:     URL url = invokers.get(0).getUrl();
  6:     // 初始化 replicaNumber
  7:     this.replicaNumber = url.getMethodParameter(methodName, "hash.nodes", 160);
  8:     // 初始化 argumentIndex
  9:     String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, "hash.arguments", "0"));
 10:     argumentIndex = new int[index.length];
 11:     for (int i = 0; i < index.length; i++) {
 12:         argumentIndex[i] = Integer.parseInt(index[i]);
 13:     }
 14:     // 初始化 virtualInvokers
 15:     for (Invoker<T> invoker : invokers) {
 16:         String address = invoker.getUrl().getAddress();
 17:         // 每四个虚拟结点为一组，为什么这样？下面会说到
 18:         for (int i = 0; i < replicaNumber / 4; i++) {
 19:             // 这组虚拟结点得到惟一名称
 20:             byte[] digest = md5(address + i);
 21:             // Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因
 22:             for (int h = 0; h < 4; h++) {
 23:                 // 对于每四个字节，组成一个long值数值，做为这个虚拟节点的在环中的惟一key
 24:                 long m = hash(digest, h);
 25:                 virtualInvokers.put(m, invoker);
 26:             }
 27:         }
 28:     }
 29: }
```

- `identityHashCode` 字段，定义哈希值。

- ```
  replicaNumber
  ```

   

  字段，

  每个

   

  Invoker 对应的

  虚拟节点数

  ，默认为 160 。

  - 可通过 `<dubbo:parameter key="hash.nodes" value="320" />` 自定义，对应【第 7 行】代码。

- ```
  argumentIndex
  ```

   

  字段，选择 Invoker 时，计算 Hash 值的参数位置数组，默认为第一个参数。

  - 可通过 `<dubbo:parameter key="hash.arguments" value="0,1" />` 自定义， 对应【第 8 至 13 行】代码。

- `virtualInvokers` 字段，虚拟节点与 Invoker 的映射关系。对应【第 14 至 28 行】进行初始化。

  - 第 15 行：**循环**每个 Invoker 对象。

  - 第 18 行：**循环** `replicaNumber / 4` 次，每**四个**虚拟节点为一组，为什么这样呢？详细见【第 20 行】。

  - 第 20 行：拼接 `address + i` 作为虚拟节点名的**唯一名称**。调用 `#md5(value)` 方法，计算 MD5 。代码如下：

    ```
    private byte[] md5(String value) {
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        md5.reset();
        byte[] bytes;
        try {
            bytes = value.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        md5.update(bytes);
        return md5.digest();
    }
    ```

    - **MD5 是一个 16 字节长度的数组，将 16 字节的数组每四个字节一组，分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因**

  - 第 22 行：顺序**循环**每四个字节。

  - 第 24 行：调用 `#hash(byte[] digest, int number)` 方法，对于**每四个字节**，组成一个 Long 值数值，做为这个虚拟节点的在环中的**惟一 KEY** 。代码如下：

    ```
    private long hash(byte[] digest, int number) {
        return (((long) (digest[3 + number * 4] & 0xFF) << 24)
                | ((long) (digest[2 + number * 4] & 0xFF) << 16)
                | ((long) (digest[1 + number * 4] & 0xFF) << 8)
                | (digest[number * 4] & 0xFF))
                & 0xFFFFFFFFL;
    }
    ```

    - x

  - 第 25 行：添加 Invoker 到 `virtualInvokers` 中。

###### 7.1.2 select

```
public Invoker<T> select(Invocation invocation) {
    // 基于方法参数，获得 KEY
    String key = toKey(invocation.getArguments());
    // 计算 MD5 值
    byte[] digest = md5(key);
    // 计算 KEY 值
    return selectForKey(hash(digest, 0));
}
```

- 调用 `#toKey(Object[] args)` 方法，基于**方法参数**，获得 KEY 。代码如下：

  ```
  private String toKey(Object[] args) {
      StringBuilder buf = new StringBuilder();
      for (int i : argumentIndex) {
          if (i >= 0 && i < args.length) {
              buf.append(args[i]);
          }
      }
      return buf.toString();
  }
  ```

- 调用 `#md5(key)` 方法，计算 MD5 值。

- 调用 `#hash(digest, hash)` 方法，计算 KEY 值。

- 调用 `#selectForKey(hash)` 方法，选一个 Invoker 对象。代码如下：

  ```
  private Invoker<T> selectForKey(long hash) {
      // 得到大于当前 key 的那个子 Map ，然后从中取出第一个 key ，就是大于且离它最近的那个 key
      Map.Entry<Long, Invoker<T>> entry = virtualInvokers.tailMap(hash, true).firstEntry();
      // 不存在，则取 virtualInvokers 第一个
  	if (entry == null) {
  		entry = virtualInvokers.firstEntry();
  	}
  	// 存在，则返回
  	return entry.getValue();
  }
  ```

# 5、Merger 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（四）之 LoadBalance 实现》](http://svip.iocoder.cn/Dubbo/cluster-4-impl-loadbalance/?self) 一文，分享 `dubbo-cluster` 模块， `merger` 包，**各种 Merger 实现类**。

Merger 相关类，如下图：

[![Merger 相关类](http://static.iocoder.cn/images/Dubbo/2019_04_20/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_20/01.png)Merger 相关类

我们可以看到，目前一共有**两部分**：

- Merger 以及其实现类。
- MergerCluster 以及其 MergerClusterInvoker

> 老艿艿：本文对应 [《Dubbo 用户指南 —— 分组聚合》](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) 文档。

## 2. Merger

`com.alibaba.dubbo.rpc.cluster.Merger` ，Merger **接口**，提供接口方法，将**对象数组**合并成**一个对象**。代码如下：

```
@SPI
public interface Merger<T> {

    /**
     * 合并 T 数组，返回合并后的 T 对象
     *
     * @param items T 数组
     * @return T 对象
     */
    T merge(T... items);

}
```

- `@SPI` 注解，Dubbo SPI **拓展点**，无默认值。

#### 2.1 Merger 实现类

Merger 内置**十二**个实现类，从代码上看基本类似。我们以 MapMerger 和 ShortArrayMerger 作为例子。

###### 2.1.1 MapMerger

`com.alibaba.dubbo.rpc.cluster.merger.MapMerger` ，实现 Merger 接口，Map Merger 实现类。代码如下：

```
public class MapMerger implements Merger<Map<?, ?>> {

    @Override
    public Map<?, ?> merge(Map<?, ?>... items) {
        if (items.length == 0) {
            return null;
        }
        // 创建结果 Map
        Map<Object, Object> result = new HashMap<Object, Object>();
        // 合并多个 Map
        for (Map<?, ?> item : items) {
            if (item != null) {
                result.putAll(item);
            }
        }
        return result;
    }

}
```

###### 2.1.2 ShortArrayMerger

`com.alibaba.dubbo.rpc.cluster.merger.ShortArrayMerger` ，实现 Merger 接口，Short 数组 Merger 实现类。代码如下：

```
public class ShortArrayMerger implements Merger<short[]> {

    @Override
    public short[] merge(short[]... items) {
        // 计算合并后的数组大小
        int total = 0;
        for (short[] array : items) {
            total += array.length;
        }
        // 创建结果数组
        short[] result = new short[total];
        // 合并多个数组
        int index = 0;
        for (short[] array : items) {
            for (short item : array) {
                result[index++] = item;
            }
        }
        return result;
    }

}
```

#### 2.2 MergerFactory

`com.alibaba.dubbo.rpc.cluster.merger.MergerFactory` ，Merger 工厂类，提供 `#getMerger(Class<T> returnType)` 方法，获得**指定类**对应的 Merger 对象。代码如下：

```
public class MergerFactory {

    /**
     * Merger 对象缓存
     */
    private static final ConcurrentMap<Class<?>, Merger<?>> mergerCache = new ConcurrentHashMap<Class<?>, Merger<?>>();

    public static <T> Merger<T> getMerger(Class<T> returnType) {
        Merger result;
        // 数组类型
        if (returnType.isArray()) {
            Class type = returnType.getComponentType();
            // 从缓存中获得 Merger 对象
            result = mergerCache.get(type);
            if (result == null) {
                loadMergers();
                result = mergerCache.get(type);
            }
            // 获取不到，使用 ArrayMerger
            if (result == null && !type.isPrimitive()) {
                result = ArrayMerger.INSTANCE;
            }
        // 普通类型
        } else {
            // 从缓存中获得 Merger 对象
            result = mergerCache.get(returnType);
            if (result == null) {
                loadMergers();
                result = mergerCache.get(returnType);
            }
        }
        return result;
    }

    /**
     * 初始化所有的 Merger 拓展对象，到 mergerCache 缓存中。
      */
    static void loadMergers() {
        Set<String> names = ExtensionLoader.getExtensionLoader(Merger.class).getSupportedExtensions();
        for (String name : names) {
            Merger m = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(name);
            mergerCache.putIfAbsent(ReflectUtils.getGenericClass(m.getClass()), m);
        }
    }

}
```

## 3. MergeableCluster

`com.alibaba.dubbo.rpc.cluster.support.MergeableCluster` ，实现 Cluster 接口，分组聚合 Cluster 实现类。代码如下：

```
public class MergeableCluster implements Cluster {

    public static final String NAME = "mergeable";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new MergeableClusterInvoker<T>(directory);
    }

}
```

- 对应 Invoker 实现类为 MergeableClusterInvoker 。

Merger 的使用，**需要设置 Cluster 的实现类为 MergeableCluster** 。但是呢，它的配置方式，和其他 Cluster 实现类不同。

- 使用方式，参见 [《Dubbo 用户指南 —— 分组聚合》](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) 文档。
- 原因，参见 [《精尽 Dubbo 源码解析 —— 集群容错（三）之 Directory 实现》](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory?self) 的 [「4.3.3.3 toMergeMethodInvokerMap」](http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/#) 。

#### 3.1 MergeableClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.MergeableClusterInvoker` ，实现 Invoker 接口，MergeableCluster Invoker 实现类。代码如下：

```
/**
 * Directory$Adaptive 对象
 */
private final Directory<T> directory;
/**
 * ExecutorService 对象，并且为 CachedThreadPool 。
 */
private ExecutorService executor = Executors.newCachedThreadPool(new NamedThreadFactory("mergeable-cluster-executor", true));

  1: @Override
  2: public Result invoke(final Invocation invocation) throws RpcException {
  3:     // 获得 Invoker 集合
  4:     List<Invoker<T>> invokers = directory.list(invocation);
  5:     // 获得 Merger 拓展名
  6:     String merger = getUrl().getMethodParameter(invocation.getMethodName(), Constants.MERGER_KEY);
  7:     // 若果未配置拓展，直接调用首个可用的 Invoker 对象
  8:     if (ConfigUtils.isEmpty(merger)) { // If a method doesn't have a merger, only invoke one Group
  9:         for (final Invoker<T> invoker : invokers) {
 10:             if (invoker.isAvailable()) {
 11:                 return invoker.invoke(invocation);
 12:             }
 13:         }
 14:         return invokers.iterator().next().invoke(invocation);
 15:     }
 16: 
 17:     // 通过反射，获得返回类型
 18:     Class<?> returnType;
 19:     try {
 20:         returnType = getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()).getReturnType();
 21:     } catch (NoSuchMethodException e) {
 22:         returnType = null;
 23:     }
 24: 
 25:     // 提交线程池，并行执行，发起 RPC 调用，并添加到 results 中
 26:     Map<String, Future<Result>> results = new HashMap<String, Future<Result>>();
 27:     for (final Invoker<T> invoker : invokers) {
 28:         Future<Result> future = executor.submit(new Callable<Result>() {
 29:             public Result call() {
 30:                 // RPC 调用
 31:                 return invoker.invoke(new RpcInvocation(invocation, invoker));
 32:             }
 33:         });
 34:         results.put(invoker.getUrl().getServiceKey(), future);
 35:     }
 36: 
 37:     // 阻塞等待执行执行结果，并添加到 resultList 中
 38:     List<Result> resultList = new ArrayList<Result>(results.size());
 39:     int timeout = getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
 40:     for (Map.Entry<String, Future<Result>> entry : results.entrySet()) {
 41:         Future<Result> future = entry.getValue();
 42:         try {
 43:             Result r = future.get(timeout, TimeUnit.MILLISECONDS);
 44:             if (r.hasException()) { // 异常 Result ，打印错误日志，忽略
 45:                 log.error(new StringBuilder(32).append("Invoke ").append(getGroupDescFromServiceKey(entry.getKey())).append(" failed: ").append(r.getException().getMessage()).toString(), r.getException());
 46:             } else { // 正常 Result ，添加到 resultList 中
 47:                 resultList.add(r);
 48:             }
 49:         } catch (Exception e) { // 异常，抛出 RpcException 异常
 50:             throw new RpcException(new StringBuilder(32).append("Failed to invoke service ").append(entry.getKey()).append(": ").append(e.getMessage()).toString(), e);
 51:         }
 52:     }
 53: 
 54:     // 结果大小为空，返回空的 RpcResult
 55:     if (resultList.isEmpty()) {
 56:         return new RpcResult((Object) null);
 57:     // 结果大小为 1 ，返回首个 RpcResult
 58:     } else if (resultList.size() == 1) {
 59:         return resultList.iterator().next();
 60:     }
 61:     // 返回类型为 void ，返回空的 RpcResult
 62:     if (returnType == void.class) {
 63:         return new RpcResult((Object) null);
 64:     }
 65: 
 66:     Object result;
 67:     // 【第 1 种】基于合并方法
 68:     if (merger.startsWith(".")) {
 69:         // 获得合并方法 Method
 70:         merger = merger.substring(1);
 71:         Method method;
 72:         try {
 73:             method = returnType.getMethod(merger, returnType);
 74:         } catch (NoSuchMethodException e) {
 75:             throw new RpcException(new StringBuilder(32).append("Can not merge result because missing method [ ").append(merger).append(" ] in class [ ").append(returnType.getClass().getName()).append(" ]").toString());
 76:         }
 77:         // 有 Method ，进行合并
 78:         if (method != null) {
 79:             if (!Modifier.isPublic(method.getModifiers())) {
 80:                 method.setAccessible(true);
 81:             }
 82:             result = resultList.remove(0).getValue();
 83:             try {
 84:                 // 方法返回类型匹配，合并时，修改 result
 85:                 if (method.getReturnType() != void.class && method.getReturnType().isAssignableFrom(result.getClass())) {
 86:                     for (Result r : resultList) {
 87:                         result = method.invoke(result, r.getValue());
 88:                     }
 89:                 // 方法返回类型不匹配，合并时，不修改 result
 90:                 } else {
 91:                     for (Result r : resultList) {
 92:                         method.invoke(result, r.getValue());
 93:                     }
 94:                 }
 95:             } catch (Exception e) {
 96:                 throw new RpcException(new StringBuilder(32).append("Can not merge result: ").append(e.getMessage()).toString(), e);
 97:             }
 98:         // 无 Method ，抛出 RpcException 异常
 99:         } else {
100:             throw new RpcException(new StringBuilder(32).append("Can not merge result because missing method [ ").append(merger).append(" ] in class [ ").append(returnType.getClass().getName()).append(" ]").toString());
101:         }
102:     // 【第 2 种】基于 Merger
103:     } else {
104:         Merger resultMerger;
105:         // 【第 2.1 种】根据返回值类型自动匹配 Merger
106:         if (ConfigUtils.isDefault(merger)) {
107:             resultMerger = MergerFactory.getMerger(returnType);
108:         // 【第 2.2 种】指定 Merger
109:         } else {
110:             resultMerger = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(merger);
111:         }
112:         // 有 Merger ，进行合并
113:         if (resultMerger != null) {
114:             List<Object> rets = new ArrayList<Object>(resultList.size());
115:             for (Result r : resultList) {
116:                 rets.add(r.getValue());
117:             }
118:             result = resultMerger.merge(rets.toArray((Object[]) Array.newInstance(returnType, 0)));
119:         // 无 Merger ，抛出 RpcException 异常
120:         } else {
121:             throw new RpcException("There is no merger to merge result.");
122:         }
123:     }
124:     // 返回 RpcResult 结果
125:     return new RpcResult(result);
126: }
```

- 🙂 看似比较长，实际很易懂。
- 第 4 行：调用 `Directory#list(invocation)` 方法，获得服务 Invoker **集合**。
- 第 6 行：调用 `URL#getMethodParameter(methodName, "merger")` 方法，获得 Merger 拓展名，**方法级**。
- 第 7 至 15 行：若**未配置** Merger 拓展名，优先调用首个**可用**的 Invoker 对象，其次调用首个 Invoker 对象。
- 第 17 至 23 行：通过反射，获得调用方法的**返回类型**。
- 第 25 至 35 行：提交线程池，**并行**执行，发起 RPC 调用，并添加 Future 到 `results` 中。
- 第 37 至 52 行：**阻塞**等待执行结果，并添加到 `resultList` 中。**注意**，分成正常 Result、异常 Result（**忽略**）、Exception 三种情况。
- 第 54 至 56 行：结果大小为**空**，返回**空**的 RpcResult 。
- 第 57 至 60 行：结果大小为 **1** ，返回**首个** RpcResult 。
- 第 61 至 64 行：返回类型为 **void** ，返回**空**的 RpcResult 。
- ========== 【**第 1 种**】基于 Method 合并==========
- 第 68 行：若 `merger` 为 `"."` 开头，指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型**本身**。
- 第 69 至 76 行：调用 `Class#getMethod(String name, Class<?>... parameterTypes)` 方法，获得**合并方法 Method** 。这个方法，意味着“合并方法的参数类型必须是返回结果类型**本身**”！！！具体原因，见 [《dubbo源码-集群容错之MergeableCluster》](https://www.jianshu.com/p/512e2211f84c) ，搜索 `"在条件分支if ( merger.startsWith(".") ) {}"` 。
- 第 77 至 97 行：**有** Method ，**循环**调用 `Method#invoke(Object obj, Object... args)` 方法，进行合并。
- 第 98 至 101 行：**无** Method ，抛出 RpcException 异常。
- ========== 【**第 2 种**】基于 Merger 合并 ==========
- 【第 **2.1** 种】第 105 至 107 行：当 `merger` 为 `"default"` 或 `"true"` 时，调用 `MergerFactory#getMerger(Class<T> returnType)` 方法，根据**返回值类型**自动匹配 Merger 。
- 【第 **2.2** 种】第 108 至 111 行：调用 `ExtensionLoader#getExtension(merger)` 方法啊，获得**指定** Merger 。
- 第 112 至 118 行：**有** Merger ，**循环**调用 `Merger#merge(T... items)` 方法，进行合并。
- 第 119 至 122 行：**无** Method ，抛出 RpcException 异常。

# 6、Configurator 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（五）之 Merger 实现》](http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/?self) 一文，分享 `dubbo-cluster` 模块， `configurator` 包，实现 Dubbo 的**配置规则**功能。

Configurator 相关类，如下图：

[![Configurator 相关类](http://static.iocoder.cn/images/Dubbo/2019_04_25/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/01.png)Configurator 相关类

> 老艿艿：本文对应 [《Dubbo 用户指南 —— 配置规则》](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html) 文档。如果之前没了解过该功能的胖友，请先阅读了解下哈。

## 2. ConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.ConfiguratorFactory` ，Configurator 工厂接口，代码如下：

```
@SPI
public interface ConfiguratorFactory {

    /**
     * get the configurator instance.
     *
     * @param url - configurator url.
     * @return configurator instance.
     */
    @Adaptive("protocol")
    Configurator getConfigurator(URL url);

}
```

- `@SPI` 注解，Dubbo SPI **拓展点**，无默认值。
- `@Adaptive("protocol")` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Configurator 实现，使用 `URL.protocol` 属性。
- `#getConfigurator(URL url)` 接口方法，获得 Configurator 对象。

#### 2.1 OverrideConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory` ，实现 ConfiguratorFactory 接口，**OverrideConfigurator** 工厂。代码如下：

```
public class OverrideConfiguratorFactory implements ConfiguratorFactory {

    @Override
    public Configurator getConfigurator(URL url) {
        return new OverrideConfigurator(url);
    }

}
```

#### 2.2 AbsentConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory` ，实现 ConfiguratorFactory 接口，**AbsentConfigurator** 工厂。代码如下：

```
public class AbsentConfiguratorFactory implements ConfiguratorFactory {

    @Override
    public Configurator getConfigurator(URL url) {
        return new AbsentConfigurator(url);
    }

}
```

## 3. Configurator

`com.alibaba.dubbo.rpc.cluster.Configurator` ，实现 Comparable 接口，**配置规则**接口。代码如下：

```
public interface Configurator extends Comparable<Configurator> {

    /**
     * get the configurator url.
     *
     * 配置规则
     *
     * @return configurator url.
     */
    URL getUrl();

    /**
     * Configure the provider url.
     *
     * 配置到 URL 中
     *
     * @param url - old rovider url.
     * @return new provider url.
     */
    URL configure(URL url);

}
```

- **一个 Configurator 对象，对应一条配置规则**。
- Configurator 有**优先级**的要求，所以实现 Comparable 接口。
- `#getUrl()` 接口方法，获得配置 URL ，里面带有配置规则。
- `#configure(Url url)` 接口方法，**设置**配置规则到指定 URL 中。

#### 3.1 AbstractConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.AbstractConfigurator` ，实现 Configurator 接口，实现公用的配置规则的**匹配**、**排序**的逻辑。

###### 3.1.1 getUrl

```
/**
 * 配置规则 URL
 */
private final URL configuratorUrl;

public AbstractConfigurator(URL url) {
    if (url == null) {
        throw new IllegalArgumentException("configurator url == null");
    }
    this.configuratorUrl = url;
}

@Override
public URL getUrl() {
    return configuratorUrl;
}
```

###### 3.1.2 configure

```
 1: @Override
 2: public URL configure(URL url) {
 3:     if (configuratorUrl.getHost() == null || url == null || url.getHost() == null) {
 4:         return url;
 5:     }
 6:     // If override url has port, means it is a provider address. We want to control a specific provider with this override url, it may take effect on the specific provider instance or on consumers holding this provider instance.
 7:     // 配置规则，URL 带有端口( port )，意图是控制提供者机器。可以在提供端生效 也可以在消费端生效
 8:     if (configuratorUrl.getPort() != 0) {
 9:         if (url.getPort() == configuratorUrl.getPort()) {
10:             return configureIfMatch(url.getHost(), url);
11:         }
12:     // override url don't have a port, means the ip override url specify is a consumer address or 0.0.0.0
13:     // 配置规则，URL 没有端口，override 输入消费端地址 或者 0.0.0.0
14:     } else {
15:         // 1.If it is a consumer ip address, the intention is to control a specific consumer instance, it must takes effect at the consumer side, any provider received this override url should ignore;
16:         // 2.If the ip is 0.0.0.0, this override url can be used on consumer, and also can be used on provider
17:         // 1. 如果是消费端地址，则意图是控制消费者机器，必定在消费端生效，提供端忽略；
18:         // 2. 如果是0.0.0.0可能是控制提供端，也可能是控制提供端
19:         if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {
20:             // NetUtils.getLocalHost是消费端注册到zk的消费者地址
21:             return configureIfMatch(NetUtils.getLocalHost(), url);// NetUtils.getLocalHost is the ip address consumer registered to registry.
22:         } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {
23:             // 控制所有提供端，地址必定是0.0.0.0，否则就要配端口从而执行上面的if分支了
24:             return configureIfMatch(Constants.ANYHOST_VALUE, url);// take effect on all providers, so address must be 0.0.0.0, otherwise it won't flow to this if branch
25:         }
26:     }
27:     return url;
28: }
```

- 我们可以看到，【第 6 至 26 行】一共有

  三种

  情况的判断：

  - 【第一种】第 8 行： `configuratorUrl` 带有**端口( port )**，意图是匹配**指定一个**服务提供者，因此使用 `url.host` 属性。
  - 【第二种】第 19 行：`url` 的 `side = consumer` ，意图是匹配服务消费者，因此使用 `NetUtils#getLocalHost()` 属性。
  - 【第三种】第 22 行：`url` 的 `side = provider` ，意图是匹配**全部**服务提供者，因此使用 `Constants.ANYHOST_VALUE = *` 属性。🙂 也就是说，目前暂不支持**指定机器**服务提供者。

- 第 10 行 || 第 21 行 || 第 24 行：调用 `#configureIfMatch(host, url)` 方法，配置到 `url` 中，若配置规则匹配。

####### 3.1.2.1 configureIfMatch

```
 1: private URL configureIfMatch(String host, URL url) {
 2:     // 匹配 Host
 3:     if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) {
 4:         // 匹配 "application"
 5:         String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY, configuratorUrl.getUsername()); // TODO 芋艿，为啥 username
 6:         String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());
 7:         if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)
 8:                 || configApplication.equals(currentApplication)) {
 9:             // 配置 URL 中的条件 KEYS 集合。其中下面四个 KEY ，不算是条件，而是内置属性。考虑到下面要移除，所以添加到该集合中。
10:             Set<String> conditionKeys = new HashSet<String>();
11:             conditionKeys.add(Constants.CATEGORY_KEY);
12:             conditionKeys.add(Constants.CHECK_KEY);
13:             conditionKeys.add(Constants.DYNAMIC_KEY);
14:             conditionKeys.add(Constants.ENABLED_KEY);
15:             // 判断传入的 url 是否匹配配置规则 URL 的条件。除了 "application" 和 "side" 之外，带有 `"~"` 开头的 KEY ，也是条件。
16:             for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {
17:                 String key = entry.getKey();
18:                 String value = entry.getValue();
19:                 if (key.startsWith("~") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {
20:                     conditionKeys.add(key);
21:                     // 若不相等，则不匹配配置规则，直接返回
22:                     if (value != null && !Constants.ANY_VALUE.equals(value)
23:                             && !value.equals(url.getParameter(key.startsWith("~") ? key.substring(1) : key))) {
24:                         return url;
25:                     }
26:                 }
27:             }
28:             // 移除条件 KEYS 集合，并配置到 URL 中
29:             return doConfigure(url, configuratorUrl.removeParameters(conditionKeys));
30:         }
31:     }
32:     return url;
33: }
```

- 第 3 行：匹配 **HOST** 。

- 第 4 至 8 行：匹配 **`"application"`** 。

- 第 9 至 14 行：配置 URL 中的**条件 KEYS 集合**。其中下面四个 KEY ，不算是条件，而是**内置属性**。考虑到下面要移除，所以添加到该集合中。

- 第 15 至 27 行：判断传入的

   

  ```
  url
  ```

   

  是否匹配配置规则 URL 的条件。除了

   

  ```
  "application"
  ```

   

  和

   

  ```
  "side"
  ```

   

  之外，

  带有 `"~"` 开头的 KEY ，也是条件

  。

  - 第 21 至 25 行： 若**不相等**，则**不匹配**配置规则，直接返回 `url` 。

- 第 29 行：从 `configuratorUrl` **移除**条件 KEYS 集合，并调用 `#doConfigure(URL currentUrl, URL configUrl)` **抽象**方法，实现**子类**设置**配置规则**到 `url` 中。

####### 3.1.2.2 doConfigure

```
protected abstract URL doConfigure(URL currentUrl, URL configUrl);
```

###### 3.1.3 compareTo

```
@Override
public int compareTo(Configurator o) {
    if (o == null) {
        return -1;
    }
    // host 升序
    int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());
    // 若 host 相同，按照 priority 降序
    if (ipCompare == 0) {//host is the same, sort by priority
        int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0);
        int j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);
        if (i < j) {
            return -1;
        } else if (i > j) {
            return 1;
        } else {
            return 0;
        }
    } else {
        return ipCompare;
    }
}
```

- 优先，按照 host **升序**，即**特定** host **高**于 **anyhost**( `"0.0.0.0"` ) 。
- 其次，按照 `"priority"` **降序**。

#### 3.2 OverrideConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfigurator` ，实现 AbstractConfigurator 抽象类，`override` Configurator 实现类。代码如下：

```
public class OverrideConfigurator extends AbstractConfigurator {

    public OverrideConfigurator(URL url) {
        super(url);
    }

    @Override
    public URL doConfigure(URL currentUrl, URL configUrl) {
        return currentUrl.addParameters(configUrl.getParameters()); // 覆盖添加
    }

}
```

- **覆盖**添加。

#### 3.3 AbsentConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfigurator` ，实现 AbstractConfigurator 抽象类，`absent` Configurator 实现类。代码如下：

```
public class AbsentConfigurator extends AbstractConfigurator {

    public AbsentConfigurator(URL url) {
        super(url);
    }

    @Override
    public URL doConfigure(URL currentUrl, URL configUrl) {
        return currentUrl.addParametersIfAbsent(configUrl.getParameters()); // 不存在时添加
    }

}
```

- **不存在时**添加。

从目前 `dubbo-admin` 项目来看，目前**暂未使用** `absent` 的配置规则。

## 4. 集成 Configurator 模块

如下图所示，我们可以看到，有**三个类**，调用 `Configurator#configure(URL url)` 方法，集成 Configurator 模块。

[![集成](http://static.iocoder.cn/images/Dubbo/2019_04_25/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/02.png)集成

#### 4.1 RegistryDirectory

RegistryDirectory 将配置规则集成到其中，从而集成到**服务消费者**中。

###### 4.1.1 toConfigurators

`#toConfigurators(List<URL> urls)` 方法，官方注释如下：

```
/**
 * 将overrideURL 转换为 map，供重新 refer 时使用.
 * 每次下发全部规则，全部重新组装计算
 *
 * @param urls 契约：
 *             </br>1.override://0.0.0.0/...(或override://ip:port...?anyhost=true)&para1=value1...表示全局规则(对所有的提供者全部生效)
 *             </br>2.override://ip:port...?anyhost=false 特例规则（只针对某个提供者生效）
 *             </br>3.不支持override://规则... 需要注册中心自行计算.
 *             </br>4.不带参数的override://0.0.0.0/ 表示清除override
 *
 * @return Configurator 集合
 */
 public static List<Configurator> toConfigurators(List<URL> urls) {
    // ...省略代码
 }
```

- 实际上，该注释说明了配置规则，在 RegistryDirectory 中，是**如何集成配置规则模块**。特别是**四条**契约，胖友好好理解下。

该方法的真正注释，应该是：将配置规则 URL 集合，**转换**成对应的 Configurator 集合。代码如下：

```
 1: public static List<Configurator> toConfigurators(List<URL> urls) {
 2:     // 忽略，若配置规则 URL 集合为空
 3:     if (urls == null || urls.isEmpty()) {
 4:         return Collections.emptyList();
 5:     }
 6: 
 7:     // 创建 Configurator 集合
 8:     List<Configurator> configurators = new ArrayList<Configurator>(urls.size());
 9:     for (URL url : urls) {
10:         // 若协议为 `empty://` ，意味着清空所有配置规则，因此返回空 Configurator 集合
11:         if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
12:             configurators.clear();
13:             break;
14:         }
15:         // 对应第 4 条契约，不带参数的 override://0.0.0.0/ 表示清除 override
16:         Map<String, String> override = new HashMap<String, String>(url.getParameters());
17:         // The anyhost parameter of override may be added automatically, it can't change the judgement of changing url
18:         // override 上的 anyhost 可能是自动添加的，不能影响改变url判断
19:         override.remove(Constants.ANYHOST_KEY);
20:         if (override.size() == 0) {
21:             configurators.clear();
22:             continue;
23:         }
24:         // 获得 Configurator 对象，并添加到 `configurators` 中
25:         configurators.add(configuratorFactory.getConfigurator(url));
26:     }
27:     // 排序
28:     Collections.sort(configurators);
29:     return configurators;
30: }
```

- 第 2 至 5 行：**忽略**，若 `urls` 集合为空。
- 的 8 行：创建 Configurator 集合 `configurators` 变量。
- 第 9 至 26 行：**循环** `urls` 集合，**转换**成对应的 Configurator 集合。🙂 中间的过程，胖友看下注释。
- 第 28 行：将 `configurators` 集合，**排序**。具体的排序规则，在 [「3.13 compareTo」](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/#) 已经解析。

###### 4.1.2 mergeUrl

```
 1: private URL mergeUrl(URL providerUrl) {
 2:     // 合并消费端参数
 3:     providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
 4: 
 5:     // 合并配置规则
 6:     List<Configurator> localConfigurators = this.configurators; // local reference
 7:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
 8:         for (Configurator configurator : localConfigurators) {
 9:             providerUrl = configurator.configure(providerUrl);
10:         }
11:     }
12: 
13:     // 不检查连接是否成功，总是创建 Invoker ！
14:     providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15: 
16:     // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17:     // 仅合并提供者参数，因为 directoryUrl 与 override 合并是在 notify 的最后，这里不能够处理
18:     this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters
19: 
20:     // 【忽略】因为是对 1.0 版本的兼容
21:     if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22:             && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23:         //fix by tony.chenl DUBBO-44
24:         String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25:         if (path != null) {
26:             int i = path.indexOf('/');
27:             if (i >= 0) {
28:                 path = path.substring(i + 1);
29:             }
30:             i = path.lastIndexOf(':');
31:             if (i >= 0) {
32:                 path = path.substring(0, i);
33:             }
34:             providerUrl = providerUrl.setPath(path);
35:         }
36:     }
37: 
38:     // 返回服务提供者 URL
39:     return providerUrl;
40: }
```

- 第 5 至 11 行：循环 `configurators` 集合，调用 `Configurator#configure(URL url)` 方法，合并**配置规则**到 `providerUrl` 中。
- 第 14 行：**仅**合并提供者参数到 `overrideDirectoryUrl` 中，因为 `directoryUrl` 与配置规则的合并是在 `#notify(List<URL> urls)` 方法的**最后**，因而这里不能够处理。代码如下图所示：[![notify](http://static.iocoder.cn/images/Dubbo/2019_04_25/03.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/03.png)notify

#### 4.2 RegistryProtocol

RegistryProtocol 通过向**注册中心**注册 OverrideListener 监听器，从而集成配置规则到**服务提供者**中。

###### 4.2.1 export

```
 1: @Override
 2: public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
 3:     // 暴露服务
 4:     // export invoker
 5:     final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);
 6: 
 7:     // 获得注册中心 URL
 8:     URL registryUrl = getRegistryUrl(originInvoker);
 9: 
10:     // 获得注册中心对象
11:     // registry provider
12:     final Registry registry = getRegistry(originInvoker);
13: 
14:     // 获得服务提供者 URL
15:     final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);
16: 
17:     //to judge to delay publish whether or not
18:     boolean register = registedProviderUrl.getParameter("register", true);
19: 
20:     // 向注册中心订阅服务消费者
21:     ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);
22: 
23:     // 向注册中心注册服务提供者（自己）
24:     if (register) {
25:         register(registryUrl, registedProviderUrl);
26:         ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); // // 标记向本地注册表的注册服务提供者，已经注册
27:     }
28: 
29:     // 使用 OverrideListener 对象，订阅配置规则
30:     // Subscribe the override data
31:     // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.
32:     // 创建订阅配置规则的 URL
33:     final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);
34:     // 创建 OverrideListener 对象，并添加到 `overrideListeners` 中
35:     final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
36:     overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
37:     // 向注册中心，发起订阅
38:     registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
39:     //Ensure that a new exporter instance is returned every time export
40:     return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);
41: }
```

- 第 29 至 38 行：使用 **OverrideListener** 对象，订阅配置规则。

  - 第 33 行：调用 `#getSubscribedOverrideUrl(registedProviderUrl)` 方法，创建**订阅配置规则**的 URL 。代码如下：

    ```
    private URL getSubscribedOverrideUrl(URL registedProviderUrl) {
        return registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)
                .addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY, // configurators
                        Constants.CHECK_KEY, String.valueOf(false)); // 订阅失败，不校验
    }
    ```

    - x

  - 第 34 至 36 行：创建 **OverrideListener** 对象，并添加到 `overrideListeners` 中。

  - 第 38 行：调用 `Registry#subscribe(overrideSubscribeUrl, overrideSubscribeListener)` 方法，向注册中心注册 **OverrideListener** 监听器，订阅配置规则的变化。

###### 4.2.2 OverrideListener

OverrideListener 是 RegistryProtocol **内部类**，实现 NotifyListener 接口，官方注释如下：

```
/**
 * 重新 export ：protocol 中的 exporter destroy 问题
 *
 * 1. 要求 registry protocol 返回的 exporter 可以正常 destroy
 * 2. notify 后不需要重新向注册中心注册
 * 3. export 方法传入的 invoker 最好能一直作为 exporter 的 invoker.
 */
```

- 初看有点绕，我们来瞅瞅代码。

####### 4.2.2.1 构造方法

```
/**
 * 订阅 URL 对象
 */
private final URL subscribeUrl;
/**
 * 原始 Invoker 对象
 */
private final Invoker originInvoker;

public OverrideListener(URL subscribeUrl, Invoker originalInvoker) {
    this.subscribeUrl = subscribeUrl;
    this.originInvoker = originalInvoker;
}
```

####### 4.2.2.2 notify

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // 获得匹配的规则配置 URL 集合
 4:     logger.debug("original override urls: " + urls);
 5:     List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);
 6:     logger.debug("subscribe url: " + subscribeUrl + ", override urls: " + matchedUrls);
 7:     // No matching results
 8:     if (matchedUrls.isEmpty()) {
 9:         return;
10:     }
11:     // 将配置规则 URL 集合，**转换**成对应的 Configurator 集合
12:     List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);
13: 
14:     // 获得真实的 Invoker 对象
15:     final Invoker<?> invoker;
16:     if (originInvoker instanceof InvokerDelegete) {
17:         invoker = ((InvokerDelegete<?>) originInvoker).getInvoker();
18:     } else {
19:         invoker = originInvoker;
20:     }
21:     // The origin invoker
22:     // 获得真实的 Invoker 的 URL 对象
23:     URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);
24: 
25:     // 忽略，若对应的 Exporter 对象不存在
26:     String key = getCacheKey(originInvoker);
27:     ExporterChangeableWrapper<?> exporter = bounds.get(key);
28:     if (exporter == null) {
29:         logger.warn(new IllegalStateException("error state, exporter should not be null"));
30:         return;
31:     }
32: 
33:     // The current, may have been merged many times
34:     // 获得 Invoker 当前的 URL 对象，可能已经被之前的配置规则合并过
35:     URL currentUrl = exporter.getInvoker().getUrl();
36:     // Merged with this configuration
37:     // 基于 originUrl 对象，合并配置规则，生成新的 newUrl 对象
38:     URL newUrl = getConfigedInvokerUrl(configurators, originUrl);
39:     // 判断新老 Url 不匹配，重新暴露 Invoker
40:     if (!currentUrl.equals(newUrl)) {
41:         RegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);
42:         logger.info("exported provider url changed, origin url: " + originUrl + ", old export url: " + currentUrl + ", new export url: " + newUrl);
43:     }
44: }
```

- 第 3 至 10 行：调用 `#getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe)` 方法，获得匹配的**规则配置** URL 集合。代码如下：

  ```
  private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {
      List<URL> result = new ArrayList<URL>();
      for (URL url : configuratorUrls) {
          URL overrideUrl = url;
          // 【忽略】，兼容老版本
          // Compatible with the old version
          if (url.getParameter(Constants.CATEGORY_KEY) == null
                  && Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {
              overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);
          }
          // 判断是否匹配
          // Check whether url is to be applied to the current service
          if (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {
              result.add(url);
          }
      }
      return result;
  }
  ```

  - 通过调用 `UrlUtils#isMatch(currentSubscribe, overrideUrl)` 方法，进行判断**是否匹配**。该方法具体实现的逻辑，比较简单，所以判断自己查看。

- 第 12 行：调用 `RegistryDirectory#toConfigurators(matchedUrls)` 方法，将配置规则 URL 集合，**转换**成对应的 Configurator 集合。

- 第 14 至 23 行：获得**真实**的 Invoker 和**对应**的 URL 对应。

- 第 25 至 31 行：**忽略**，若对应的 Exporter 对象不存在。

- ========== **重点** ==========

- 第 35 行：通过 `exporter` 的 Invoker ，获得 Invoker **当前**的 URL 对象，**可能已经被之前的配置规则合并过**。

- 第 38 行：调用 `#getConfigedInvokerUrl(configurators,originUrl)` 方法，基于 `originUrl` 对象，**合并配置规则**，生成**新的** `newUrl` 对象。代码如下：

  ```
  private URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {
      for (Configurator configurator : configurators) {
          // 合并配置规则
          url = configurator.configure(url);
      }
      return url;
  }
  ```

- 第 39 至 43 行：判断新老 URL 若**不匹配**，调用 `RegistryProtocol#doChangeLocalExport(originInvoker, newUrl)` 方法，**重新暴露** Invoker 对象。详细解析，见 [「4.2.3 doChangeLocalExport」](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/#) 。

###### 4.2.3 doChangeLocalExport

```
 1: private <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {
 2:     // 校验对应的 Exporter 是否存在。若不存在，打印告警日志。
 3:     String key = getCacheKey(originInvoker);
 4:     final ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);
 5:     if (exporter == null) {
 6:         logger.warn(new IllegalStateException("error state, exporter should not be null"));
 7:     } else {
 8:         // 创建 InvokerDelegete 对象
 9:         final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);
10:         // 重新暴露 Invoker
11:         // 设置到 ExporterChangeableWrapper 中
12:         exporter.setExporter(protocol.export(invokerDelegete));
13:     }
14: }
```

- 第 2 至 6 行：**校验**对应的 ExporterChangeableWrapper 是否存在。若不存在，打印**告警**日志。

- 第 9 行：创建 InvokerDelegete 对象。

- 第 12 行：调用

   

  ```
  Protocol$Adaptive#export(Invoker)
  ```

   

  方法，

  重新暴露

   

  Invoker 对象。

  😈 可能会有机智的胖友会问，原来的 Exporter 不进行

  销毁

  么?实际上

  不需要

  ，原因有两点：

  - 1、每个协议初始化的 Server 有**缓存** ，所以重新初始化，可以重用**缓存**中的 Server 。
  - 2、如果**销毁**原有 Exporter ，会导致**缓存**的 Server 也一起销毁。**而且，即使不销毁，原有 Exporter 也就是一个对象，可以被回收掉**。

- 第 12 行：调用 `ExporterChangeableWrapper#setExporter(exporter)` 方法，设置**新的** Exporter 对象。

#### 4.3 ServiceConfig

TODO 8038 ServiceConfig 为啥判断了 url.protocol

# 7、Router 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（六）之 Configurator 实现》](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self) 一文，分享 `dubbo-cluster` 模块， `router` 包，实现 Dubbo 的**路由规则**功能。

Router 相关类，如下图：

[![Router 相关类](http://static.iocoder.cn/images/Dubbo/2019_04_30/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_30/02.png)Router 相关类

> 老艿艿：本文对应 [《Dubbo 用户指南 —— 路由规则》](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html) 文档。如果之前没了解过该功能的胖友，请先阅读了解下哈。

## 2. RouterFactory

`com.alibaba.dubbo.rpc.cluster.RouterFactory` ，Router 工厂**接口**。代码如下：

```
@SPI
public interface RouterFactory {

    /**
     * Create router.
     *
     * 创建 Router 对象
     *
     * @param url
     * @return router
     */
    @Adaptive("protocol")
    Router getRouter(URL url);

}
```

- `@SPI` 注解，Dubbo SPI **拓展点**，无默认值。
- `@Adaptive("protocol")` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Router 实现，使用 `URL.protocol` 属性。
- `#getRouter(URL url)` 接口方法，获得 Router 对象。

#### 2.1 ConditionRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouterFactory` ，实现 RouterFactory 接口，**ConditionRouter** 工厂实现类。代码如下：

```
public class ConditionRouterFactory implements RouterFactory {

    public static final String NAME = "condition";

    @Override
    public Router getRouter(URL url) {
        return new ConditionRouter(url);
    }

}
```

- 对应 Router 实现类为 ConditionRouter 。

#### 2.2 ScriptRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouterFactory` ，实现 RouterFactory 接口，**ScriptRouter** 工厂实现类。代码如下：

```
public class ScriptRouterFactory implements RouterFactory {

    public static final String NAME = "script";

    @Override
    public Router getRouter(URL url) {
        return new ScriptRouter(url);
    }

}
```

- 对应 Router 实现类为 ScriptRouter 。

#### 2.3 FileRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.file.FileRouterFactory` ，实现 RouterFactory 接口，基于**文件**读取路由规则，创建**对应的 Router 实现类的对象**。代码如下：

```
 1: public class FileRouterFactory implements RouterFactory {
 2: 
 3:     public static final String NAME = "file";
 4: 
 5:     /**
 6:      * RouterFactory$Adaptive 对象
 7:      */
 8:     private RouterFactory routerFactory;
 9: 
10:     public void setRouterFactory(RouterFactory routerFactory) {
11:         this.routerFactory = routerFactory;
12:     }
13: 
14:     @Override
15:     public Router getRouter(URL url) {
16:         try {
17:             // Transform File URL into Script Route URL, and Load
18:             // file:///d:/path/to/route.js?router=script ==> script:///d:/path/to/route.js?type=js&rule=<file-content>
19:             // 获得 router 配置项，默认为 script
20:             String protocol = url.getParameter(Constants.ROUTER_KEY, ScriptRouterFactory.NAME); // Replace original protocol (maybe 'file') with 'script'
21:             // 使用文件后缀做为类型
22:             String type = null; // Use file suffix to config script type, e.g., js, groovy ...
23:             String path = url.getPath();
24:             if (path != null) {
25:                 int i = path.lastIndexOf('.');
26:                 if (i > 0) {
27:                     type = path.substring(i + 1);
28:                 }
29:             }
30:             // 读取规则内容
31:             String rule = IOUtils.read(new FileReader(new File(url.getAbsolutePath())));
32: 
33:             // 创建路由规则 URL
34:             boolean runtime = url.getParameter(Constants.RUNTIME_KEY, false);
35:             URL script = url.setProtocol(protocol).addParameter(Constants.TYPE_KEY, type)
36:                     .addParameter(Constants.RUNTIME_KEY, runtime)
37:                     .addParameterAndEncoded(Constants.RULE_KEY, rule);
38: 
39:             // 通过 Dubbo SPI Adaptive 机制，获得 Router 对象
40:             return routerFactory.getRouter(script);
41:         } catch (IOException e) {
42:             throw new IllegalStateException(e.getMessage(), e);
43:         }
44:     }
45: 
46: }
```

- 第 20 行：获得 `"router"` 配置项，默认为 `"script"` 。
- 第 21 至 29 行：获得**类型**，基于文件后缀。
- 第 31 行：从**文件**中，读取**规则内容**。
- 第 33 至 37 行：创建路由规则 URL 对象。
- 第 40 行：通过 Dubbo SPI **Adaptive** 机制，获得**对应的 Router 对象**。

## 3. Router

`com.alibaba.dubbo.rpc.cluster.Router` ，实现 Comparable 接口，**路由规则**接口。代码如下：

```
public interface Router extends Comparable<Router> {

    /**
     * get the router url.
     * <p>
     * 路由规则 URL
     *
     * @return url
     */
    URL getUrl();

    /**
     * route.
     *
     * 路由，筛选匹配的 Invoker 集合
     *
     * @param invokers   Invoker 集合
     * @param url        refer url
     * @param invocation
     * @return routed invokers 路由后的 Invoker 集合
     * @throws RpcException
     */
    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;

}
```

- **一个 Router 对象，对应一条路由规则**。
- Configurator 有**优先级**的要求，所以实现 Comparable 接口。
- `#getUrl()` 接口方法，获得路由 URL ，里面带有路由规则。
- `#route(List<Invoker<T>> invokers, URL url, Invocation invocation)` 接口方法，路由，筛选**匹配的** Invoker 集合。

#### 3.1 ConditionRouter

`com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouter` ，实现 Router 接口，**基于条件表达式**的 Router 实现类。

> 基于条件表达式的路由规则，如：`host = 10.20.153.10 => host = 10.20.153.11`

**注意**，胖友一定要看了 [《Dubbo 用户指南 —— 路由规则》](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#条件路由规则) 的 [条件路由规则](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) 部分，不然下面影响理解。

###### 3.1.1 构造方法

```
/**
 * 分组正则匹配，详细见 {@link #parseRule(String)} 方法
 *
 * 前 [] 为匹配，分隔符
 * 后 [] 为匹配，内容
 */
private static Pattern ROUTE_PATTERN = Pattern.compile("([&!=,]*)\\s*([^&!=,\\s]+)");

/**
 * 路由规则 URL
 */
private final URL url;
/**
 * 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0 。
 */
private final int priority;
/**
 * 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false 。
 */
private final boolean force;
/**
 * 消费者匹配条件集合，通过解析【条件表达式 rule 的 `=>` 之前半部分】
 */
private final Map<String, MatchPair> whenCondition;
/**
 * 提供者地址列表的过滤条件，通过解析【条件表达式 rule 的 `=>` 之后半部分】
 */
private final Map<String, MatchPair> thenCondition;

public ConditionRouter(URL url) {
    this.url = url;
    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
    this.force = url.getParameter(Constants.FORCE_KEY, false);
    try {
        // 拆分条件变大时为 when 和 then 两部分
        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
        if (rule == null || rule.trim().length() == 0) {
            throw new IllegalArgumentException("Illegal route rule!");
        }
        rule = rule.replace("consumer.", "").replace("provider.", "");
        int i = rule.indexOf("=>");
        String whenRule = i < 0 ? null : rule.substring(0, i).trim();
        String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
        // 解析 `whenCondition`
        Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || "true".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
        // 解析 `thenCondition`
        Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || "false".equals(thenRule) ? null : parseRule(thenRule);
        // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
        this.whenCondition = when;
        this.thenCondition = then;
    } catch (ParseException e) {
        throw new IllegalStateException(e.getMessage(), e);
    }
}
```

- 每个字段的解释，胖友自己看下注释。
- MatchPair ，见 [「3.1.2 MatchPair」](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) 中。
- `#parseRule()` 方法，见 [「3.1.3 parseRule」](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) 中。

###### 3.1.2 MatchPair

MatchPair 为 ConditionRouter 的**内部静态类**，用于匹配的值**组**。**每个**属性条件，例如 `method` `host` 等，对应**一个** MatchPair 对象。代码如下：

```
private static final class MatchPair {

    /**
     * 匹配的值集合
     */
    final Set<String> matches = new HashSet<String>();
    /**
     * 不匹配的值集合
     */
    final Set<String> mismatches = new HashSet<String>();

    /**
     * 判断 value 是否匹配 matches + mismatches
     *
     * @param value 值
     * @param param URL
     * @return 是否匹配
     */
    private boolean isMatch(String value, URL param) {
        // 只匹配 matches
        if (!matches.isEmpty() && mismatches.isEmpty()) {
            for (String match : matches) {
                if (UrlUtils.isMatchGlobPattern(match, value, param)) {
                    return true;
                }
            }
            return false; // 如果没匹配上，认为为 false ，即不匹配
        }

        // 只匹配 mismatches
        if (!mismatches.isEmpty() && matches.isEmpty()) {
            for (String mismatch : mismatches) {
                if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
                    return false;
                }
            }
            return true; // 注意，这里和上面不同。原因，你懂的。
        }

        // 匹配 mismatches + matches
        if (!matches.isEmpty()) {
            //when both mismatches and matches contain the same value, then using mismatches first
            for (String mismatch : mismatches) {
                if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
                    return false;
                }
            }
            for (String match : matches) {
                if (UrlUtils.isMatchGlobPattern(match, value, param)) {
                    return true;
                }
            }
            return false; // 如果没匹配上，认为为 false ，即不匹配
        }
        return false;
    }
}
```

- `#isMatch(String value, URL param)` 方法，判断 `value` 是否**匹配** `matches` 和 `mismatches` 。

  - 那么为什么会有 `param` 参数呢？因为要支持 `$` 从 URL 中，读取参数。

  - `#UrlUtils#isMatchGlobPattern(match, value, URL)` 方法，支持 `*` 通配，判断 `match` 和 `value` 是否匹配。代码如下：

    ```
    public static boolean isMatchGlobPattern(String pattern, String value, URL param) {
        // 以美元符 `$` 开头，表示引用参数
        if (param != null && pattern.startsWith("$")) {
            pattern = param.getRawParameter(pattern.substring(1));
        }
        // 匹配
        return isMatchGlobPattern(pattern, value);
    }
    
    public static boolean isMatchGlobPattern(String pattern, String value) {
        // 全匹配
        if ("*".equals(pattern)) {
            return true;
        }
        // 全部为空，匹配
        if ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {
            return true;
        }
        // 有一个为空，不匹配
        if ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {
            return false;
        }
    
        // 支持 * 的通配
        int i = pattern.lastIndexOf('*');
        // doesn't find "*"
        if (i == -1) {
            return value.equals(pattern);
        }
        // "*" is at the end
        else if (i == pattern.length() - 1) {
            return value.startsWith(pattern.substring(0, i));
        }
        // "*" is at the beginning
        else if (i == 0) {
            return value.endsWith(pattern.substring(i + 1));
        }
        // "*" is in the middle
        else {
            String prefix = pattern.substring(0, i);
            String suffix = pattern.substring(i + 1);
            return value.startsWith(prefix) && value.endsWith(suffix);
        }
    }
    ```

    - x

😈 代码比较简单，所以胖友自己读下。

###### 3.1.3 parseRule

`#parseRule(rule)` 方法，解析路由配置内容 `"rule"` 。代码如下：

```
 1: private static Map<String, MatchPair> parseRule(String rule) throws ParseException {
 2: //    System.out.println("rule: " + rule); // add by 芋艿，方便大家看
 3:     Map<String, MatchPair> condition = new HashMap<String, MatchPair>();
 4:     if (StringUtils.isBlank(rule)) {
 5:         return condition;
 6:     }
 7:     // Key-Value pair, stores both match and mismatch conditions
 8:     MatchPair pair = null;
 9:     // Multiple values
10:     Set<String> values = null;
11:     final Matcher matcher = ROUTE_PATTERN.matcher(rule);
12:     while (matcher.find()) { // Try to match one by one
13:         String separator = matcher.group(1);
14:         String content = matcher.group(2);
15: //        System.out.println(separator + "\t" + content); // add by 芋艿，方便大家看
16:         // Start part of the condition expression.
17:         if (separator == null || separator.length() == 0) {
18:             pair = new MatchPair();
19:             condition.put(content, pair);
20:         }
21:         // The KV part of the condition expression
22:         else if ("&".equals(separator)) {
23:             if (condition.get(content) == null) {
24:                 pair = new MatchPair();
25:                 condition.put(content, pair);
26:             } else {
27:                 pair = condition.get(content);
28:             }
29:         }
30:         // The Value in the KV part.
31:         else if ("=".equals(separator)) {
32:             if (pair == null) {
33:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
34:             }
35:             values = pair.matches;
36:             values.add(content);
37:         }
38:         // The Value in the KV part.
39:         else if ("!=".equals(separator)) {
40:             if (pair == null) {
41:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
42:             }
43:             values = pair.mismatches;
44:             values.add(content);
45:         }
46:         // The Value in the KV part, if Value have more than one items.
47:         else if (",".equals(separator)) { // Should be seperateed by ','
48:             if (values == null || values.isEmpty()) {
49:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
50:             }
51:             values.add(content);
52:         } else {
53:             throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
54:         }
55:     }
56:     return condition;
57: }
```

- 第 11 至 14 行：通过 `ROUTE_PATTERN` 正则匹配 `rule` ，**循环**多次，直到结束。如下是两个例子：

  ```
  rule: host = 192.168.3.17 & method = say01
  	host
  =	192.168.3.17
  &	method
  =	say01
  
  ---------- 分割线 ---------- 
  
  rule: host = 192.168.3.17
  	host
  =	192.168.3.17
  ```

- 第 16 至 29 行：处理条件**属性**的情况，例如：`host` 和 `& method` 等等，此时会获得对应的 MatchPair 对象。若不存在，则进行创建 MatchPair 对象。

- 第 30 至 45 行：处理条件

  条件值

  的情况，例如：

  ```
  = 192.168.3.17
  ```

   

  和

   

  ```
  != say01
  ```

   

  等等，此时会添加到 MatchPair 的

   

  ```
  matches
  ```

   

  或

   

  ```
  mismatches
  ```

   

  中。

  - 第 46 至 51 行：处理条件**条件值**以逗号( `,` )分隔多个值的情况，此时**也会**添加到 MatchPair 的 `matches` 或 `mismatches` 中。

- 第 52 至 54 行：非法，抛出 ParseException 异常。

###### 3.1.4 route

```
 1: @Override
 2: public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
 3:     // 为空，直接返回空 Invoker 集合
 4:     if (invokers == null || invokers.isEmpty()) {
 5:         return invokers;
 6:     }
 7:     try {
 8:         // 不匹配 `whenCondition` ，直接返回 `invokers` 集合，因为不需要走 `whenThen` 的匹配
 9:         if (!matchWhen(url, invocation)) {
10:             return invokers;
11:         }
12:         List<Invoker<T>> result = new ArrayList<Invoker<T>>();
13:         // `whenThen` 为空，则返回空 Invoker 集合
14:         if (thenCondition == null) {
15:             logger.warn("The current consumer in the service blacklist. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey());
16:             return result;
17:         }
18:         // 使用 `whenThen` ，匹配 `invokers` 集合。若符合，添加到 `result` 中
19:         for (Invoker<T> invoker : invokers) {
20:             if (matchThen(invoker.getUrl(), url)) {
21:                 result.add(invoker);
22:             }
23:         }
24:         // 若 `result` 非空，返回它
25:         if (!result.isEmpty()) {
26:             return result;
27:         // 如果 `force=true` ，代表强制执行，返回空 Invoker 集合
28:         } else if (force) {
29:             logger.warn("The route result is empty and force execute. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey() + ", router: " + url.getParameterAndDecoded(Constants.RULE_KEY));
30:             return result;
31:         }
32:     } catch (Throwable t) {
33:         logger.error("Failed to execute condition router rule: " + getUrl() + ", invokers: " + invokers + ", cause: " + t.getMessage(), t);
34:     }
35:     // 如果 `force=false` ，代表不强制执行，返回 `invokers` 集合，即忽略路由规则
36:     return invokers;
37: }
```

- 第 3 至 6 行：若 `invokers` 为空，直接返回**空** Invoker 集合。

- 第 8 至 11 行：调用 `#matchWhen(url, invocation)` 方法，使用服务**消费者** `url` 匹配 `whenCondition` 。代码如下：

  ```
  boolean matchWhen(URL url, Invocation invocation) {
      return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);
  }
  ```

  - 如果匹配条件为空，表示对所有消费方应用，如：`=> host != 10.20.153.11` 。
  - 若**不匹配**，则直接返回**全** `invokers` 集合，因为不需要走 `whenThen` 的匹配。
  - `#matchCondition(...)` 方法的详细解析，见 [「3.1.5 matchCondition」](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) 。

- 第 13 至 17 行：若 `whenThen` 为空，则返回**空** Invoker 集合。

- 第 18 至 23 行：**循环**调用 `#matchThen(url, invocation)` 方法，使用服务**提供者者** `invokers` 的 URL ，匹配 `whenThen` 集合。代码如下：

  ```
  private boolean matchThen(URL url, URL param) {
      return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);
  }
  ```

  - 如果过滤条件为空，表示禁止访问，如：`host = 10.20.153.10 =>` 。
  - 若**匹配**，添加到 `result` 中。

- ========== 处理 `result` + `force` 的**三种**情况 ==========

- 第 24 至 26 行：若 `result` **非空**，返回**它**。

- 第 27 至 31 行：若 `result` **为空**，如果 `force=true` ，代表强制执行，返回**空** Invoker 集合。

- 第 36 行：若 `result` **为空**，如果 `force=false` ，代表**不**强制执行，返回**全** `invokers` 集合，即**忽略**路由规则。

😈 情况比较多，胖友可以回过头在理一理。

####### 3.1.5 matchCondition

```
private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {
    Map<String, String> sample = url.toMap();
    boolean result = false; // 是否匹配
    for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {
        // 获得条件属性
        String key = matchPair.getKey();
        String sampleValue;
        // get real invoked method name from invocation
        if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {
            sampleValue = invocation.getMethodName();
        } else {
            sampleValue = sample.get(key);
            if (sampleValue == null) {
                sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);
            }
        }
        // 匹配条件值
        if (sampleValue != null) {
            if (!matchPair.getValue().isMatch(sampleValue, param)) { // 返回不匹配
                return false;
            } else {
                result = true;
            }
        } else {
            // not pass the condition
            if (!matchPair.getValue().matches.isEmpty()) { // 无条件值，但是有匹配条件 `matches` ，则返回不匹配。
                return false;
            } else {
                result = true;
            }
        }
    }
    return result;
}
```

###### 3.1.5 compareTo

```
@Override
public int compareTo(Router o) {
    if (o == null || o.getClass() != ConditionRouter.class) {
        return 1;
    }
    ConditionRouter c = (ConditionRouter) o;
    return this.priority == c.priority ? url.toFullString().compareTo(c.url.toFullString()) : (this.priority > c.priority ? 1 : -1);
}
```

- 优先，按照 `"priority"` **降序**。
- 其次，按照 `"url"` **升序**。

#### 3.2 ScriptRouter

`com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouter` ，实现 Router 接口，基于**脚本**的 Router 实现类。

> 脚本路由规则 [4](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#fn_4) 支持 JDK 脚本引擎的所有脚本，比如：javascript, jruby, groovy 等，通过 `type=javascript` 参数设置脚本类型，缺省为 javascript。

> ```
> > "script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("function route(invokers) { ... } (invokers)")
> >
> ```

> 基于脚本引擎的路由规则，如：
>
> ```
> > function route(invokers) {
> >     var result = new java.util.ArrayList(invokers.size());
> >     for (i = 0; i < invokers.size(); i ++) {
> >         if ("10.20.153.10".equals(invokers.get(i).getUrl().getHost())) {
> >             result.add(invokers.get(i));
> >         }
> >     }
> >     return result;
> > } (invokers); // 表示立即执行方法
> >
> ```

###### 3.2.1 构造方法

```
/**
 * 脚本类型 与 ScriptEngine 的映射缓存
 */
private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();

/**
 * 路由规则 URL
 */
private final ScriptEngine engine;
/**
 * 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0 。
 */
private final int priority;
/**
 * 路由规则内容
 */
private final String rule;
/**
 * 路由规则 URL
 */
private final URL url;

public ScriptRouter(URL url) {
    this.url = url;
    String type = url.getParameter(Constants.TYPE_KEY);
    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
    String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
    // 初始化 `engine`
    if (type == null || type.length() == 0) {
        type = Constants.DEFAULT_SCRIPT_TYPE_KEY;
    }
    if (rule == null || rule.length() == 0) {
        throw new IllegalStateException(new IllegalStateException("route rule can not be empty. rule:" + rule));
    }
    ScriptEngine engine = engines.get(type);
    if (engine == null) { // 在缓存中不存在，则进行创建 ScriptEngine 对象
        engine = new ScriptEngineManager().getEngineByName(type);
        if (engine == null) {
            throw new IllegalStateException(new IllegalStateException("Unsupported route rule type: " + type + ", rule: " + rule));
        }
        engines.put(type, engine);
    }
    this.engine = engine;
    this.rule = rule;
}
```

###### 3.2.2 route

```
@Override
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
    try {
        // 执行脚本
        List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);
        Compilable compilable = (Compilable) engine;
        Bindings bindings = engine.createBindings();
        bindings.put("invokers", invokersCopy);
        bindings.put("invocation", invocation);
        bindings.put("context", RpcContext.getContext());
        CompiledScript function = compilable.compile(rule); // 编译
        Object obj = function.eval(bindings); // 执行
        // 根据结果类型，转换成 (List<Invoker<T>> 类型返回
        if (obj instanceof Invoker[]) {
            invokersCopy = Arrays.asList((Invoker<T>[]) obj);
        } else if (obj instanceof Object[]) {
            invokersCopy = new ArrayList<Invoker<T>>();
            for (Object inv : (Object[]) obj) {
                invokersCopy.add((Invoker<T>) inv);
            }
        } else {
            invokersCopy = (List<Invoker<T>>) obj;
        }
        return invokersCopy;
    } catch (ScriptException e) {
        // 发生异常，忽略路由规则，返回全 `invokers` 集合
        logger.error("route error , rule has been ignored. rule: " + rule + ", method:" + invocation.getMethodName() + ", url: " + RpcContext.getContext().getUrl(), e);
        return invokers;
    }
}
```

- 🙂 比较易懂，胖友自己看代码注释。

###### 3.2.3 compareTo

```
@Override
public int compareTo(Router o) {
    if (o == null || o.getClass() != ScriptRouter.class) {
        return 1;
    }
    ScriptRouter c = (ScriptRouter) o;
    return this.priority == c.priority ? rule.compareTo(c.rule) : (this.priority > c.priority ? 1 : -1);
}
```

- 优先，按照 `"priority"` **降序**。
- 其次，按照 `"rule"` **升序**。

#### 3.3 MockInvokersSelector

详细解析，见 [《精尽 Dubbo 源码解析 —— 集群容错（八）之 Mock 实现》](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/?self) 。

## 4. 集成 Router 模块

如下图所示，我们可以看到，有**二个类**，调用 `Router#route(List<Invoker<T>>, URL, Invocation)` 方法，集成 Router 模块。

[![集成](http://static.iocoder.cn/images/Dubbo/2019_04_30/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_30/01.png)集成

#### 4.1 AbstractDirectory

###### 4.1.1 setRouters

`#setRouters(List<Router> routers)` 方法，设置路由规则们。代码如下：

```
 1: protected void setRouters(List<Router> routers) {
 2:     // copy list // 复制 routers ，因为下面要修改
 3:     routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);
 4:     // append url router
 5:     // 拼接 `url` 中，配置的路由规则
 6:     String routerkey = url.getParameter(Constants.ROUTER_KEY);
 7:     if (routerkey != null && routerkey.length() > 0) {
 8:         RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);
 9:         routers.add(routerFactory.getRouter(url));
10:     }
11:     // append mock invoker selector
12:     routers.add(new MockInvokersSelector());
13:     // 排序
14:     Collections.sort(routers);
15:     // 赋值给属性
16:     this.routers = routers;
17: }
```

- 第 3 行：复制重新创建 `routers` 数组，因为下面会进行修改。

- 第 5 至 10 行：添加`url` 中**配置的路由规则**到 `routers` 中。例如：

  ```
  <dubbo:registry id="zk01" address="zookeeper://127.0.0.1:2181">
      <dubbo:parameter key="router" value="file" />
      <dubbo:parameter key="rule" value="/Users/yunai/xxx.js" />
  </dubbo:registry>
  ```

  - 受限于 XML 对字符的限制，`"condition"` 或 `"script"` 类型的路由配置会比较难设置。所以笔者认为，如果是使用 XML 配置路由规则，`"file"` 类型是比较合适的方式。当然，如果使用 Java API 又或者注解的方式，应该不存在这样的问题。

- 第 12 行：添加 **MockInvokersSelector** 到 `routers` 中。

- 第 14 行：排序 `routers` 。

- 第 16 行：**赋值属性**给 AbstractDirectory 。

###### 4.1.2 list

```
 1: @Override
 2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
 3:     if (destroyed) {
 4:         throw new RpcException("Directory already destroyed .url: " + getUrl());
 5:     }
 6:     // 获得所有 Invoker 集合
 7:     List<Invoker<T>> invokers = doList(invocation);
 8:     // 根据路由规则，筛选 Invoker 集合
 9:     List<Router> localRouters = this.routers; // local reference 本地引用，避免并发问题
10:     if (localRouters != null && !localRouters.isEmpty()) {
11:         for (Router router : localRouters) {
12:             try {
13:                 if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14:                     invokers = router.route(invokers, getConsumerUrl(), invocation);
15:                 }
16:             } catch (Throwable t) {
17:                 logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18:             }
19:         }
20:     }
21:     return invokers;
22: }
```

- 第 8 至 20 行：

  循环

  ，调用

   

  ```
  Router#route(invokers, url, invocation)
  ```

   

  方法，不断路由，筛选

  匹配的

   

  Invoker 集合。

  - 第 13 行：判断 `"runtime"` 为 **true** 才执行：是否在每次调用时执行路由规则，**否则只在提供者地址列表变更时预先执行并缓存结果**，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 `true`，需要注意设置会影响调用的性能，可不填，缺省为 `flase`。

#### 4.2 RegistryDirectory

###### 4.2.1 notify

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // 【省略无关代码】根据 URL 的分类或协议，分组成三个集合 。
 4:     List<URL> invokerUrls = new ArrayList<URL>(); // 服务提供者 URL 集合
 5:     List<URL> routerUrls = new ArrayList<URL>();
 6:     List<URL> configuratorUrls = new ArrayList<URL>();
 7:     
 8:     //  【省略无关代码】处理配置规则 URL 集合
 9:     // configurators
10: 
11:     // 处理路由规则 URL 集合
12:     if (!routerUrls.isEmpty()) {
13:         List<Router> routers = toRouters(routerUrls);
14:         if (routers != null) { // null - do nothing
15:             setRouters(routers);
16:         }
17:     }
18:     
19:     //  【省略无关代码】合并配置规则，到 `directoryUrl` 中，形成 `overrideDirectoryUrl` 变量。
20:     //  【省略无关代码】处理服务提供者 URL 集合
21: }
```

- 第 12 行：若注册中心通知的 `routerUrls` 非空，进行处理 `routerUrls` 集合。

- 第 13 行：调用 `#toRouters(routerUrls)` 方法，将路由规则 URL 集合，**转换**成对应的 Router 集合。代码如下：

  ```
  private List<Router> toRouters(List<URL> urls) {
      List<Router> routers = new ArrayList<Router>();
      if (urls == null || urls.isEmpty()) {
          return routers;
      }
      for (URL url : urls) {
          // 忽略，若是 "empty://" 。一般情况下，所有路由规则被删除时，有且仅有一条协议为 "empty://" 的路由规则 URL
          if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
              continue;
          }
          // 获得 "router"
          String routerType = url.getParameter(Constants.ROUTER_KEY);
          if (routerType != null && routerType.length() > 0) {
              url = url.setProtocol(routerType);
          }
          try {
              // 创建 Router 对象
              Router router = routerFactory.getRouter(url);
              // 添加到返回结果
              if (!routers.contains(router)) {
                  routers.add(router);
              }
          } catch (Throwable t) {
              logger.error("convert router url to router error, url: " + url, t);
          }
      }
      return routers;
  }
  ```

  - 代码易懂，胖友看下注释理解。

- 第 14 至 16 行：`routers` 集合非 **null**( 允许集合大小为 **0** )，调用 `#setRouters(routers)` 方法，设置路由规则集合，即 [「4.1.1 setRouters」](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) 。

###### 4.2.2 toMethodInvokers

```
 1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
 2:     // 创建新的 `methodInvokerMap`
 3:     Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
 4:     // 创建 Invoker 集合
 5:     List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
 6:     //  【省略无关代码】按服务提供者 URL 所声明的 methods 分类，兼容注册中心执行路由过滤掉的 methods
 7:     // 路由全 `invokersList` ，匹配合适的 Invoker 集合
 8:     List<Invoker<T>> newInvokersList = route(invokersList, null);
 9:     // 添加 `newInvokersList` 到 `newMethodInvokerMap` 中，表示该服务提供者的全量 Invoker 集合
10:     newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
11:     // 循环，基于每个方法路由，匹配合适的 Invoker 集合
12:     if (serviceMethods != null && serviceMethods.length > 0) {
13:         for (String method : serviceMethods) {
14:             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
15:             if (methodInvokers == null || methodInvokers.isEmpty()) {
16:                 methodInvokers = newInvokersList;
17:             }
18:             newMethodInvokerMap.put(method, route(methodInvokers, method));
19:         }
20:     }
21:     // 【省略无关代码】循环排序每个方法的 Invoker 集合，并设置为不可变
22: }
```

- 第 8 行：调用 `#route(invokers, method)` 方法，路由**全** `invokersList` ，匹配合适的 Invoker 集合**进行缓存**，这就是上文提到的“*只在提供者地址列表变更时预先执行并缓存结果*”。代码如下：

  ```
  private List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {
      // 创建 Invocation 对象
      Invocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
      // 获得 Router 数组
      List<Router> routers = getRouters();
      // 根据路由规则，筛选 Invoker 集合
      if (routers != null) {
          for (Router router : routers) {
              if (router.getUrl() != null) {
                  invokers = router.route(invokers, getConsumerUrl(), invocation);
              }
          }
      }
      return invokers;
  }
  ```

  - 主要是调用 `Router#route(...)` 方法，路由。

- 第 11 至 20 行：**循环**，调用 `#route(invokers, method)` 方法，路由**每个方法**的 `methodInvokers` ，匹配合适的 Invoker 集合**进行缓存**。

# 8、Mock 实现

## 1. 概述

本文接 [《精尽 Dubbo 源码解析 —— 集群容错（七）之 Router 实现》](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) 一文，分享 `dubbo-cluster` 模块， `mock` 包，实现 Dubbo 如下功能：

- **本地伪装**：通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。
- **服务降级**：可以通过服务降级功能，临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。

> 老艿艿：如果不熟悉的胖友，推荐结合着 [《Dubbo 用户指南 —— 本地伪装》](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) 和 [《Dubbo 用户指南 —— 服务降级》](http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html) 一起学习。

- **注意**，[《Dubbo 用户指南 —— 本地伪装》](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) 的文档有点问题：Spring XML 是通过 `<dubbo:reference />` 配置，而不是 `<dubbo:service />` 。

本文涉及类如下图：

[![Mock 相关类](http://static.iocoder.cn/images/Dubbo/2019_05_05/01.png)](http://static.iocoder.cn/images/Dubbo/2019_05_05/01.png)Mock 相关类

- 分成两个部分：
  - MockClusterWrapper + MockClusterInvoker + MockClusterSelector
  - MockProtocol + MockInvoker

## 2. MockClusterWrapper

`com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper` ，实现 Cluster 接口，Mock Cluster **Wrapper** 实现类。代码如下：

```
public class MockClusterWrapper implements Cluster {

    /**
     * 真正的 Cluster 对象
     */
    private Cluster cluster;

    public MockClusterWrapper(Cluster cluster) {
        this.cluster = cluster;
    }

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new MockClusterInvoker<T>(directory, // <2>
                this.cluster.join(directory)); // <1>
    }

}
```

- `cluster` 字段，**真正**的 Cluster 对象。因为 MockClusterWrapper 是 Dubbo SPI Wrapper 类，**所以对应的 Cluster 对象，都会被它所包装**。不理解的胖友，可以看下 [《精尽 Dubbo 源码分析 —— 拓展机制 SPI》](http://svip.iocoder.cn/Dubbo/spi/?self) 的 [「4.4.2 createExtension」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 的【第 24 至 30 行】。
- `<1>` 处：调用 `Cluster#join(directory)` 方法，创建**真正**的 Cluster Invoker 对象。
- `<2>` 处：创建 MockClusterInvoker 对象。详细解析，见 [「3. MockClusterInvoker」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

## 3. MockClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker` ，实现 Invoker 接口，**MockClusterWrapper** 对应的 Invoker 实现类。

#### 3.1 构造方法

```
private final Directory<T> directory;
/**
 * 真正的 Invoker 对象
 */
private final Invoker<T> invoker;

public MockClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
    this.directory = directory;
    this.invoker = invoker;
}
```

#### 3.2 invoke

```
 1: @Override
 2: public Result invoke(Invocation invocation) throws RpcException {
 3:     Result result;
 4:     // 获得 "mock" 配置项，有多种配置方式
 5:     String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
 6:     //【第一种】无 mock
 7:     if (value.length() == 0 || value.equalsIgnoreCase("false")) {
 8:         // no mock
 9:         // 调用原 Invoker ，发起 RPC 调用
10:         result = this.invoker.invoke(invocation);
11:     //【第二种】强制服务降级 http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html
12:     } else if (value.startsWith("force")) {
13:         if (logger.isWarnEnabled()) {
14:             logger.info("force-mock: " + invocation.getMethodName() + " force-mock enabled , url : " + directory.getUrl());
15:         }
16:         // force:direct mock
17:         // 直接调用 Mock Invoker ，执行本地 Mock 逻辑
18:         result = doMockInvoke(invocation, null);
19:     // 【第三种】失败服务降级 http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html
20:     } else {
21:         // fail-mock
22:         try {
23:             // 调用原 Invoker ，发起 RPC 调用
24:             result = this.invoker.invoke(invocation);
25:         } catch (RpcException e) {
26:             // 业务性异常，直接抛出
27:             if (e.isBiz()) {
28:                 throw e;
29:             } else {
30:                 if (logger.isWarnEnabled()) {
31:                     logger.info("fail-mock: " + invocation.getMethodName() + " fail-mock enabled , url : " + directory.getUrl(), e);
32:                 }
33:                 // 失败后，调用 Mock Invoker ，执行本地 Mock 逻辑
34:                 result = doMockInvoke(invocation, e);
35:             }
36:         }
37:     }
38:     return result;
39: }
```

- 第 5 行：获得 `"mock"` 配置项。根据不同的配置，分成**三种**情况。

- ========== 第一种：**无 Mock** ==========

- 第 10 行：只调用**真正的** `invoker` 的 `#invoke(invocation)` 方法，发起 RPC 调用，**即不进行 Mock 逻辑**。

- ========== 第二种：**强制服务降级** ==========

- 第 12 行：`"mock"` 配置项以 `"force"` **开头**，**强制**服务降级，即 [《Dubbo 用户指南 —— 服务降级》](http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html) 。

- 第 18 行：**直接**调用 `#doMockInvoke(invocation, null)` 方法，调用 **Mock Invoker** ，执行本地 Mock 逻辑。详细解析，见 [「3.3 doMockInvoke」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

- ========== 第三种：**失败服务降级** ==========

- 第 24 行：**优先**，调用**真正的** `invoker` 的 `#invoke(invocation)` 方法，发起 RPC 调用，**即不进行 Mock 逻辑**。

- 第 25 至 36 行：处理 RpcException 异常。

  也仅仅处理这种类型的异常

  。

  - 第 26 至 28 行：若发生**业务性**异常，直接抛出异常。
  - 第 29 至 35 行：**失败后**，调用 `#doMockInvoke(invocation, null)` 方法，调用 **Mock Invoker** ，执行本地 Mock 逻辑。详细解析，见 [「3.3 doMockInvoke」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

😈 总的来说，MockClusterInvoker 的 `#invoke(Invocation)` 方法的过程，根据不同的 `"mock"` 配置，“组合”调用**真正的**和 **Mock** 的 Invoker 。

#### 3.3 doMockInvoke

```
 1: private Result doMockInvoke(Invocation invocation, RpcException e) {
 2:     Result result;
 3:     // 第一步，获得 Mock Invoker 对象
 4:     Invoker<T> mInvoker;
 5:     // 路由匹配 Mock Invoker 集合
 6:     List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
 7:     // 如果不存在，创建 MockInvoker 对象
 8:     if (mockInvokers == null || mockInvokers.isEmpty()) {
 9:         mInvoker = (Invoker<T>) new MockInvoker(directory.getUrl());
10:     // 如果存在，选择第一个
11:     } else {
12:         mInvoker = mockInvokers.get(0);
13:     }
14:     // 第二步，调用，执行本地 Mock 逻辑
15:     try {
16:         result = mInvoker.invoke(invocation);
17:     } catch (RpcException me) {
18:         if (me.isBiz()) {
19:             result = new RpcResult(me.getCause());
20:         } else {
21:             throw new RpcException(me.getCode(), getMockExceptionMessage(e, me), me.getCause());
22:         }
23:     } catch (Throwable me) {
24:         throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
25:     }
26:     return result;
27: }
```

- 第 3 至 13 行：

  第一步

  ，获得

   

  MockInvoker

   

  对象。

  - 第 6 行：调用 `#selectMockInvoker(invocation)` 方法，**路由匹配** Mock Invoker 集合。详细解析，见 [「3.4 selectMockInvoker」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。
  - 第 7 至 9 行：若**不**存在，**创建** MockInvoker 对象。
  - 第 10 至 13 行：若**已**不能再，**选择**第一个 Mock Invoker 对象。

- 第 14 至 16 行：调用 `MockInvoker#invoke(invocation)` 方法，执行本地 Mock 逻辑。

- 第 17 至 25 行：处理**异常**。

#### 3.4 selectMockInvoker

```
 1: private List<Invoker<T>> selectMockInvoker(Invocation invocation) {
 2:     List<Invoker<T>> invokers = null;
 3:     if (invocation instanceof RpcInvocation) {
 4:         // 存在隐含契约(虽然在接口声明中增加描述，但扩展性会存在问题.同时放在 attachment 中的做法需要改进
 5:         ((RpcInvocation) invocation).setAttachment(Constants.INVOCATION_NEED_MOCK, Boolean.TRUE.toString());
 6:         // directory 根据 invocation 中 attachment 是否有 Constants.INVOCATION_NEED_MOCK，来判断获取的是 normal invokers or mock invokers
 7:         try {
 8:             invokers = directory.list(invocation);
 9:         } catch (RpcException e) {
10:             if (logger.isInfoEnabled()) {
11:                 logger.info("Exception when try to invoke mock. Get mock invokers error for service:" + directory.getUrl().getServiceInterface() + ", method:" + invocation.getMethodName() + ", will contruct a new mock with 'new MockInvoker()'.", e);
12:             }
13:         }
14:     }
15:     return invokers;
16: }
```

- 第 5 行：设置 RpcInvocation 的 `"invocation.need.mock"` 为 **true** 。
- 第 8 行：调用 `Directory#list(invocation)` 方法，获得**所有** Invoker 集合。因为【第 5 行】设置了 `"invocation.need.mock"` 为 **true** ，所以实际获得的是 MockInvoker 集合。详细解析，见 [「3.4.1 MockInvokersSelector」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

###### 3.4.1 MockInvokersSelector

`com.alibaba.dubbo.rpc.cluster.router.MockInvokersSelector` ，实现 Router 接口，MockInvoker 路由**选择器**实现类。

因为 AbstractDirectory 的 `#setRouters(List<Router> routers)` 方法中，都会添加 **MockInvokersSelector** ，如下图所示：[![setRouters](http://static.iocoder.cn/images/Dubbo/2019_05_05/02.png)](http://static.iocoder.cn/images/Dubbo/2019_05_05/02.png)setRouters

- 所以，每次 `Directory#list(invocation)` 的过程中，都会执行 MockInvokersSelector 的路由逻辑。

------

`#route(List<Invoker<T>> invokers, URL url, Invocation invocation)` 方法，根据 `"invocation.need.mock"` 路由匹配**对应类型**的 Invoker 集合：

- 1、若为 **true** ，**Mock**Invoker 集合。
- 2、若为 **false** ，**普通** Invoker 集合。

代码如下：

```
 1: @Override
 2: public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers, URL url, final Invocation invocation) throws RpcException {
 3:     // 获得普通 Invoker 集合
 4:     if (invocation.getAttachments() == null) {
 5:         return getNormalInvokers(invokers);
 6:     } else {
 7:         // 获得 "invocation.need.mock" 配置项
 8:         String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);
 9:         // 获得普通 Invoker 集合
10:         if (value == null) {
11:             return getNormalInvokers(invokers);
12:         // 获得 MockInvoker 集合
13:         } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {
14:             return getMockedInvokers(invokers);
15:         }
16:     }
17:     // 其它，不匹配，直接返回 `invokers` 集合
18:     return invokers;
19: }
```

- 分成**三种**情况，我们一个一个来看。在看具体情况之前，我们先来看 `#hasMockProviders(invokers)` 方法，判断是否有 MockInvoker 。代码如下：

  ```
  private <T> boolean hasMockProviders(final List<Invoker<T>> invokers) {
      boolean hasMockProvider = false;
      for (Invoker<T> invoker : invokers) {
          if (invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) { // 协议为 "mock"
              hasMockProvider = true;
              break;
          }
      }
      return hasMockProvider;
  }
  ```

  - 通过 `protocol = "mock"` 来判断，是否为 **Mock**Invoker 。所以只要**不为** MockInvoker ，就是**普通** Invoker 。关于 `"mock"` 协议，我们稍后在 [「4. MockProtocol」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 中，详细解析。

- 【第**一**种】第 3 至 5 行 || 第 9 至 11 行：若**未设置** `"invocation.need.mock"` 配置项，调用 `#getNormalInvokers(invokers)` 方法，获得**普通** Invoker 集合。代码如下：

  ```
   1: private <T> List<Invoker<T>> getNormalInvokers(final List<Invoker<T>> invokers) {
   2:     // 不包含 MockInvoker 的情况下，直接返回 `invokers` 集合
   3:     if (!hasMockProviders(invokers)) {
   4:         return invokers;
   5:     } else {
   6:         // 若包含 MockInvoker 的情况下，过滤掉 MockInvoker ，创建普通 Invoker 集合
   7:         List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(invokers.size());
   8:         for (Invoker<T> invoker : invokers) {
   9:             if (!invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) {
  10:                 sInvokers.add(invoker);
  11:             }
  12:         }
  13:         return sInvokers;
  14:     }
  15: }
  ```

  - 第 2 至 4 行：调用 `#hasMockProviders(invokers)` 方法，判断**不包含** MockInvoker 的情况，直接返回 `invokers` 集合。
  - 第 6 至 13 行：若**包含** MockInvoker 的情况，**过滤**掉 MockInvoker ，创建**普通** Invoker 集合。

- 【第**二**种】第 12 至 15 行：若设置 `"invocation.need.mock"` 配置项为 **true** ，调用 `#getMockedInvokers(invokers)` 方法，获得 **Mock**Invoker 集合。代码如下：

  ```
  private <T> List<Invoker<T>> getMockedInvokers(final List<Invoker<T>> invokers) {
      // 不包含 MockInvoker 的情况下，直接返回 null
      if (!hasMockProviders(invokers)) {
          return null;
      }
      // 过滤掉普通 kInvoker ，创建 MockInvoker 集合
      List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(1); // 一般情况就一个，所以设置了默认数组大小为 1 。
      for (Invoker<T> invoker : invokers) {
          if (invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) {
              sInvokers.add(invoker);
          }
      }
      return sInvokers;
  }
  ```

  - 和 `#getNormalInvokers(invokers)` 方法，**相反**。比较易懂，胖友看代码注释。

- 【第**三**种】第 18 行：其它，**不匹配**，直接返回 `invokers` 集合。理论上，应该调用和【第**一**种】一样，调用 `#getNormalInvokers(invokers)` 方法。不过没关系，😈 从目前代码来看，这块是走不到的。

## 4. MockProtocol

`com.alibaba.dubbo.rpc.support.MockProtocol` ，实现 AbstractProtocol 抽象类，用于在服务**消费者**，通过类型为 `"mock"` 的 URL ，引用创建 MockInvoker 对象。代码如下：

```
public final class MockProtocol extends AbstractProtocol {

    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        throw new UnsupportedOperationException();
    }

    @Override
    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        return new MockInvoker<T>(url);
    }

    @Override
    public int getDefaultPort() {
        return 0;
    }

}
```

- `#export(Invoker)` **实现**方法，不允许调用，直接抛出 UnsupportedOperationException 异常。

- `#refer(Class<T> type, Url)` **实现**方法，引用创建 **MockInvoker** 对象。一般情况下，我们可以通过 `dubbo-admin` **运维平台**或者直接向 Zookeeper 写入**静态** URL ，例如：

  ```
  // 实际写入的 URL
  /dubbo/com.alibaba.dubbo.demo.DemoService/providers/mock%3A%2F%2F10.20.153.11%2Fcom.alibaba.dubbo.demo.DemoService%3Fdynamic%3Dtrue%26application%3Dfoo
  
  // decode URL
  /dubbo/com.alibaba.dubbo.demo.DemoService/providers/mock://10.20.153.11/com.alibaba.dubbo.demo.DemoService?dynamic=true&application=foo
  ```

  - 为什么要是**静态** URL 呢？因为非静态 URL ，可能被注册中心删除。

😈 当然，我们在 [「3.3 doMockInvoke」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 中也看到，即使不**手动**添加 `"mock"` URL ，在【第 9 行】代码中也会**自动**创建 MockInvoker 对象。

## 5. MockInvoker

`com.alibaba.dubbo.rpc.support.MockInvoker` ，实现 Invoker 接口，**Mock** Invoker 实现类。

#### 5.1 构造方法

```
/**
 * ProxyFactory$Adaptive 对象
 */
private final static ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();

/**
 * mock 与 Invoker 对象的映射缓存
 *
 * @see #getInvoker(String)
 */
private final static Map<String, Invoker<?>> mocks = new ConcurrentHashMap<String, Invoker<?>>();
/**
 * mock 与 Throwable 对象的映射缓存
 *
 * @see #getThrowable(String)
 */
private final static Map<String, Throwable> throwables = new ConcurrentHashMap<String, Throwable>();

/**
 * URL 对象
 */
private final URL url;

public MockInvoker(URL url) {
    this.url = url;
}
```

#### 5.2 invoke

`#invoke(Invocation)` **实现**方法，执行 Mock 逻辑。代码如下：

```
 1: @Override
 2: public Result invoke(Invocation invocation) throws RpcException {
 3:     if (invocation instanceof RpcInvocation) {
 4:         ((RpcInvocation) invocation).setInvoker(this);
 5:     }
 6:     // 获得 `"mock"` 配置项，方法级 > 类级
 7:     String mock = getUrl().getParameter(invocation.getMethodName() + "." + Constants.MOCK_KEY);
 8:     if (StringUtils.isBlank(mock)) {
 9:         mock = getUrl().getParameter(Constants.MOCK_KEY);
10:     }
11:     if (StringUtils.isBlank(mock)) { // 不允许为空
12:         throw new RpcException(new IllegalAccessException("mock can not be null. url :" + url));
13:     }
14:     // 标准化 `"mock"` 配置项
15:     mock = normalizedMock(URL.decode(mock));
16:     // 等于 "return " ，返回值为空的 RpcResult 对象
17:     if (Constants.RETURN_PREFIX.trim().equalsIgnoreCase(mock.trim())) {
18:         RpcResult result = new RpcResult();
19:         result.setValue(null);
20:         return result;
21:     // 以 "return " 开头，返回对应值的 RpcResult 对象
22:     } else if (mock.startsWith(Constants.RETURN_PREFIX)) {
23:         mock = mock.substring(Constants.RETURN_PREFIX.length()).trim();
24:         mock = mock.replace('`', '"');
25:         try {
26:             // 解析返回类型
27:             Type[] returnTypes = RpcUtils.getReturnTypes(invocation);
28:             // 解析返回值
29:             Object value = parseMockValue(mock, returnTypes);
30:             // 创建对应值的 RpcResult 对象，并返回
31:             return new RpcResult(value);
32:         } catch (Exception ew) {
33:             throw new RpcException("mock return invoke error. method :" + invocation.getMethodName() + ", mock:" + mock + ", url: " + url, ew);
34:         }
35:     // 以 "throw" 开头，抛出 RpcException 异常
36:     } else if (mock.startsWith(Constants.THROW_PREFIX)) {
37:         mock = mock.substring(Constants.THROW_PREFIX.length()).trim();
38:         mock = mock.replace('`', '"');
39:         if (StringUtils.isBlank(mock)) { // 禁止为空
40:             throw new RpcException(" mocked exception for Service degradation. ");
41:         } else { // user customized class
42:             // 创建自定义异常
43:             Throwable t = getThrowable(mock);
44:             // 抛出业务类型的 RpcException 异常
45:             throw new RpcException(RpcException.BIZ_EXCEPTION, t);
46:         }
47:     // 自定义 Mock 类，执行自定义逻辑
48:     } else {
49:         try {
50:             // 创建 Invoker 对象
51:             Invoker<T> invoker = getInvoker(mock);
52:             // 执行 Invoker 对象的调用逻辑
53:             return invoker.invoke(invocation);
54:         } catch (Throwable t) {
55:             throw new RpcException("Failed to create mock implemention class " + mock, t);
56:         }
57:     }
58: }
```

- 第 6 至 13 行：获得 `"mock"` 配置项，优先从**方法级**的参数，再从**类级**的参数。

- 第 15 行：调用 `#normalizedMock(mock)` 方法，标准化 `"mock"` 配置项。详细解析，见 [「5.3 normalizedMock」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

- 下面根据 `mock` ，分成**三种**情况。

- 【第 **1.1** 种】第 16 至 20 行：等于 `"return "` ，返回值为**空** 的 RpcResult 对象。

- 【第

   

  1.2

   

  种】第 21 至 34 行：以

   

  ```
  "return"
  ```

   

  开头，返回

  对应值

   

  的 RpcResult 对象。

  - 第29 行：调用 `#parseMockValue(mock, returnTypes)` 方法，解析**返回值**。详细解析，见 [「5.4 parseMockValue」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

- 【第

   

  2

   

  种】第 35 至 46 行：以

   

  ```
  "throw"
  ```

   

  开头，抛出

  对应的

   

  RpcException 异常。

  - 第 43 行：调用 `#getThrowable(mock)` 对象，创建**自定义**异常。详细解析，见 [「5.5 getThrowable」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。

- 【第

   

  3

   

  种】第 47 至 57 行：

  自定义

   

  Mock 类，执行自定义逻辑。

  - 第 51 行：调用 `#getInvoker(mock)` 方法，获得 Invoker 对象。详细解析，见 [「5.6 getInvoker」](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) 。
  - 第 53 行：调用 `Invoker#invoke(invocation)` 方法，执行**自定义** Mock 逻辑。

#### 5.3 normalizedMock

```
 1: private String normalizedMock(String mock) {
 2:     // 若为空，直接返回
 3:     if (mock == null || mock.trim().length() == 0) {
 4:         return mock;
 5:     // 若果为 "true" "default" "fail" "force" 四种字符串，修改为对应接口 + "Mock" 类
 6:     } else if (ConfigUtils.isDefault(mock) || "fail".equalsIgnoreCase(mock.trim()) || "force".equalsIgnoreCase(mock.trim())) {
 7:         mock = url.getServiceInterface() + "Mock";
 8:     }
 9:     // 若以 "fail:" 开头，去掉该开头
10:     if (mock.startsWith(Constants.FAIL_PREFIX)) {
11:         mock = mock.substring(Constants.FAIL_PREFIX.length()).trim();
12:     // 若以 "force:" 开头，去掉该开头
13:     } else if (mock.startsWith(Constants.FORCE_PREFIX)) {
14:         mock = mock.substring(Constants.FORCE_PREFIX.length()).trim();
15:     }
16:     return mock;
17: }
```

- 【第**一**种】第 2 至 4 行：若为**空**，直接返回。
- 【第**二**种】第 5 至 8 行：若为 **`true` `default` `fail` `force`** ，修改为对应接口 + `"Mock"` 。
- 【第**三**种】第 9 至 15 行：若以 `"fail:"` 或 `"force:"` **开头** ，去掉**开头**。该开头，仅用于 MockClusterInvoker 表示**强制** Mock 还是**失败** Mock 。

#### 5.4 parseMockValue

```
public static Object parseMockValue(String mock) {
    return parseMockValue(mock, null);
}

public static Object parseMockValue(String mock, Type[] returnTypes) {
    // 解析值（不考虑返回类型）
    Object value;
    if ("empty".equals(mock)) { // 未赋值的对象，即 new XXX() 对象
        value = ReflectUtils.getEmptyObject(returnTypes != null && returnTypes.length > 0 ? (Class<?>) returnTypes[0] : null);
    } else if ("null".equals(mock)) { // null
        value = null;
    } else if ("true".equals(mock)) { // true
        value = true;
    } else if ("false".equals(mock)) { // false
        value = false;
    } else if (mock.length() >= 2 && (mock.startsWith("\"") && mock.endsWith("\"")
            || mock.startsWith("\'") && mock.endsWith("\'"))) { // 使用 '' 或 "" 的字符串，截取掉头尾
        value = mock.subSequence(1, mock.length() - 1);
    } else if (returnTypes != null && returnTypes.length > 0 && returnTypes[0] == String.class) { // 字符串
        value = mock;
    } else if (StringUtils.isNumeric(mock)) { // 数字
        value = JSON.parse(mock);
    } else if (mock.startsWith("{")) { // Map
        value = JSON.parseObject(mock, Map.class);
    } else if (mock.startsWith("[")) { // List
        value = JSON.parseObject(mock, List.class);
    } else {
        value = mock;
    }
    // 转换成对应的返回类型
    if (returnTypes != null && returnTypes.length > 0) {
        value = PojoUtils.realize(value, (Class<?>) returnTypes[0], returnTypes.length > 1 ? returnTypes[1] /* 泛型 */: null);
    }
    return value;
}
```

- 解析**值**，并**转换**成对应的返回**类型**。

#### 5.5 getThrowable

```
private Throwable getThrowable(String throwStr) {
    // 从缓存中，获得 Throwable 对象
    Throwable throwable = throwables.get(throwStr);
    if (throwable != null) {
        return throwable;
    }
    // 不存在，创建 Throwable 对象
    Throwable t;
    try {
        // 获得异常类
        Class<?> bizException = ReflectUtils.forName(throwStr);
        // 获得构造方法
        Constructor<?> constructor = ReflectUtils.findConstructor(bizException, String.class);
        // 创建 Throwable 对象
        t = (Throwable) constructor.newInstance(new Object[]{" mocked exception for Service degradation. "});
        // 添加到缓存中
        if (throwables.size() < 1000) {
            throwables.put(throwStr, t);
        }
    } catch (Exception e) {
        throw new RpcException("mock throw error :" + throwStr + " argument error.", e);
    }
    return t;
}
```

- 代码比较易懂，胖友看代码注释。

#### 5.6 getInvoker

```
private Invoker<T> getInvoker(String mockService) {
    // 从缓存中，获得 Invoker 对象
    Invoker<T> invoker = (Invoker<T>) mocks.get(mockService);
    if (invoker != null) {
        return invoker;
    }
    // 不存在，创建 Invoker 对象
    // 1. 获得接口类
    Class<T> serviceType = (Class<T>) ReflectUtils.forName(url.getServiceInterface());
    // 2. 若为 `true` `default` ，修改修改为对应接口 + "Mock" 类。这种情况出现在原始 `mock = fail:true` 或 `mock = force:true` 等情况
    if (ConfigUtils.isDefault(mockService)) {
        mockService = serviceType.getName() + "Mock";
    }
    // 3. 获得 Mock 类
    Class<?> mockClass = ReflectUtils.forName(mockService);
    // 4. 校验 Mock 类，实现了接口类
    if (!serviceType.isAssignableFrom(mockClass)) {
        throw new IllegalArgumentException("The mock implemention class " + mockClass.getName() + " not implement interface " + serviceType.getName());
    }
    try {
        // 5. 创建 Mock 对象
        T mockObject = (T) mockClass.newInstance();
        // 6. 创建 Mock 对应，对应的 Invoker 对象
        invoker = proxyFactory.getInvoker(mockObject, serviceType, url);
        // 7. 添加到缓存
        if (mocks.size() < 10000) {
            mocks.put(mockService, invoker);
        }
        return invoker;
    } catch (InstantiationException e) {
        throw new IllegalStateException("No such empty constructor \"public " + mockClass.getSimpleName() + "()\" in mock implemention class " + mockClass.getName(), e);
    } catch (IllegalAccessException e) {
        throw new IllegalStateException(e);
    }
}
```

- 代码比较易懂，胖友看代码注释。

## 6. AbstractInterfaceConfig

`#checkStubAndMock(Class<?> interfaceClass)` 方法，校验 Stub 和 **Mock 相关的配置**。代码如下：

```
protected void checkStubAndMock(Class<?> interfaceClass) {
    // 【省略代码】`local` 配置项的校验，和 `stub` 一样。
    // 【省略代码】`stub` 配置项的校验

    // mock 配置校验
    if (ConfigUtils.isNotEmpty(mock)) {
        if (mock.startsWith(Constants.RETURN_PREFIX)) { // 处理 "return " 开头的情况
            String value = mock.substring(Constants.RETURN_PREFIX.length());
            // 校验 Mock 值，配置正确
            try {
                MockInvoker.parseMockValue(value);
            } catch (Exception e) {
                throw new IllegalStateException("Illegal mock json value in <dubbo:service ... mock=\"" + mock + "\" />");
            }
        } else {
            // 获得 Mock 类
            Class<?> mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + "Mock") : ReflectUtils.forName(mock);
            // 校验是否实现接口类
            if (!interfaceClass.isAssignableFrom(mockClass)) {
                throw new IllegalStateException("The mock implementation class " + mockClass.getName() + " not implement interface " + interfaceClass.getName());
            }
            // 校验是否有默认构造方法
            try {
                mockClass.getConstructor();
            } catch (NoSuchMethodException e) {
                throw new IllegalStateException("No such empty constructor \"public " + mockClass.getSimpleName() + "()\" in mock implementation class " + mockClass.getName());
            }
        }
    }
}
```

- 代码比较易懂，胖友看代码注释。

- 从 Mock 配置校验的逻辑我们可以看出，不允许配置

   

  ```
  "force:"
  ```

   

  和

   

  ```
  "fail:"
  ```

   

  为开头。😈 所以，

  不能通过

   

  Java API 或者 XML ，又或者注解来配置 Mock 规则，只能通过

  配置规则

  来开启

  服务降级

  。具体的配置方式，参见

   

  《Dubbo 用户指南 —— 服务降级》

  。

  - 同样，也不允许配置 `"throws "` 开头。