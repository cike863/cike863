# 1ã€æŠ½è±¡ API

## 1. æ¦‚è¿°

ä»æœ¬æ–‡å¼€å§‹ï¼Œæˆ‘ä»¬æ¥åˆ†äº« Dubbo çš„**é›†ç¾¤å®¹é”™**åŠŸèƒ½çš„å®ç°ã€‚

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” é¡¹ç›®ç»“æ„ä¸€è§ˆã€‹](http://svip.iocoder.cn/Dubbo/intro/?self) çš„ [ã€Œ3.4 dubbo-clusterã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) ä¸­ï¼Œæˆ‘ä»¬å¯¹ Dubbo çš„ `dubbo-cluster` é¡¹ç›®ï¼Œåšäº†æ•´ä½“çš„ä»£ç ç»“æ„åšäº†ä»‹ç»ã€‚å¦‚æœå·²ç»æ²¡ä»€ä¹ˆå°è±¡çš„èƒ–å‹ï¼Œè¯·å…ˆå›è¿‡å¤´æ‰¾å›å¤±æ•£çš„è®°å¿†ã€‚

Dubbo å¯¹é›†ç¾¤å®¹é”™åŠŸèƒ½ï¼Œå®ç°äº†å¾ˆå¥½çš„ `package` æ‹†åˆ†ï¼Œå› æ­¤æˆ‘ä»¬æŒ‰ç…§å¦‚ä¸‹é¡ºåºï¼š

1. æŠ½è±¡ API

- Cluster å®ç°
- Directory å®ç°
- LoadBalance å®ç°
- Merger å®ç°
- Router å®ç°
- Configurator å®ç°

**ä¸€ä¸ªä¸»é¢˜ï¼Œå¯¹åº”ä¸€ç¯‡æ–‡ç« **ã€‚é‚£ä¹ˆï¼Œæœ¬æ–‡å½“ç„¶æ˜¯åˆ†äº«**æŠ½è±¡ API**ã€‚è€ƒè™‘åˆ°å¹²å·´å·´çš„çœ‹æŠ½è±¡ API ä¼šå¾ˆå®¹æ˜“ä¸€è„¸æ‡µé€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šä½¿ç”¨ **FailoverCluster** è´¯ç©¿æœ¬æ–‡ã€‚

## 2. æ•´ä½“æµç¨‹

> [![é›†ç¾¤å®¹é”™](http://static.iocoder.cn/images/Dubbo/2018_01_04/09.png)](http://static.iocoder.cn/images/Dubbo/2018_01_04/09.png)é›†ç¾¤å®¹é”™

- ğŸ™‚ åªçœ‹çº¢çº¿ã€‚

- å·¦è¾¹ invoke

   

  ï¼šé€šè¿‡ Cluster æš´éœ²

   

  Invoker

   

  å¯¹è±¡ï¼Œä»è€Œå®ç°

  ç»Ÿä¸€

  ã€

  é€æ˜

  çš„è°ƒç”¨è¿‡ç¨‹ã€‚

  - æ— æ³•ç†è§£ï¼Ÿè¯¦ç»†è§£æï¼Œè§ [ã€Œ3. Clusterã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) ã€‚

- **å³è¾¹ list** ï¼šé€šè¿‡ Directory ä¸­ï¼Œ**è·å–**å¯è°ƒç”¨çš„ Invoker é›†åˆã€‚

- **å³è¾¹ route** ï¼šé€šè¿‡ Router ï¼Œ**è¿‡æ»¤**ç¬¦åˆ**è·¯ç”±è§„åˆ™**çš„ Invoker é›†åˆã€‚

- **å³è¾¹ select** ï¼šé€šè¿‡ LoadBalance ï¼Œæ ¹æ®**è´Ÿè½½å‡è¡¡æœºåˆ¶**ï¼Œ**é€‰æ‹©**ä¸€ä¸ªç¬¦åˆçš„ Invoker å¯¹è±¡ã€‚

- **å³è¾¹ invoke** ï¼šè°ƒç”¨è¯¥ Invoker å¯¹è±¡ã€‚

## 3. Cluster

`com.alibaba.dubbo.rpc.cluster.Cluster` ï¼Œé›†ç¾¤æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@SPI(FailoverCluster.NAME)
public interface Cluster {

    /**
     * Merge the directory invokers to a virtual invoker.
     *
     * åŸºäº Directory ï¼Œåˆ›å»º Invoker å¯¹è±¡ï¼Œå®ç°ç»Ÿä¸€ã€é€æ˜çš„ Invoker è°ƒç”¨è¿‡ç¨‹
     *
     * @param directory Directory å¯¹è±¡
     * @param <T>  æ³›å‹
     * @return cluster invoker
     * @throws RpcException
     */
    @Adaptive
    <T> Invoker<T> join(Directory<T> directory) throws RpcException;

}
```

- `@SPI(FailoverCluster.NAME)` æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œé»˜è®¤ä¸º `"failover"` ï¼Œå³**å¤±è´¥é‡è¯•**ï¼Œä¹Ÿå°±æ˜¯ä¼šè´¯ç©¿æœ¬æ–‡çš„ FailoverCluster ç±»ã€‚
- `@Adaptive` æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Cluster å®ç°ï¼Œä½¿ç”¨ `URL.cluster` å±æ€§ã€‚
- `#join(Directory<T>)` æ¥å£æ–¹æ³•ï¼ŒåŸºäº Directory ï¼Œåˆ›å»º Invoker å¯¹è±¡ï¼Œå®ç°ç»Ÿä¸€ã€é€æ˜çš„ Invoker è°ƒç”¨è¿‡ç¨‹ã€‚

#### 3.1 join æ–¹æ³•

åœ¨ RegistryProtocol çš„ `#doRefer(Cluster, Registry, type, url)` æ–¹æ³•ä¸­ï¼Œä¼šè°ƒç”¨ `Cluster#join(directory)` æ–¹æ³•ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private Cluster cluster; // <1>

private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
    // åˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶è®¾ç½®æ³¨å†Œä¸­å¿ƒ <2>
    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
    directory.setRegistry(registry);
    directory.setProtocol(protocol);
    
    // ... çœç•¥æ— å…³ä»£ç 

    // åˆ›å»º Invoker å¯¹è±¡ <3>
    Invoker invoker = cluster.join(directory);
    // å‘æœ¬åœ°æ³¨å†Œè¡¨ï¼Œæ³¨å†Œæ¶ˆè´¹è€…
    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
    return invoker;
}
```

- `<1>` ï¼š`cluster` å±æ€§ï¼Œ`Cluster$Adaptive` å¯¹è±¡
- `<2>` ï¼šåˆ›å»º RegistryDirectory å¯¹è±¡ã€‚é€šè¿‡å®ƒï¼Œå¯ä»¥æ³¨å†Œåˆ°**ä¸€ä¸ª**æ³¨å†Œä¸­å¿ƒçš„æ‰€æœ‰æœåŠ¡**æä¾›è€…**ï¼Œå³ä¸Šæ–‡æåˆ°çš„ã€å³è¾¹ listã€‘ã€‚
- `<3>` ï¼šè°ƒç”¨ `Cluster#join(directory)` æ–¹æ³•ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚å› ä¸º `cluster` æ˜¯ Dubbo SPI Adaptive ç±»ï¼Œæ‰€ä»¥å¯ä»¥è‡ªåŠ¨è·å–åˆ°**å¯¹åº”çš„** Cluster å®ç°ç±»ã€‚

#### 3.2 å­ç±»

[![Cluster å­ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)Cluster å­ç±»

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸ª Cluster å®ç°ç±»ï¼Œå¯¹åº”ä¸€ä¸ª**ä¸“å±**äºå…¶çš„ Invoker å®ç°ç±»ã€‚æœ¬æ–‡åˆ†äº«çš„ FailoverCluster çš„å¯¹åº”çš„ Invoker ä¸º FailoverClusterInvoker ã€‚åœ¨çœ‹å…·ä½“çš„ä»£ç ä¹‹å‰ï¼Œå…ˆä¸€èµ·æ¥çœ‹çœ‹**é›†ç¾¤å®¹é”™çš„è°ƒç”¨( invoke )è¿‡ç¨‹**ã€‚

## 4. è°ƒç”¨é¡ºåºå›¾

å¦‚ä¸‹æ˜¯æœåŠ¡**æ¶ˆè´¹è€…**çš„è°ƒç”¨é¡ºåºå›¾ï¼š

[![é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2019_04_01/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/02.png)é¡ºåºå›¾

- åœ¨ InvokerInvocationHandler çš„ ã€4ã€‘`#invoke(invocation)` å¤„**æ’å…¥**ï¼š**å…ˆ**è°ƒç”¨**é›†ç¾¤å®¹é”™ Invoker** çš„ `#invoke(invocation)` ï¼Œ**å†**è°ƒç”¨ `ProtocolFilterWrapper$Invoker` çš„ `#invoke(invocation)` ã€‚

- è°ƒç”¨æ ˆ

  å¦‚ä¸‹å›¾ï¼š

  ![è°ƒç”¨æ ˆ](http://static.iocoder.cn/images/Dubbo/2019_04_01/03.png)

  è°ƒç”¨æ ˆ

  - MockClusterInvoker ï¼Œèƒ–å‹å…ˆæ— è§†ï¼Œåç»­æœ‰è¯¦ç»†æ–‡ç« ï¼Œè¿›è¡Œåˆ†äº«ã€‚

## 5. FailoverCluster

`com.alibaba.dubbo.rpc.cluster.support.FailoverCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œå½“å‡ºç°å¤±è´¥ï¼Œé‡è¯•å…¶å®ƒæœåŠ¡å™¨ã€‚é€šå¸¸ç”¨äº**è¯»æ“ä½œ**ï¼Œä½†é‡è¯•ä¼šå¸¦æ¥æ›´é•¿å»¶è¿Ÿã€‚å¯é€šè¿‡ `retries="2"` æ¥è®¾ç½®é‡è¯•æ¬¡æ•°(ä¸å«ç¬¬ä¸€æ¬¡)ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FailoverCluster implements Cluster {

    public final static String NAME = "failover";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailoverClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker ä¸º FailoverClusterInvoker ã€‚

## 6. AbstractClusterInvoker

å› ä¸ºï¼ŒFailoverClusterInvoker ç»§æ‰¿ AbstractClusterInvoker ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¥åˆ†äº«å®ƒã€‚

`com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker` ï¼Œå®ç° Invoker æ¥å£ï¼ŒCluster Invoker æŠ½è±¡ç±»ï¼š

- **å®ç°**ä¾‹å¦‚é€‰æ‹©ä¸€ä¸ªç¬¦åˆ Invoker å¯¹è±¡ç­‰ç­‰**å…¬ç”¨**æ–¹æ³•

- **å®šä¹‰** `#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` **æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°å­ Cluster çš„ Invoker å®ç°ç±»çš„**æœåŠ¡è°ƒç”¨**çš„å·®å¼‚é€»è¾‘ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  protected abstract Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException;
  ```

#### 6.1 æ„é€ æ–¹æ³•

```
/**
 * Directory å¯¹è±¡
 */
protected final Directory<T> directory;
/**
 * é›†ç¾¤æ—¶æ˜¯å¦æ’é™¤éå¯ç”¨( available )çš„ Invoker ï¼Œé»˜è®¤ä¸º true
 */
protected final boolean availablecheck;
/**
 * æ˜¯å¦å·²ç»é”€æ¯
 */
private AtomicBoolean destroyed = new AtomicBoolean(false);
/**
 * ç²˜æ»è¿æ¥ Invoker
 *
 * http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html
 * ç²˜æ»è¿æ¥ç”¨äºæœ‰çŠ¶æ€æœåŠ¡ï¼Œå°½å¯èƒ½è®©å®¢æˆ·ç«¯æ€»æ˜¯å‘åŒä¸€æä¾›è€…å‘èµ·è°ƒç”¨ï¼Œé™¤éè¯¥æä¾›è€…æŒ‚äº†ï¼Œå†è¿å¦ä¸€å°ã€‚
 * ç²˜æ»è¿æ¥å°†è‡ªåŠ¨å¼€å¯å»¶è¿Ÿè¿æ¥ï¼Œä»¥å‡å°‘é•¿è¿æ¥æ•°ã€‚
 */
private volatile Invoker<T> stickyInvoker = null;

public AbstractClusterInvoker(Directory<T> directory) {
    this(directory, directory.getUrl());
}

public AbstractClusterInvoker(Directory<T> directory, URL url) {
    // åˆå§‹åŒ– directory
    if (directory == null) {
        throw new IllegalArgumentException("service directory == null");
    }
    this.directory = directory;
    // sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.
    // åˆå§‹åŒ– availablecheck
    this.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);
}
```

- `directory` å­—æ®µï¼ŒDirectory å¯¹è±¡ã€‚é€šè¿‡å®ƒï¼Œå¯ä»¥è·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€…çš„ Invoker å¯¹è±¡ã€‚

- `availablecheck` å­—æ®µï¼Œé›†ç¾¤æ—¶æ˜¯å¦æ’é™¤éå¯ç”¨( available )çš„ Invoker ï¼Œé»˜è®¤ä¸º `"true"` ï¼Œé€šè¿‡ `"cluster.availablecheck"` é…ç½®é¡¹è®¾ç½®ã€‚

- `destroyed` å­—æ®µï¼Œæ˜¯å¦å·²ç»é”€æ¯ã€‚è‹¥å·²ç»é”€æ¯ï¼Œåˆ™ä¸å…è®¸åœ¨è°ƒç”¨ã€‚

- `stickyInvoker` å­—æ®µï¼Œç²˜æ»è¿æ¥ Invoker ï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” ç²˜æ»è¿æ¥
  ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/stickiness.html) æ–‡æ¡£ã€‚

  > ç²˜æ»è¿æ¥ç”¨äºæœ‰çŠ¶æ€æœåŠ¡ï¼Œå°½å¯èƒ½è®©å®¢æˆ·ç«¯æ€»æ˜¯å‘åŒä¸€æä¾›è€…å‘èµ·è°ƒç”¨ï¼Œé™¤éè¯¥æä¾›è€…æŒ‚äº†ï¼Œå†è¿å¦ä¸€å°ã€‚

#### 6.2 list

`#list(Invocation)` æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
protected List<Invoker<T>> list(Invocation invocation) throws RpcException {
    return directory.list(invocation);
}
```

#### 6.3 select

`#select(LoadBalance, Invocation, invokers, selected)` æ–¹æ³•ï¼Œä»**å€™é€‰**çš„ Invoker é›†åˆï¼Œé€‰æ‹©ä¸€ä¸ª**æœ€ç»ˆè°ƒç”¨**çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
/**
 * ä½¿ç”¨ loadbalance é€‰æ‹© invoker.
 *
 * @param loadbalance Loadbalance å¯¹è±¡ï¼Œæä¾›è´Ÿè´£å‡è¡¡ç­–ç•¥
 * @param invocation Invocation å¯¹è±¡
 * @param invokers   å€™é€‰çš„ Invoker é›†åˆ
 * @param selected    å·²é€‰è¿‡çš„ Invoker é›†åˆ. æ³¨æ„ï¼šè¾“å…¥ä¿è¯ä¸é‡å¤
 * @return æœ€ç»ˆçš„ Invoker å¯¹è±¡
 * @throws RpcException å½“å‘ç”Ÿ RpcException æ—¶
 */
  1: protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
  2:     if (invokers == null || invokers.isEmpty()) {
  3:         return null;
  4:     }
  5:     // è·å¾— sticky é…ç½®é¡¹ï¼Œæ–¹æ³•çº§
  6:     String methodName = invocation == null ? "" : invocation.getMethodName();
  7:     boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);
  8:     {
  9:         // ignore overloaded method
 10:         // è‹¥ stickyInvoker ä¸å­˜åœ¨äº invokers ä¸­ï¼Œè¯´æ˜ä¸åœ¨å€™é€‰ä¸­ï¼Œéœ€è¦ç½®ç©ºï¼Œé‡æ–°é€‰æ‹©
 11:         if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
 12:             stickyInvoker = null;
 13:         }
 14:         // ignore cucurrent problem
 15:         // è‹¥å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼Œä¸” stickyInvoker ä¸å­˜åœ¨äº selected ä¸­ï¼Œåˆ™è¿”å› stickyInvoker è¿™ä¸ª Invoker å¯¹è±¡
 16:         if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
 17:             // è‹¥å¼€å¯æ’é™¤éå¯ç”¨çš„ Invoker çš„ç‰¹æ€§ï¼Œåˆ™æ ¡éªŒ stickyInvoker æ˜¯å¦å¯ç”¨ã€‚è‹¥å¯ç”¨ï¼Œåˆ™è¿›è¡Œè¿”å›
 18:             if (availablecheck && stickyInvoker.isAvailable()) {
 19:                 return stickyInvoker;
 20:             }
 21:         }
 22:     }
 23: 
 24:     // æ‰§è¡Œé€‰æ‹©
 25:     Invoker<T> invoker = doselect(loadbalance, invocation, invokers, selected);
 26: 
 27:     // è‹¥å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼Œè®°å½•æœ€ç»ˆé€‰æ‹©çš„ Invoker åˆ° stickyInvoker
 28:     if (sticky) {
 29:         stickyInvoker = invoker;
 30:     }
 31:     return invoker;
 32: }
```

- è¯¥æ–¹æ³•ä¸»è¦å¤„ç†**ç²˜æ»è¿æ¥**çš„ç‰¹æ€§ï¼Œå…·ä½“ä½¿ç”¨ Loadbalance é€‰æ‹© Invoker å¯¹è±¡çš„é€»è¾‘ï¼Œåœ¨ `#doselect(loadbalance, invocation, invokers, selected)` æ–¹æ³•ä¸­ã€‚

- ç¬¬ 5 è‡³ 22 è¡Œï¼šè·å¾—

  ç²˜æ»è¿æ¥

   

  ```
  stickyInvoker
  ```

   

  å¯¹è±¡ã€‚

  - ç¬¬ 6 è‡³ 7 è¡Œï¼šè·å¾—æ–¹æ³•çº§çš„ `sticky` é…ç½®é¡¹ã€‚

  - ç¬¬ 9 è‡³ 13 è¡Œï¼šè‹¥ `stickyInvoker` ä¸å­˜åœ¨äº `invokers` ä¸­ï¼Œè¯´æ˜ä¸åœ¨å€™é€‰ä¸­ï¼Œéœ€è¦ç½®ç©ºï¼Œé‡æ–°é€‰æ‹©ã€‚

  - ç¬¬ 14 è‡³ 21 è¡Œï¼šè·å¾—

    ç²˜æ»è¿æ¥

     

    ```
    stickyInvoker
    ```

     

    å¯¹è±¡ã€‚å¦‚è¦æ»¡è¶³å¦‚ä¸‹

    æ¡ä»¶

    ï¼š

    - ç¬¬ 16 è¡Œï¼š1ï¼‰å¼€å¯ç²˜æ»è¿æ¥çš„ç‰¹æ€§ï¼›2ï¼‰`stickyInvoker` ä¸å­˜åœ¨äº `selected` ä¸­ã€‚
    - ç¬¬ 18 è¡Œï¼šè‹¥å¼€å¯**æ’é™¤éå¯ç”¨**çš„ Invoker çš„ç‰¹æ€§ï¼Œåˆ™æ ¡éªŒ `stickyInvoker` æ˜¯å¦å¯ç”¨ã€‚

- ç¬¬ 25 è¡Œï¼šè°ƒç”¨ `#doselect(loadbalance, invocation, invokers, selected)` æ–¹æ³•ï¼Œæ‰§è¡Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

- ç¬¬ 27 è‡³ 30 è¡Œï¼šè‹¥å¼€å¯**ç²˜æ»è¿æ¥**çš„ç‰¹æ€§ï¼Œè®°å½•æœ€ç»ˆé€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œåˆ° `stickyInvoker` ä¸­ã€‚

###### 6.3.1 doselect

`#doselect(loadbalance, invocation, invokers, selected)` æ–¹æ³•ï¼Œä»**å€™é€‰**çš„ Invoker é›†åˆï¼Œé€‰æ‹©ä¸€ä¸ª**æœ€ç»ˆè°ƒç”¨**çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private Invoker<T> doselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
 2:     if (invokers == null || invokers.isEmpty()) {
 3:         return null;
 4:     }
 5:     // ã€ç¬¬ä¸€ç§ã€‘å¦‚æœåªæœ‰ä¸€ä¸ª Invoker ï¼Œç›´æ¥é€‰æ‹©
 6:     if (invokers.size() == 1) {
 7:         return invokers.get(0);
 8:     }
 9:     // ã€ç¬¬äºŒç§ã€‘å¦‚æœåªæœ‰ä¸¤ä¸ª Invoker ï¼Œé€€åŒ–æˆè½®å¾ª
10:     // If we only have two invokers, use round-robin instead.
11:     if (invokers.size() == 2 && selected != null && !selected.isEmpty()) {
12:         return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0);
13:     }
14: 
15:     // ã€ç¬¬ä¸‰ç§ã€‘ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
16:     Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
17: 
18:     // If the `invoker` is in the  `selected` or invoker is unavailable && availablecheck is true, reselect.
19:     // å¦‚æœ selectedä¸­åŒ…å«ï¼ˆä¼˜å…ˆåˆ¤æ–­ï¼‰ æˆ–è€… ä¸å¯ç”¨&&availablecheck=true åˆ™é‡è¯•.
20:     if ((selected != null && selected.contains(invoker))
21:             || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
22:         try {
23:             //ã€ç¬¬å››ç§ã€‘é‡é€‰ä¸€ä¸ª Invoker å¯¹è±¡
24:             Invoker<T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
25:             if (rinvoker != null) {
26:                 invoker = rinvoker;
27:             } else {
28:                 // Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
29:                 // ã€ç¬¬äº”ç§ã€‘çœ‹ä¸‹ç¬¬ä¸€æ¬¡é€‰çš„ä½ç½®ï¼Œå¦‚æœä¸æ˜¯æœ€åï¼Œé€‰+1ä½ç½®.
30:                 int index = invokers.indexOf(invoker);
31:                 try {
32:                     // Avoid collision
33:                     // æœ€ååœ¨é¿å…ç¢°æ’
34:                     invoker = index < invokers.size() - 1 ? invokers.get(index + 1) : invoker;
35:                 } catch (Exception e) {
36:                     logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
37:                 }
38:             }
39:         } catch (Throwable t) {
40:             logger.error("clustor relselect fail reason is :" + t.getMessage() + " if can not slove ,you can set cluster.availablecheck=false in url", t);
41:         }
42:     }
43:     return invoker;
44: }
```

- æœ‰**äº”ç§**é€‰æ‹©æœ€ç»ˆè°ƒç”¨çš„ Invoker å¯¹è±¡çš„æ–¹å¼ã€‚

- ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 5 è‡³ 8 è¡Œï¼šå¦‚æœåªæœ‰**ä¸€ä¸ªå€™é€‰**çš„ Invoker å¯¹è±¡ï¼Œç›´æ¥é€‰æ‹©è¿”å›ã€‚ğŸ˜ˆ å› ä¸ºæ²¡çš„é€‰æ‹©äº†ã€‚

- ã€ç¬¬äºŒç§ã€‘ç¬¬ 9 è‡³ 13 è¡Œï¼šå¦‚æœåªæœ‰**ä¸¤ä¸ªå€™é€‰**çš„ Invoker é›†åˆï¼Œé€€åŒ–ä¸ºè½®è¯¢ã€‚æ­¤å¤„å­˜åœ¨ä¸€ä¸ª BUG ï¼š

  > è½¬è½½è‡ªæˆ‘**é£å“¥**ï¼Œ[ã€Šdubbo æºç  - è´Ÿè½½å‡è¡¡ã€‹](https://www.jianshu.com/p/10c30d7b8b6a)
  >
  > è¿™é‡Œé€€åŒ–æˆè½®è¯¢çš„å®ç°æœ‰é—®é¢˜ï¼Œå¯¹åº”æºç `return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0)ï¼›`å¦‚æœretries=4ï¼Œå³æœ€å¤šè°ƒç”¨5æ¬¡ï¼Œä¸”ä¸¤ä¸ªå¯é€‰invokeåˆ†åˆ«ä¸ºï¼š
  >
  > 10.0.0.1:20884ï¼Œ10.0.0.1:20886ï¼›
  >
  > é‚£ä¹ˆ5æ¬¡é€‰æ‹©çš„invokeä¸ºï¼š
  >
  > - 10.0.0.1:20884
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886
  > - 10.0.0.1:20886ï¼Œ
  >
  > å³é™¤äº†ç¬¬1æ¬¡å¤–åé¢çš„é€‰æ‹©éƒ½æ˜¯é€‰æ‹©**ç¬¬äºŒä¸ª**invoker;
  >
  > å› æ¬¡éœ€è¦æŠŠselected.get(0)ä¿®æ”¹ä¸ºï¼šselected.get(selected.size()-1)ï¼›
  >
  > å³æ¯æ¬¡æ‹¿å‰ä¸€æ¬¡é€‰æ‹©çš„invokerä¸ invokers.get(0)æ¯”è¾ƒï¼Œå¦‚æœç›¸åŒï¼Œåˆ™é€‰åˆ™å¦ä¸€ä¸ªinvokerï¼›å¦åˆ™å°±é€‰ invokers.get(0)ï¼›

  - æ¯”è¾ƒæœ‰è¶£çš„æ˜¯ï¼Œ[ISSUE#934ï¼šExtension of LoadBalance (a small suggestion for loadbalance policy when thereâ€™s less than 2 providers) ](https://github.com/apache/incubator-dubbo/issues/934)ã€‚å’Œä¸Šè¿° BUG æ— å…³ï¼Œèƒ–å‹è‡ªå·±ç†è§£ä¸‹ã€‚

- ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 16 è‡³ 21 è¡Œï¼šè°ƒç”¨ `Loadbalance#select(invokers, url, invocation)` æ–¹æ³•ï¼Œä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚å…·ä½“çš„ä»£ç å®ç°ï¼Œè§ Loadbalance çš„æ–‡ç« ã€‚

  - è¿™ç§æ–¹å¼çš„è¿”å›ï¼Œé€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œéœ€è¦æ»¡è¶³**ä¸¤ä¸ª**æ¡ä»¶ï¼š1ï¼‰ä¸å­˜åœ¨äº `selected` ä¸­ã€‚2ï¼‰Invoker æ˜¯å¯ç”¨çš„ï¼Œè‹¥å¼€å¯æ’é™¤éå¯ç”¨çš„ Invoker çš„ç‰¹æ€§ã€‚

- ã€ç¬¬å››ç§ã€‘è°ƒç”¨ `#reselect(loadbalance, invocation, invokers, selected, availablecheck)` æ–¹æ³•ï¼Œé‡æ–°é€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚ğŸ˜ˆ å› ä¸ºæ­¤æ—¶ `invokers` ä¸­ï¼Œæ— æ³•æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6.3.2 reselectã€](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface/#) ã€‚

- ã€ç¬¬äº”ç§ã€‘**é¡ºåº**ä»å€™é€‰çš„ `invokers` é›†åˆä¸­ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œä¸è€ƒè™‘æ˜¯å¦**å¯ç”¨**ï¼Œåˆæˆ–è€…**å·²ç»é€‰æ‹©è¿‡**ï¼Œç±»ä¼¼ã€ç¬¬ä¸€ç§ã€‘ã€ç¬¬äºŒç§ã€‘çš„æ–¹å¼ã€‚ğŸ˜ˆæ€»ä¹‹ï¼Œä¿è¯èƒ½è·å–åˆ°ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

###### 6.3.2 reselect

`#reselect(loadbalance, invocation, invokers, selected, availablecheck)` æ–¹æ³•ï¼Œé‡æ–°é€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availablecheck) throws RpcException {
 2:     // Allocating one in advance, this list is certain to be used.
 3:     // é¢„å…ˆåˆ†é…ä¸€ä¸ªï¼Œè¿™ä¸ªåˆ—è¡¨æ˜¯ä¸€å®šä¼šç”¨åˆ°çš„.
 4:     List<Invoker<T>> reselectInvokers = new ArrayList<Invoker<T>>(invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());
 5: 
 6:     // First, try picking a invoker not in `selected`.
 7:     // å…ˆä»éselectä¸­é€‰
 8:     if (availablecheck) { // invoker.isAvailable() should be checked
 9:         // è·å¾—éé€‰æ‹©è¿‡ï¼Œå¹¶ä¸”å¯ç”¨çš„ Invoker é›†åˆ
10:         for (Invoker<T> invoker : invokers) {
11:             if (invoker.isAvailable()) { // å¹¶ä¸”å¯ç”¨
12:                 if (selected == null || !selected.contains(invoker)) {
13:                     reselectInvokers.add(invoker);
14:                 }
15:             }
16:         }
17:         // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
18:         if (!reselectInvokers.isEmpty()) {
19:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
20:         }
21:     } else { // do not check invoker.isAvailable()
22:         // è·å¾—éé€‰æ‹©è¿‡çš„ Invoker é›†åˆ
23:         for (Invoker<T> invoker : invokers) {
24:             if (selected == null || !selected.contains(invoker)) {
25:                 reselectInvokers.add(invoker);
26:             }
27:         }
28:         // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
29:         if (!reselectInvokers.isEmpty()) {
30:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
31:         }
32:     }
33:     // Just pick an available invoker using loadbalance policy
34:     // æœ€åä»selectä¸­é€‰å¯ç”¨çš„.
35:     {
36:         // è·å¾—é€‰æ‹©è¿‡çš„ï¼Œå¹¶ä¸”å¯ç”¨çš„ Invoker é›†åˆ
37:         if (selected != null) {
38:             for (Invoker<T> invoker : selected) {
39:                 if ((invoker.isAvailable()) // available first
40:                         && !reselectInvokers.contains(invoker)) {
41:                     reselectInvokers.add(invoker);
42:                 }
43:             }
44:         }
45:         // ä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚
46:         if (!reselectInvokers.isEmpty()) {
47:             return loadbalance.select(reselectInvokers, getUrl(), invocation);
48:         }
49:     }
50:     return null;
51: }
```

- ç¬¬ 4 è¡Œï¼šé¢„å…ˆåˆ›å»ºä¸€ä¸ªé‡é€‰ Invoker é›†åˆï¼Œæˆ‘ä»¬ä¼šå‘ç°å¾ˆå¥‡æ€ªçš„ä¸€æ®µ `invokers.size() - 1` ä»£ç ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç¬”è€…çš„ç†è§£æ˜¯ï¼Œå‡ºç°é‡é€‰ `#reselect(...)` çš„åŸå› ï¼Œè¯´æ˜ `#doselect(...)` çš„ã€ç¬¬ä¸‰ç§ã€‘é€‰æ‹©çš„ Invoker å¯¹è±¡ï¼Œåœ¨ `selected` ä¸­ï¼Œå› æ­¤éœ€è¦**å»æ‰ä¸€ä¸ª**ã€‚

- ä¸€å…±æœ‰

  ä¸¤ç±»ä¸‰ç§

  çš„é€‰æ‹©æ–¹å¼ï¼š

  - ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 10 è‡³ 16 è¡Œï¼šè·å¾—**éé€‰æ‹©è¿‡**( `invokers` )ï¼Œ å¹¶ä¸”**å¿…é¡»**å¯ç”¨çš„ Invoker é›†åˆã€‚
  - ã€ç¬¬äºŒç§ã€‘ç¬¬ 22 è‡³ 27 è¡Œï¼šè·å¾—**éé€‰æ‹©è¿‡**( `invokers` )ï¼Œ å¹¶ä¸”**ä¸è€ƒè™‘**å¯ç”¨çš„ Invoker é›†åˆã€‚
  - ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 36 è‡³ 44 è¡Œï¼šè·å¾—**é€‰æ‹©è¿‡**( `selected` )ï¼Œå¹¶ä¸”**å¿…é¡»**å¯ç”¨çš„ Invoker é›†åˆã€‚

- ç¬¬ 19 è¡Œ || ç¬¬ 30 è¡Œ || ç¬¬ 47 è¡Œï¼šè°ƒç”¨ `Loadbalance#select(invokers, url, invocation)` æ–¹æ³•ï¼Œä½¿ç”¨ Loadbalance ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

#### 6.4 invoke

`#invoke(invocation)` æ–¹æ³•ï¼Œè°ƒç”¨æœåŠ¡**æä¾›è€…**çš„é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public Result invoke(final Invocation invocation) throws RpcException {
 3:     // æ ¡éªŒæ˜¯å¦é”€æ¯
 4:     checkWhetherDestroyed();
 5: 
 6:     // è·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆ
 7:     List<Invoker<T>> invokers = list(invocation);
 8: 
 9:     // è·å¾— LoadBalance å¯¹è±¡
10:     LoadBalance loadbalance;
11:     if (invokers != null && !invokers.isEmpty()) {
12:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()
13:                 .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));
14:     } else {
15:         loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);
16:     }
17: 
18:     // è®¾ç½®è°ƒç”¨ç¼–å·ï¼Œè‹¥æ˜¯å¼‚æ­¥è°ƒç”¨
19:     RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
20: 
21:     // æ‰§è¡Œè°ƒç”¨
22:     return doInvoke(invocation, invokers, loadbalance);
23: }
```

- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#checkWhetherDestroyed()` æ–¹æ³•ï¼Œ**æ ¡éªŒ**æ˜¯å¦å·²ç»é”€æ¯ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected void checkWhetherDestroyed() {
      if (destroyed.get()) {
          throw new RpcException("Rpc cluster invoker for " + getInterface() + " on consumer " + NetUtils.getLocalHost()
                  + " use dubbo version " + Version.getVersion()
                  + " is now destroyed! Can not invoke any more.");
      }
  }
  ```

- ç¬¬ 7 è¡Œï¼šè°ƒç”¨ `#list(invocation)` æ–¹æ³•ï¼ŒåŸºäº Directory ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚

- ç¬¬ 9 è‡³ 16 è¡Œï¼šè·å¾— Loadbalance å¯¹è±¡ã€‚

- ç¬¬ 19 è¡Œï¼šè°ƒç”¨ `RpcUtils#attachInvocationIdIfAsync(url, invocation)` æ–¹æ³•ï¼Œè®¾ç½®**è°ƒç”¨ç¼–å·**ï¼Œè‹¥æ˜¯å¼‚æ­¥è°ƒç”¨ã€‚

- ç¬¬ 22 è¡Œï¼šè°ƒç”¨ `#doInvoke(invocation, invokers, loadbalance)` **æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œè°ƒç”¨ã€‚ğŸ™‚ å­ Cluster çš„ Invoker å®ç°ç±»çš„**æœåŠ¡è°ƒç”¨**çš„å·®å¼‚é€»è¾‘ã€‚

#### 6.5 å…¶å®ƒå®ç°æ–¹æ³•

###### 6.5.1 getInterface

```
@Override
public Class<T> getInterface() {
    return directory.getInterface();
}
```

###### 6.5.2 getUrl

```
@Override
public URL getUrl() {
    return directory.getUrl();
}
```

###### 6.5.3 isAvailable

```
@Override
public boolean isAvailable() {
    // å¦‚æœ‰ç²˜æ»è¿æ¥ Invoker ï¼ŒåŸºäºå®ƒåˆ¤æ–­ã€‚
    Invoker<T> invoker = stickyInvoker; // æŒ‡å‘ï¼Œé¿å…å¹¶å‘
    if (invoker != null) {
        return invoker.isAvailable();
    }
    // åŸºäº Directory åˆ¤æ–­
    return directory.isAvailable();
}
```

###### 6.5.4 checkInvokers

```
protected void checkInvokers(List<Invoker<T>> invokers, Invocation invocation) {
    if (invokers == null || invokers.isEmpty()) {
        throw new RpcException("Failed to invoke the method "
                + invocation.getMethodName() + " in the service " + getInterface().getName()
                + ". No provider available for the service " + directory.getUrl().getServiceKey()
                + " from registry " + directory.getUrl().getAddress()
                + " on the consumer " + NetUtils.getLocalHost()
                + " using the dubbo version " + Version.getVersion()
                + ". Please check if the providers have been started and registered.");
    }
}
```

###### 6.5.5 destroy

```
@Override
public void destroy() {
    if (destroyed.compareAndSet(false, true)) {
        directory.destroy();
    }
}
```

## 7. FailoverClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼Œ**FailoverCluster** Invoker å®ç°ç±»ã€‚

å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼Œå½“å‡ºç°å¤±è´¥ï¼Œé‡è¯•å…¶å®ƒæœåŠ¡å™¨ã€‚é€šå¸¸ç”¨äº**è¯»æ“ä½œ**ï¼Œä½†é‡è¯•ä¼šå¸¦æ¥æ›´é•¿å»¶è¿Ÿã€‚å¯é€šè¿‡ `retries="2"` æ¥è®¾ç½®é‡è¯•æ¬¡æ•°(ä¸å«ç¬¬ä¸€æ¬¡)ã€‚

åœ¨çœ‹å…·ä½“çš„ `#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` çš„å®ç°ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥ç…ç…**è°ƒç”¨é¡ºåºå›¾**ï¼š

[![è°ƒç”¨é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2019_04_01/04.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/04.png)è°ƒç”¨é¡ºåºå›¾

- å®é™…é€»è¾‘å¾ˆç®€å•ï¼š**å¾ªç¯**ï¼ŒæŸ¥æ‰¾ä¸€ä¸ª Invoker å¯¹è±¡ï¼Œè¿›è¡Œè°ƒç”¨ï¼Œç›´åˆ°**æˆåŠŸ**ã€‚

`#doInvoke(Invocation, List<Invoker<T>>, LoadBalance)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
 3:     List<Invoker<T>> copyinvokers = invokers;
 4:     // æ£€æŸ¥copyinvokerså³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
 5:     checkInvokers(copyinvokers, invocation);
 6:     // å¾—åˆ°æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°ï¼šæœ€å¤§å¯é‡è¯•æ¬¡æ•°+1ï¼Œé»˜è®¤æœ€å¤§å¯é‡è¯•æ¬¡æ•°Constants.DEFAULT_RETRIES=2
 7:     int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;
 8:     if (len <= 0) {
 9:         len = 1;
10:     }
11:     // ä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸
12:     RpcException le = null;
13:     // ä¿å­˜å·²ç»è°ƒç”¨è¿‡çš„Invoker
14:     List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.
15:     Set<String> providers = new HashSet<String>(len);
16:     // failoveræœºåˆ¶æ ¸å¿ƒå®ç°ï¼šå¦‚æœå‡ºç°è°ƒç”¨å¤±è´¥ï¼Œé‚£ä¹ˆé‡è¯•å…¶ä»–æœåŠ¡å™¨
17:     for (int i = 0; i < len; i++) {
18:         // é‡è¯•æ—¶ï¼Œè¿›è¡Œé‡æ–°é€‰æ‹©ï¼Œé¿å…é‡è¯•æ—¶invokeråˆ—è¡¨å·²å‘ç”Ÿå˜åŒ–.
19:         // æ³¨æ„ï¼šå¦‚æœåˆ—è¡¨å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆinvokedåˆ¤æ–­ä¼šå¤±æ•ˆï¼Œå› ä¸ºinvokerç¤ºä¾‹å·²ç»æ”¹å˜
20:         if (i > 0) {
21:             checkWhetherDestroyed();
22:             // æ ¹æ®Invocationè°ƒç”¨ä¿¡æ¯ä»Directoryä¸­è·å–æ‰€æœ‰å¯ç”¨Invoker
23:             copyinvokers = list(invocation);
24:             // check again
25:             // é‡æ–°æ£€æŸ¥ä¸€ä¸‹
26:             checkInvokers(copyinvokers, invocation);
27:         }
28:         // æ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä»copyinvokersä¸­é€‰æ‹©ä¸€ä¸ªInvoker
29:         Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);
30:         // ä¿å­˜æ¯æ¬¡è°ƒç”¨çš„Invoker
31:         invoked.add(invoker);
32:         // è®¾ç½®å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­
33:         RpcContext.getContext().setInvokers((List) invoked);
34:         try {
35:             // RPC è°ƒç”¨å¾—åˆ° Result
36:             Result result = invoker.invoke(invocation);
37:             // é‡è¯•è¿‡ç¨‹ä¸­ï¼Œå°†æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸ä¿¡æ¯ä»¥ warn çº§åˆ«æ—¥å¿—è¾“å‡º
38:             if (le != null && logger.isWarnEnabled()) {
39:                 logger.warn("Although retry the method " + invocation.getMethodName()
40:                         + " in the service " + getInterface().getName()
41:                         + " was successful by the provider " + invoker.getUrl().getAddress()
42:                         + ", but there have been failed providers " + providers
43:                         + " (" + providers.size() + "/" + copyinvokers.size()
44:                         + ") from the registry " + directory.getUrl().getAddress()
45:                         + " on the consumer " + NetUtils.getLocalHost()
46:                         + " using the dubbo version " + Version.getVersion() + ". Last error is: "
47:                         + le.getMessage(), le);
48:             }
49:             return result;
50:         } catch (RpcException e) {
51:             // å¦‚æœæ˜¯ä¸šåŠ¡æ€§è´¨çš„å¼‚å¸¸ï¼Œä¸å†é‡è¯•ï¼Œç›´æ¥æŠ›å‡º
52:             if (e.isBiz()) { // biz exception.
53:                 throw e;
54:             }
55:             // å…¶ä»–æ€§è´¨çš„å¼‚å¸¸ç»Ÿä¸€å°è£…æˆRpcException
56:             le = e;
57:         } catch (Throwable e) {
58:             le = new RpcException(e.getMessage(), e);
59:         } finally {
60:             providers.add(invoker.getUrl().getAddress());
61:         }
62:     }
63:     // æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°ç”¨å®Œè¿˜å¾—åˆ°Resultçš„è¯ï¼ŒæŠ›å‡ºRpcExceptionå¼‚å¸¸ï¼šé‡è¯•äº†Næ¬¡è¿˜æ˜¯å¤±è´¥ï¼Œå¹¶è¾“å‡ºæœ€åä¸€æ¬¡å¼‚å¸¸ä¿¡æ¯
64:     throw new RpcException(le != null ? le.getCode() : 0, "Failed to invoke the method "
65:             + invocation.getMethodName() + " in the service " + getInterface().getName()
66:             + ". Tried " + len + " times of the providers " + providers
67:             + " (" + providers.size() + "/" + copyinvokers.size()
68:             + ") from the registry " + directory.getUrl().getAddress()
69:             + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
70:             + Version.getVersion() + ". Last error is: "
71:             + (le != null ? le.getMessage() : ""), le != null && le.getCause() != null ? le.getCause() : le);
72: }
```

- ç¬¬ 3 è¡Œï¼š`copyinvokers` å˜é‡ï¼Œå€™é€‰çš„ Invoker é›†åˆã€‚

- ç¬¬ 5 è¡Œï¼šè°ƒç”¨**çˆ¶** `#checkInvokers(copyinvokers, invocation)` æ–¹æ³•ï¼Œ**æ ¡éªŒ**å€™é€‰çš„ Invoker é›†åˆ**éç©º**ã€‚å¦‚æœä¸ºç©ºï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚

- ç¬¬ 6 è‡³ 10 è¡Œï¼šè·å¾—**æœ€å¤§å¯è°ƒç”¨æ¬¡æ•°**ï¼šæœ€å¤§**å¯é‡è¯•**æ¬¡æ•° +1 ã€‚é»˜è®¤æœ€å¤§å¯é‡è¯•æ¬¡æ•°`Constants.DEFAULT_RETRIES = 2` ã€‚

- ç¬¬ 12 è¡Œï¼š`le` å˜é‡ï¼Œä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„**å¼‚å¸¸**ã€‚

- ç¬¬ 14 è¡Œï¼š`invoked` å˜é‡ï¼Œä¿å­˜å·²ç»è°ƒç”¨çš„ Invoker é›†åˆã€‚

- ç¬¬ 15 è¡Œï¼š`providers` å˜é‡ï¼Œä¿å­˜å·²ç»è°ƒç”¨çš„**ç½‘ç»œåœ°å€**é›†åˆã€‚

- ç¬¬ 16 è‡³ 62 è¡Œï¼š

  failover æœºåˆ¶æ ¸å¿ƒå®ç°ï¼šå¦‚æœå‡ºç°è°ƒç”¨å¤±è´¥ï¼Œé‚£ä¹ˆé‡è¯•å…¶ä»–æœåŠ¡å™¨

  ã€‚

  - ç¬¬ 20 è‡³ 27 è¡Œï¼š**é‡è¯•æ—¶**( `i > 0` )ï¼Œ è¿›è¡Œé‡æ–°é€‰æ‹©ï¼Œé¿å…é‡è¯•æ—¶ï¼Œå€™é€‰ Invoker é›†åˆï¼Œå·²å‘ç”Ÿå˜åŒ–ã€‚
  - ã€é‡è¦ã€‘ç¬¬ 29 è¡Œï¼šè°ƒç”¨**çˆ¶** `#select(loadbalance, invocation, copyinvokers, invoked)` æ–¹æ³•ï¼Œæ ¹æ® Loadbalance è´Ÿè½½å‡è¡¡æœºåˆ¶ï¼Œä» `copyinvokers` ä¸­ï¼Œé€‰æ‹©ä¸€ä¸ªè¢«è°ƒç”¨çš„ Invoker å¯¹è±¡ã€‚
  - ç¬¬ 31 è¡Œï¼šä¿å­˜æ¯æ¬¡è°ƒç”¨çš„ Invoker å¯¹è±¡ï¼Œåˆ° `invoked` ä¸­ã€‚
  - ç¬¬ 33 è¡Œï¼šä¿å­˜å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­ã€‚
  - ã€é‡è¦ã€‘ç¬¬ 36 è¡Œï¼šè°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼Œ**å‘èµ· RPC è°ƒç”¨**ã€‚
  - ç¬¬ 37 è‡³ 48 è¡Œï¼šè‹¥ `le` éç©ºï¼Œè¯´æ˜æ­¤æ—¶æ˜¯**é‡è¯•è°ƒç”¨æˆåŠŸ**ï¼Œå°†æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸ä¿¡æ¯ä»¥ **warn** çº§åˆ«æ—¥å¿—è¾“å‡ºï¼Œæ–¹ä¾¿æœªæ¥è¿½æº¯ã€‚
  - ========== å¼‚å¸¸ç›¸å…³ ===========
  - ç¬¬ 55 è‡³ 54 è¡Œï¼šå¦‚æœæ˜¯ä¸šåŠ¡æ€§è´¨çš„å¼‚å¸¸ï¼Œä¸å†é‡è¯•ï¼Œç›´æ¥æŠ›å‡ºã€‚
  - ç¬¬ 56 è¡Œï¼šä¿å­˜å¼‚å¸¸åˆ° `le` ã€‚
  - ç¬¬ 58 è¡Œï¼šé RpcException å¼‚å¸¸ï¼Œ**å°è£…**æˆ RpcException å¼‚å¸¸ã€‚
  - ç¬¬ 59 è‡³ 61 è¡Œï¼šä¿å­˜æ¯æ¬¡è°ƒç”¨çš„**ç½‘ç»œåœ°å€**ï¼Œåˆ° `providers` ä¸­ã€‚

- ç¬¬ 63 è‡³ 71 è¡Œï¼šè¶…è¿‡æœ€å¤§è°ƒç”¨æ¬¡æ•°ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚è¯¥å¼‚å¸¸ä¸­ï¼Œå¸¦æœ‰æœ€åä¸€æ¬¡è°ƒç”¨å¼‚å¸¸çš„ä¿¡æ¯ã€‚

# 2ã€Cluster å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ APIã€‹](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `support` åŒ…ï¼Œ**å„ç§ Cluster å®ç°ç±»**ã€‚

Cluster å­ç±»å¦‚ä¸‹å›¾ï¼š

[![Cluster å­ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_01/01.png)Cluster å­ç±»

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ¯ä¸ª Cluster å®ç°ç±»ï¼Œå¯¹åº”ä¸€ä¸ª**ä¸“å±**äºå…¶çš„ Invoker å®ç°ç±»ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªå­ç±»å¾€ä¸‹çœ‹ã€‚

> è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” é›†ç¾¤å®¹é”™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html) æ–‡æ¡£ã€‚

## 2. AvailableCluster

`com.alibaba.dubbo.rpc.cluster.support.AvailableCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œè°ƒç”¨**é¦–ä¸ªå¯ç”¨**æœåŠ¡å™¨ï¼Œç›®å‰ç”¨äº[å¤šæ³¨å†Œä¸­å¿ƒå¼•ç”¨](http://dubbo.apache.org/zh-cn/docs/user/demos/multi-registry.html#å¤šæ³¨å†Œä¸­å¿ƒæ³¨å†Œ)ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class AvailableCluster implements Cluster {

    public static final String NAME = "available";

    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new AvailableClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º AvailableClusterInvoker ã€‚

#### 2.1 AvailableClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.AvailableClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒAvailableCluster Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class AvailableClusterInvoker<T> extends AbstractClusterInvoker<T> {

    public AvailableClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // å¾ªç¯å€™é€‰çš„ Invoker é›†åˆï¼Œè°ƒç”¨é¦–ä¸ªå¯ç”¨çš„ Invoker å¯¹è±¡ã€‚
        for (Invoker<T> invoker : invokers) {
            if (invoker.isAvailable()) { // å¯ç”¨
                // å‘èµ· RPC è°ƒç”¨
                return invoker.invoke(invocation);
            }
        }
        throw new RpcException("No provider available in " + invokers);
    }

}
```

## 3. BroadcastCluster

`com.alibaba.dubbo.rpc.cluster.support.BroadcastCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¹¿æ’­è°ƒç”¨**æ‰€æœ‰**æä¾›è€…ï¼Œé€ä¸ªè°ƒç”¨ï¼Œ**ä»»æ„**ä¸€å°æŠ¥é”™åˆ™æŠ¥é”™ã€‚é€šå¸¸ç”¨äºé€šçŸ¥æ‰€æœ‰æä¾›è€…æ›´æ–°ç¼“å­˜æˆ–æ—¥å¿—ç­‰æœ¬åœ°èµ„æºä¿¡æ¯ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class BroadcastCluster implements Cluster {

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new BroadcastClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º BroadcastClusterInvoker ã€‚

#### 3.1 BroadcastClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.BroadcastClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒBroadcastCluster Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class BroadcastClusterInvoker<T> extends AbstractClusterInvoker<T> {

    private static final Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker.class);

    public BroadcastClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    @SuppressWarnings({"unchecked", "rawtypes"})
    public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // æ£€æŸ¥ invokers å³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
        checkInvokers(invokers, invocation);
        // è®¾ç½®å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­
        RpcContext.getContext().setInvokers((List) invokers);
        // ä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸
        RpcException exception = null;
        // ä¿å­˜æœ€åä¸€æ¬¡è°ƒç”¨çš„ç»“æœ
        Result result = null;
        // å¾ªç¯å€™é€‰çš„ Invoker é›†åˆï¼Œè°ƒç”¨æ‰€æœ‰ Invoker å¯¹è±¡ã€‚
        for (Invoker<T> invoker : invokers) {
            try {
                // å‘èµ· RPC è°ƒç”¨
                result = invoker.invoke(invocation);
            } catch (RpcException e) {
                exception = e;
                logger.warn(e.getMessage(), e);
            } catch (Throwable e) {
                exception = new RpcException(e.getMessage(), e); // å°è£…æˆ RpcException å¼‚å¸¸
                logger.warn(e.getMessage(), e);
            }
        }
        // è‹¥å­˜åœ¨ä¸€ä¸ªå¼‚å¸¸ï¼ŒæŠ›å‡ºè¯¥å¼‚å¸¸
        if (exception != null) {
            throw exception;
        }
        return result;
    }

}
```

## 4. FailbackCluster

`com.alibaba.dubbo.rpc.cluster.support.FailbackCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¤±è´¥è‡ªåŠ¨æ¢å¤ï¼Œåå°è®°å½•å¤±è´¥è¯·æ±‚ï¼Œå®šæ—¶é‡å‘ã€‚é€šå¸¸ç”¨äºæ¶ˆæ¯é€šçŸ¥æ“ä½œã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FailbackCluster implements Cluster {

    public final static String NAME = "failback";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailbackClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º FailbackClusterInvoker ã€‚

#### 4.1 FailbackClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒFailbackCluster Invoker å®ç°ç±»ã€‚

###### 4.1.1 æ„é€ æ–¹æ³•

```
/**
 * é‡è¯•é¢‘ç‡
 */
private static final long RETRY_FAILED_PERIOD = 5 * 1000;

/**
 * ScheduledExecutorService å¯¹è±¡
 */
private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2, new NamedThreadFactory("failback-cluster-timer", true));
/**
 * å¤±è´¥ä»»åŠ¡é›†åˆ
 */
private final ConcurrentMap<Invocation, AbstractClusterInvoker<?>> failed = new ConcurrentHashMap<Invocation, AbstractClusterInvoker<?>>();
/**
 * é‡è¯•ä»»åŠ¡ Future
 */
private volatile ScheduledFuture<?> retryFuture;

public FailbackClusterInvoker(Directory<T> directory) {
    super(directory);
}
```

- æ‰€æœ‰å­—æ®µï¼Œéƒ½æ˜¯å’Œé‡è¯•ç›¸å…³ï¼Œèƒ–å‹çœ‹ä¸‹æ³¨é‡Šã€‚

###### 4.1.2 doInvoke

```
@Override
protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    try {
        // æ£€æŸ¥ invokers å³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
        checkInvokers(invokers, invocation);
        // æ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä» invokers ä¸­é€‰æ‹©ä¸€ä¸ªInvoker
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        // RPC è°ƒç”¨å¾—åˆ° Result
        return invoker.invoke(invocation);
    } catch (Throwable e) {
        logger.error("Failback to invoke method " + invocation.getMethodName() + ", wait for retry in background. Ignored exception: " + e.getMessage() + ", ", e);
        // æ·»åŠ åˆ°å¤±è´¥ä»»åŠ¡
        addFailed(invocation, this);
        return new RpcResult(); // ignore
    }
}
```

- è‹¥ RPC è°ƒç”¨å¤±è´¥ï¼Œåˆ™è°ƒç”¨ `#addFailed(invocation, this)` æ–¹æ³•ï¼Œæ·»åŠ åˆ° `failed` ä¸­ï¼Œåå°å®šæ—¶é‡è¯•ã€‚

###### 4.1.3 addFailed

```
private void addFailed(Invocation invocation, AbstractClusterInvoker<?> router) {
    // è‹¥å®šæ—¶ä»»åŠ¡æœªåˆå§‹åŒ–ï¼Œè¿›è¡Œåˆ›å»º
    if (retryFuture == null) {
        synchronized (this) {
            if (retryFuture == null) {
                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {

                    public void run() {
                        // collect retry statistics
                        try {
                            retryFailed();
                        } catch (Throwable t) { // Defensive fault tolerance
                            logger.error("Unexpected error occur at collect statistic", t);
                        }
                    }
                }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);
            }
        }
    }
    // æ·»åŠ åˆ°å¤±è´¥ä»»åŠ¡
    failed.put(invocation, router);
}
```

- åˆ›å»ºçš„å®šæ—¶ä»»åŠ¡ï¼Œä¼šè°ƒç”¨ `#retryFailed()` æ–¹æ³•ï¼Œé‡è¯•ä»»åŠ¡ï¼Œå‘èµ· RCP è°ƒç”¨ã€‚

###### 4.1.4 retryFailed

```
void retryFailed() {
    if (failed.size() == 0) {
        return;
    }
    // å¾ªç¯é‡è¯•ä»»åŠ¡ï¼Œé€ä¸ªè°ƒç”¨
    for (Map.Entry<Invocation, AbstractClusterInvoker<?>> entry : new HashMap<Invocation, AbstractClusterInvoker<?>>(failed).entrySet()) { // åˆ›å»ºé›†åˆ
        Invocation invocation = entry.getKey();
        Invoker<?> invoker = entry.getValue();
        try {
            // RPC è°ƒç”¨å¾—åˆ° Result
            invoker.invoke(invocation);
            // ç§»é™¤å¤±è´¥ä»»åŠ¡
            failed.remove(invocation);
        } catch (Throwable e) {
            logger.error("Failed retry to invoke method " + invocation.getMethodName() + ", waiting again.", e);
        }
    }
}
```

- å¾ªç¯é‡è¯•ä»»åŠ¡ï¼Œé€ä¸ªå‘èµ· RPC è°ƒç”¨ã€‚è‹¥è°ƒç”¨æˆåŠŸï¼Œç§»é™¤è¯¥å¤±è´¥ä»»åŠ¡å‡º `failed` é›†åˆã€‚

åœ¨æç«¯æƒ…å†µä¸‹ï¼Œå­˜åœ¨ä¸€ä¸ª BUG ï¼Œå¤ç°æ­¥éª¤å¦‚ä¸‹ï¼š

1. å‡è®¾ç›®å‰æœ‰ä¸¤ä¸ªæœåŠ¡æä¾›è€… Aã€B ã€‚
2. é¦–å…ˆè°ƒç”¨ A æœåŠ¡ï¼Œå‡è®¾è¶…æ—¶ï¼Œæ·»åŠ åˆ° `failed` ä¸­ã€‚
3. é‡è¯•è°ƒç”¨ B æœåŠ¡ï¼ˆA æœåŠ¡äº¦å¯ï¼‰ï¼Œå‡è®¾å†æ¬¡è¶…æ—¶ï¼Œæ·»åŠ åˆ° `failed` ä¸­ã€‚
4. å› ä¸º `#doInvoker(...)` æ–¹æ³•ï¼Œè°ƒç”¨å¤±è´¥ï¼Œä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼ˆå½“ç„¶ä¹Ÿä¸èƒ½ï¼‰ï¼Œå¯¼è‡´ `#retryFailed(...)` æ–¹æ³•ï¼Œ**è¯¯ä»¥ä¸º**è°ƒç”¨æˆåŠŸï¼Œé”™è¯¯çš„ç§»é™¤è¯¥å¤±è´¥ä»»åŠ¡å‡º `failed` é›†åˆã€‚

é‚£ä¹ˆèƒ½ä¸èƒ½åœ¨ `#retryFailed(...)` æ–¹æ³•ä¸­ï¼Œå…ˆç§»é™¤è¯¥å¤±è´¥ä»»åŠ¡å‡º `failed` é›†åˆå‘¢ï¼Œå†å‘èµ· PRC è°ƒç”¨å‘¢ï¼Ÿç­”æ¡ˆæ˜¯**ä¸å¯ä»¥**ï¼Œå› ä¸ºåœ¨è°ƒç”¨ `#doInvoke(...)` æ–¹æ³•ä¹‹å‰ï¼Œå¯èƒ½å‘ç”Ÿå¼‚å¸¸ï¼Œå¯¼è‡´å¤±è´¥ä»»åŠ¡çš„ä¸¢å¤±ã€‚

é‚£ä¹ˆè¯¥æ€ä¹ˆåŠï¼Ÿæœ‰ä¸¤ç§æ–¹å¼ï¼š

1. ä¸Šè¿°æ–¹æ¡ˆçš„åŸºç¡€ä¸Šï¼Œåœ¨ `#retryFailed(...)` æ–¹æ³•çš„ç§»é™¤å¤„ç†ä¸­ï¼Œå¢åŠ è°ƒç”¨ `#addFailed(...)` æ–¹æ³•ã€‚
2. æšä¸¾ä¸€ä¸ª `FAILED_RESULT` å¯¹è±¡ï¼Œè®© `#doInvoke(...)` æ–¹æ³•å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œè¿”å›è¯¥å¯¹è±¡ã€‚è¿™æ · `#retryFailed(...)` æ–¹æ³•ï¼Œåœ¨ç§»é™¤å‡º `failed` é›†åˆæ—¶ï¼Œå¢åŠ ä¸‹æ˜¯å¦æ‰§è¡ŒæˆåŠŸçš„åˆ¤æ–­ã€‚

ç¬”è€…å€¾å‘ç¬¬äºŒç§ï¼Œé€»è¾‘æ›´åŠ çº¿æ€§å’Œæ˜“æ‡‚ã€‚

## 5. FailfastCluster

`com.alibaba.dubbo.rpc.cluster.support.FailfastCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¿«é€Ÿå¤±è´¥ï¼Œåªå‘èµ·ä¸€æ¬¡è°ƒç”¨ï¼Œ**å¤±è´¥ç«‹å³æŠ¥é”™**ã€‚é€šå¸¸ç”¨äº**éå¹‚ç­‰æ€§çš„å†™æ“ä½œ**ï¼Œæ¯”å¦‚æ–°å¢è®°å½•ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FailfastCluster implements Cluster {

    public final static String NAME = "failfast";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailfastClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º FailfastClusterInvoker ã€‚

#### 5.1 FailfastInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailbackClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒFailfast Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FailfastClusterInvoker<T> extends AbstractClusterInvoker<T> {

    public FailfastClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        // æ£€æŸ¥ invokers å³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
        checkInvokers(invokers, invocation);
        // æ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä» invokers ä¸­é€‰æ‹©ä¸€ä¸ªInvoker
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        try {
            // RPC è°ƒç”¨å¾—åˆ° Result
            return invoker.invoke(invocation);
        } catch (Throwable e) {
            // è‹¥æ˜¯ä¸šåŠ¡æ€§è´¨çš„å¼‚å¸¸ï¼Œç›´æ¥æŠ›å‡º
            if (e instanceof RpcException && ((RpcException) e).isBiz()) { // biz exception.
                throw (RpcException) e;
            }
            // å°è£… RpcException å¼‚å¸¸ï¼Œå¹¶æŠ›å‡º
            throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,
                    "Failfast invoke providers " + invoker.getUrl() + " " + loadbalance.getClass().getSimpleName() + " select from all providers " + invokers + " for service " + getInterface().getName() + " method " + invocation.getMethodName() + " on consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e.getCause() != null ? e.getCause() : e);
        }
    }

}
```

- å’Œ FailbackClusterInvoker å·®å¼‚ç‚¹ï¼Œåœ¨äºå¯¹å¼‚å¸¸çš„å¤„ç†ã€‚

## 6. FailsafeCluster

`com.alibaba.dubbo.rpc.cluster.support.FailsafeCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¤±è´¥å®‰å…¨ï¼Œ**å‡ºç°å¼‚å¸¸æ—¶ï¼Œç›´æ¥å¿½ç•¥**ã€‚é€šå¸¸ç”¨äºå†™å…¥å®¡è®¡æ—¥å¿—ç­‰æ“ä½œã€‚

ä»£ç å¦‚ä¸‹ï¼š

```
public class FailfastCluster implements Cluster {

    public final static String NAME = "failfast";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailfastClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º FailsafeClusterInvoker ã€‚

#### 6.1 FailsafeClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.FailsafeClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒFailsafe Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FailsafeClusterInvoker<T> extends AbstractClusterInvoker<T> {

    private static final Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker.class);

    public FailsafeClusterInvoker(Directory<T> directory) {
        super(directory);
    }

    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        try {
            // æ£€æŸ¥ invokers å³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
            checkInvokers(invokers, invocation);
            // æ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä» invokers ä¸­é€‰æ‹©ä¸€ä¸ªInvoker
            Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
            // RPC è°ƒç”¨å¾—åˆ° Result
            return invoker.invoke(invocation);
        } catch (Throwable e) {
            // æ‰“å°å¼‚å¸¸æ—¥å¿—
            logger.error("Failsafe ignore exception: " + e.getMessage(), e);
            // å¿½ç•¥å¼‚å¸¸
            return new RpcResult(); // ignore
        }
    }

}
```

- å’Œ FailfastInvoker å·®å¼‚ç‚¹ï¼Œåœ¨äºå¯¹å¼‚å¸¸çš„å¤„ç†ã€‚

## 7. ForkingCluster

`com.alibaba.dubbo.rpc.cluster.support.ForkingCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œå¹¶è¡Œè°ƒç”¨å¤šä¸ªæœåŠ¡å™¨ï¼Œåªè¦ä¸€ä¸ªæˆåŠŸå³è¿”å›ã€‚é€šå¸¸ç”¨äºå®æ—¶æ€§è¦æ±‚è¾ƒé«˜çš„è¯»æ“ä½œï¼Œä½†éœ€è¦æµªè´¹æ›´å¤šæœåŠ¡èµ„æºã€‚å¯é€šè¿‡ `forks="2"` æ¥è®¾ç½®æœ€å¤§å¹¶è¡Œæ•°ã€‚

ä»£ç å¦‚ä¸‹ï¼š

```
public class ForkingCluster implements Cluster {

    public final static String NAME = "forking";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new ForkingClusterInvoker<T>(directory);
    }

}
```

#### 7.1 ForkingClusterInvoker

> è€è‰¿è‰¿ï¼šBlockQueue çš„ä½¿ç”¨ï¼Œéå¸¸ç²¾é«“ï¼

`com.alibaba.dubbo.rpc.cluster.support.ForkingClusterInvoker` ï¼Œå®ç° AbstractClusterInvoker æŠ½è±¡ç±»ï¼ŒForkingCluster Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: public class ForkingClusterInvoker<T> extends AbstractClusterInvoker<T> {
 2: 
 3:     /**
 4:      * ExecutorService å¯¹è±¡ï¼Œå¹¶ä¸”ä¸º CachedThreadPool ã€‚
 5:      */
 6:     private final ExecutorService executor = Executors.newCachedThreadPool(new NamedThreadFactory("forking-cluster-timer", true));
 7: 
 8:     public ForkingClusterInvoker(Directory<T> directory) {
 9:         super(directory);
10:     }
11: 
12:     @Override
13:     @SuppressWarnings({"unchecked", "rawtypes"})
14:     public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
15:         // æ£€æŸ¥ invokers å³å¯ç”¨Invokeré›†åˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸
16:         checkInvokers(invokers, invocation);
17:         // ä¿å­˜é€‰æ‹©çš„ Invoker é›†åˆ
18:         final List<Invoker<T>> selected;
19:         // å¾—åˆ°æœ€å¤§å¹¶è¡Œæ•°ï¼Œé»˜è®¤ä¸º Constants.DEFAULT_FORKS = 2
20:         final int forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);
21:         // è·å¾—è°ƒç”¨è¶…æ—¶æ—¶é—´ï¼Œé»˜è®¤ä¸º DEFAULT_TIMEOUT = 1000 æ¯«ç§’
22:         final int timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
23:         // è‹¥æœ€å¤§å¹¶è¡Œä¹¦å°äºç­‰äº 0ï¼Œæˆ–è€…å¤§äº invokers çš„æ•°é‡ï¼Œç›´æ¥ä½¿ç”¨ invokers
24:         if (forks <= 0 || forks >= invokers.size()) {
25:             selected = invokers;
26:         } else {
27:             // å¾ªç¯ï¼Œæ ¹æ®è´Ÿè½½å‡è¡¡æœºåˆ¶ä» invokersï¼Œä¸­é€‰æ‹©ä¸€ä¸ªä¸ªInvoker ï¼Œä»è€Œç»„æˆ Invoker é›†åˆã€‚
28:             // æ³¨æ„ï¼Œå› ä¸ºå¢åŠ äº†æ’é‡é€»è¾‘ï¼Œæ‰€ä»¥ä¸èƒ½ä¿è¯è·å¾—çš„ Invoker é›†åˆçš„å¤§å°ï¼Œå°äºæœ€å¤§å¹¶è¡Œæ•°
29:             selected = new ArrayList<Invoker<T>>();
30:             for (int i = 0; i < forks; i++) {
31:                 // åœ¨invokeråˆ—è¡¨(æ’é™¤selected)å,å¦‚æœæ²¡æœ‰é€‰å¤Ÿ,åˆ™å­˜åœ¨é‡å¤å¾ªç¯é—®é¢˜.è§selectå®ç°.
32:                 Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);
33:                 if (!selected.contains(invoker)) { //Avoid add the same invoker several times. //é˜²æ­¢é‡å¤æ·»åŠ invoker
34:                     selected.add(invoker);
35:                 }
36:             }
37:         }
38:         // è®¾ç½®å·²ç»è°ƒç”¨çš„ Invoker é›†åˆï¼Œåˆ° Context ä¸­
39:         RpcContext.getContext().setInvokers((List) selected);
40:         // å¼‚å¸¸è®¡æ•°å™¨
41:         final AtomicInteger count = new AtomicInteger();
42:         // åˆ›å»ºé˜»å¡é˜Ÿåˆ—
43:         final BlockingQueue<Object> ref = new LinkedBlockingQueue<Object>();
44:         // å¾ªç¯ selected é›†åˆï¼Œæäº¤çº¿ç¨‹æ± ï¼Œå‘èµ· RPC è°ƒç”¨
45:         for (final Invoker<T> invoker : selected) {
46:             executor.execute(new Runnable() {
47:                 public void run() {
48:                     try {
49:                         // RPC è°ƒç”¨ï¼Œè·å¾— Result ç»“æœ
50:                         Result result = invoker.invoke(invocation);
51:                         // æ·»åŠ  Result åˆ° `ref` é˜»å¡é˜Ÿåˆ—
52:                         ref.offer(result);
53:                     } catch (Throwable e) {
54:                         // å¼‚å¸¸è®¡æ•°å™¨ + 1
55:                         int value = count.incrementAndGet();
56:                         // è‹¥ RPC è°ƒç”¨ç»“æœéƒ½æ˜¯å¼‚å¸¸ï¼Œåˆ™æ·»åŠ å¼‚å¸¸åˆ° `ref` é˜»å¡é˜Ÿåˆ—
57:                         if (value >= selected.size()) {
58:                             ref.offer(e);
59:                         }
60:                     }
61:                 }
62:             });
63:         }
64:         try {
65:             // ä» `ref` é˜Ÿåˆ—ä¸­ï¼Œé˜»å¡ç­‰å¾…ç»“æœ
66:             Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);
67:             // è‹¥æ˜¯å¼‚å¸¸ç»“æœï¼ŒæŠ›å‡º RpcException å¼‚å¸¸
68:             if (ret instanceof Throwable) {
69:                 Throwable e = (Throwable) ret;
70:                 throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, "Failed to forking invoke provider " + selected + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e.getCause() != null ? e.getCause() : e);
71:             }
72:             // è‹¥æ˜¯æ­£å¸¸ç»“æœï¼Œç›´æ¥è¿”å›
73:             return (Result) ret;
74:         } catch (InterruptedException e) {
75:             throw new RpcException("Failed to forking invoke provider " + selected + ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e);
76:         }
77:     }
78: 
79: }
```

- ç¬¬ 15 è‡³ 39 è¡Œï¼šèƒ–å‹è‡ªå·±çœ‹ä»£ç æ³¨é‡Šï¼Œæ¯”è¾ƒæ˜“æ‡‚ã€‚

- ç¬¬ 41 è¡Œï¼š`count` å˜é‡ï¼Œ**å¼‚å¸¸**è®¡æ•°å™¨ã€‚

- ç¬¬ 43 è¡Œï¼š`ref` å˜é‡ï¼Œé˜»å¡é˜Ÿåˆ—ã€‚é€šè¿‡å®ƒï¼Œå®ç°çº¿ç¨‹æ± å¼‚æ­¥æ‰§è¡Œä»»åŠ¡çš„**ç»“æœé€šçŸ¥**ï¼Œéå¸¸äº®çœ¼ã€‚

- ç¬¬ 44 è‡³ 63 è¡Œï¼šå¾ªç¯

   

  ```
  selected
  ```

   

  é›†åˆï¼Œæäº¤çº¿ç¨‹æ± ï¼Œå‘èµ· RPC è°ƒç”¨ã€‚

  - ç¬¬ 49 è‡³ 52 è¡Œï¼šè°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼ŒRPC è°ƒç”¨ï¼Œ**æˆåŠŸ**è·å¾— Result ç»“æœï¼Œå¹¶å°† Result æ·»åŠ åˆ° `ref` é˜»å¡é˜Ÿåˆ—ä¸­ã€‚
  - ç¬¬ 53 è‡³ 59 è¡Œï¼šè‹¥è°ƒç”¨**å¤±è´¥**ï¼Œå¼‚å¸¸è®¡æ•°å™¨ `count` åŠ ä¸€ã€‚å½“æ‰€æœ‰çš„ RPC è°ƒç”¨éƒ½å®Œæˆï¼Œå¹¶ä¸”éƒ½æ˜¯å¼‚å¸¸æ—¶ï¼Œåˆ™æ·»åŠ **æœ€åä¸€ä¸ª**å¼‚å¸¸åˆ° `ref` é˜»å¡é˜Ÿåˆ—ã€‚ğŸ™‚ ç»†èŠ‚å¤„ç†å¾ˆåˆ°ä½ã€‚

- ç¬¬ 66 è¡Œï¼šä» `ref` é˜Ÿåˆ—ä¸­ï¼Œ**é˜»å¡**ç­‰å¾…ï¼Œç›´åˆ°è·å¾—åˆ°ç»“æœæˆ–è€…è¶…æ—¶ã€‚è‡³æ­¤ï¼ŒForkingClusterInvoker å®ç°äº†å¹¶è¡Œè°ƒç”¨ï¼Œä¸”åªè¦ä¸€ä¸ªæˆåŠŸå³è¿”å›ã€‚å½“ç„¶ï¼Œè¿˜æœ‰ä¸€ä¸ªéšæ€§çš„ï¼Œ**æ‰€æœ‰éƒ½å¤±è´¥æ‰è¿”å›**ã€‚

- ç¬¬ 67 è‡³ 76 è¡Œï¼šå¤„ç†ç­‰å¾…çš„â€œç»“æœâ€ã€‚

## 8. FailoverCluster

FailoverCluster ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸€ï¼‰ä¹‹æŠ½è±¡ APIã€‹](http://svip.iocoder.cn/Dubbo/cluster-1-api-interface//?self) ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬å·²ç»è¯¦ç»†è§£æã€‚

## 9. MergeableCluster

MergeableCluster ï¼Œå¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” åˆ†ç»„èšåˆã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) æ–‡æ¡£ï¼Œæˆ‘ä»¬åç»­å•ç‹¬å†™æ–‡ç« åˆ†äº«ã€‚

## 10. MockClusterWrapper

MockClusterWrapper ï¼Œå¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€”æœ¬åœ°ä¼ªè£… ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) æ–‡æ¡£ï¼Œæˆ‘ä»¬åç»­å•ç‹¬å†™æ–‡ç« åˆ†äº«ã€‚

# 3ã€Directory å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆäºŒï¼‰ä¹‹ Cluster å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-2-impl-cluster/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `directory` åŒ…ï¼Œ**å„ç§ Directory å®ç°ç±»**ã€‚

Directory ï¼Œä¸­æ–‡ç›´è¯‘ä¸º**ç›®å½•**ï¼Œä»£è¡¨äº†**å¤šä¸ª** Invoker ï¼Œå¯ä»¥æŠŠå®ƒçœ‹æˆ `List<Invoker>` ã€‚ä½†ä¸ List ä¸åŒçš„æ˜¯ï¼Œå®ƒçš„å€¼å¯èƒ½æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œæ¯”å¦‚æ³¨å†Œä¸­å¿ƒæ¨é€å˜æ›´ã€‚

Directory å­ç±»å¦‚ä¸‹å›¾ï¼š

[![Directory å­ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_10/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/01.png)Directory å­ç±»

æˆ‘ä»¬çœ‹åˆ°æœ‰ä¸¤ä¸ªå®ç°ç±»ï¼š

- StaticDirectory ï¼Œ**é™æ€** Directory å®ç°ç±»ï¼Œä»å‘½åä¸Šçœ‹å‡ºå®ƒæ˜¯**é™æ€**çš„ `List<Invoker>` ã€‚
- RegistryDirectory ï¼ŒåŸºäº**æ³¨å†Œä¸­å¿ƒ**çš„**åŠ¨æ€** Directory å®ç°ç±»ï¼Œä»å‘½åä¸Šçœ‹å‡ºå®ƒæ˜¯**åŠ¨æ€**çš„ï¼Œä¼šæ ¹æ®æ³¨å†Œä¸­å¿ƒçš„æ¨é€å˜æ›´ `List<Invoker>` ã€‚

## 2. Directory

`com.alibaba.dubbo.rpc.cluster.Directory` ï¼Œç»§æ‰¿ Node æ¥å£ï¼ŒDirectory æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public interface Directory<T> extends Node {

    /**
     * get service type.
     *
     * è·å¾—æœåŠ¡ç±»å‹ï¼Œä¾‹å¦‚ï¼šcom.alibaba.dubbo.demo.DemoService
     *
     * @return service type.
     */
    Class<T> getInterface();

    /**
     * list invokers.
     *
     * è·å¾—æ‰€æœ‰æœåŠ¡ Invoker é›†åˆ
     *
     * @return invokers
     */
    List<Invoker<T>> list(Invocation invocation) throws RpcException;

}
```

- å®šä¹‰äº†**ä¸¤ä¸ª**æ¥å£æ–¹æ³•ï¼Œåˆ†åˆ«è¿”å›æœåŠ¡çš„**ç±»å‹**å’Œ **Invoker é›†åˆ**ã€‚
- ä¸€ä¸ª Directory **åªå¯¹åº”**ä¸€ä¸ªæœåŠ¡ç±»å‹ã€‚

## 3. AbstractDirectory

`com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory` ï¼Œå®ç° Directory æ¥å£ï¼ŒDirectory æŠ½è±¡å®ç°ç±»ï¼Œå®ç°äº†å…¬ç”¨çš„**è·¯ç”±è§„åˆ™( Router )**çš„é€»è¾‘ã€‚

#### 3.1 æ„é€ æ–¹æ³•

```
/**
 * æ˜¯å¦å·²ç»é”€æ¯
 */
private volatile boolean destroyed = false;
/**
 * æ³¨å†Œä¸­å¿ƒ URL
 */
private final URL url;
/**
 * æ¶ˆè´¹è€… URL
 *
 * è‹¥æœªæ˜¾ç¤ºè°ƒç”¨ {@link #AbstractDirectory(URL, URL, List)} æ„é€ æ–¹æ³•ï¼ŒconsumerUrl ç­‰äº {@link #url}
 */
private volatile URL consumerUrl;
/**
 * Router æ•°ç»„
 */
private volatile List<Router> routers;

public AbstractDirectory(URL url) {
    this(url, null);
}

public AbstractDirectory(URL url, List<Router> routers) {
    this(url, url, routers);
}

public AbstractDirectory(URL url, URL consumerUrl, List<Router> routers) {
    if (url == null) {
        throw new IllegalArgumentException("url == null");
    }
    this.url = url;
    this.consumerUrl = consumerUrl;
    // è®¾ç½® Router æ•°ç»„
    setRouters(routers);
}
```

- `consumerUrl` å­—æ®µï¼Œè®¤çœŸçœ‹ä¸‹æ³¨é‡Šå’Œæ„é€ æ–¹æ³•ã€‚
- è°ƒç”¨ `#setRouters(routers)` æ–¹æ³•ï¼Œåˆå§‹åŒ–å¹¶è®¾ç½® Router æ•°ç»„ã€‚

#### 3.2 setRouters

`#setRouters(routers)` æ–¹æ³•ï¼Œåˆå§‹åŒ–å¹¶è®¾ç½® Router æ•°ç»„ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router?self) ä¸­ã€‚

#### 3.3 list

`#list(Invocation)` **å®ç°**æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰æœåŠ¡ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
 3:     if (destroyed) {
 4:         throw new RpcException("Directory already destroyed .url: " + getUrl());
 5:     }
 6:     // è·å¾—æ‰€æœ‰ Invoker é›†åˆ
 7:     List<Invoker<T>> invokers = doList(invocation);
 8:     // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
 9:     List<Router> localRouters = this.routers; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
10:     if (localRouters != null && !localRouters.isEmpty()) {
11:         for (Router router : localRouters) {
12:             try {
13:                 if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14:                     invokers = router.route(invokers, getConsumerUrl(), invocation);
15:                 }
16:             } catch (Throwable t) {
17:                 logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18:             }
19:         }
20:     }
21:     return invokers;
22: }
```

- ç¬¬ 7 è¡Œï¼šè°ƒç”¨ `#doList(invocation)` **æŠ½è±¡**æ–¹æ³•ï¼Œè·å¾—æ‰€æœ‰ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;
  ```

- ç¬¬ 9 è‡³ 20 è¡Œï¼šæ ¹æ®**è·¯ç”±è§„åˆ™( Router )**ï¼Œè¿›ä¸€æ­¥ç­›é€‰åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚

## 4. RegistryDirectory

`com.alibaba.dubbo.registry.integration.RegistryDirectory` ï¼Œå®ç° NotifyListener æ¥å£ï¼Œå®ç° AbstractDirectory æŠ½è±¡ç±»ï¼ŒåŸºäº**æ³¨å†Œä¸­å¿ƒ**çš„ Directory å®ç°ç±»ã€‚

1. RegistryDirectory åœ¨ `dubbo-registry` æ¨¡å—ï¼Œ`integration` åŒ…ä¸‹ï¼Œæ˜¯ Dubbo æ³¨å†Œä¸­å¿ƒæ¨¡å—é›†æˆ Directory çš„å®ç°ç±»ã€‚
2. RegistryDirectory ä½œä¸ºä¸€ä¸ª NotifyListener ï¼Œ**è®¢é˜…**æ³¨å†Œä¸­å¿ƒ( Registry ) çš„æ•°æ®ï¼Œå®ç°å¯¹å˜æ›´çš„**ç›‘å¬**ã€‚

#### 4.1 æ„é€ æ–¹æ³•

> RegistryDirectory çš„å­—æ®µæœ‰ **17** ä¸ªï¼Œæ¯”è¾ƒå¤šï¼Œæ‰€ä»¥èƒ–å‹è¯·è€å¿ƒã€‚

```
// ========== Dubbo SPI Adaptive å¯¹è±¡ BEGIN ==========

/**
 * Cluster$Adaptive å¯¹è±¡
 */
private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();
/**
 * RouterFactory$Adaptive å¯¹è±¡
 */
private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension();
/**
 * ConfiguratorFactory$Adaptive å¯¹è±¡
 */
private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();

// ========== æœåŠ¡æ¶ˆè´¹è€…ç›¸å…³ BEGIN ==========

/**
 * æœåŠ¡ç±»å‹ï¼Œä¾‹å¦‚ï¼šcom.alibaba.dubbo.demo.DemoService
 */
private final Class<T> serviceType; // Initialization at construction time, assertion not null
/**
 * Consumer URL çš„é…ç½®é¡¹ Map
 */
private final Map<String, String> queryMap; // Initialization at construction time, assertion not null
/**
 * æœåŠ¡æ–¹æ³•æ•°ç»„
 */
private final String[] serviceMethods;
/**
 * æ˜¯å¦å¼•ç”¨å¤šåˆ†ç»„
 *
 * æœåŠ¡åˆ†ç»„ï¼šhttp://dubbo.apache.org/zh-cn/docs/user/demos/service-group.html
 */
private final boolean multiGroup;

// ========== æ³¨å†Œä¸­å¿ƒç›¸å…³ BEGIN ==========

/**
 * æ³¨å†Œä¸­å¿ƒçš„ Protocol å¯¹è±¡
 */
private Protocol protocol; // Initialization at the time of injection, the assertion is not null
/**
 * æ³¨å†Œä¸­å¿ƒ
 */
private Registry registry; // Initialization at the time of injection, the assertion is not null
/**
 * æ³¨å†Œä¸­å¿ƒçš„æœåŠ¡ç±»ï¼Œç›®å‰æ˜¯ com.alibaba.dubbo.registry.RegistryService
 *
 * é€šè¿‡ {@link #url} çš„ {@link URL#getServiceKey()} è·å¾—
 */
private final String serviceKey; // Initialization at construction time, assertion not null
/**
 * æ˜¯å¦ç¦æ­¢è®¿é—®ã€‚
 *
 * æœ‰ä¸¤ç§æƒ…å†µä¼šå¯¼è‡´ï¼š
 *
 * 1. æ²¡æœ‰æœåŠ¡æä¾›è€…
 * 2. æœåŠ¡æä¾›è€…è¢«ç¦ç”¨
 */
private volatile boolean forbidden = false;

// ========== é…ç½®è§„åˆ™ç›¸å…³ BEGIN ==========

/**
 * åŸå§‹çš„ç›®å½• URL
 *
 * ä¾‹å¦‚ï¼šzookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&callbacks=1000&check=false&client=netty4&cluster=failback&dubbo=2.0.0&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,callbackParam,save,update,say03,delete,say04,demo,say01,bye,say02,saves&payload=1000&pid=63400&qos.port=33333&register.ip=192.168.16.23&sayHello.async=true&side=consumer&timeout=10000&timestamp=1527056491064
 */
private final URL directoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
/**
 * è¦†å†™çš„ç›®å½• URL ï¼Œç»“åˆé…ç½®è§„åˆ™
 */
private volatile URL overrideDirectoryUrl; // Initialization at construction time, assertion not null, and always assign non null value
/**
 * é…ç½®è§„åˆ™æ•°ç»„
 *
 * override rules
 * Priority: override>-D>consumer>provider
 * Rule one: for a certain provider <ip:port,timeout=100>
 * Rule two: for all providers <* ,timeout=5000>
 */
private volatile List<Configurator> configurators; // The initial value is null and the midway may be assigned to null, please use the local variable reference

// ========== æœåŠ¡æä¾›è€…ç›¸å…³ BEGIN ==========

/**
 * [url]ä¸[æœåŠ¡æä¾›è€… Invoker é›†åˆ]çš„æ˜ å°„ç¼“å­˜
 */
// Map<url, Invoker> cache service url to invoker mapping.
private volatile Map<String, Invoker<T>> urlInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
/**
 * [æ–¹æ³•å]ä¸[æœåŠ¡æä¾›è€… Invoker é›†åˆ]çš„æ˜ å°„ç¼“å­˜
 */
// Map<methodName, Invoker> cache service method to invokers mapping.
private volatile Map<String, List<Invoker<T>>> methodInvokerMap; // The initial value is null and the midway may be assigned to null, please use the local variable reference
/**
 * [æœåŠ¡æä¾›è€… Invoker é›†åˆ]ç¼“å­˜
 */
// Set<invokerUrls> cache invokeUrls to invokers mapping.
private volatile Set<URL> cachedInvokerUrls; // The initial value is null and the midway may be assigned to null, please use the local variable reference

public RegistryDirectory(Class<T> serviceType, URL url) {
    super(url);
    if (serviceType == null) {
        throw new IllegalArgumentException("service type is null.");
    }
    if (url.getServiceKey() == null || url.getServiceKey().length() == 0) {
        throw new IllegalArgumentException("registry serviceKey is null.");
    }
    this.serviceType = serviceType;
    this.serviceKey = url.getServiceKey();
    // è·å¾— queryMap
    this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));
    // è·å¾— overrideDirectoryUrl å’Œ directoryUrl
    this.overrideDirectoryUrl = this.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);
    // åˆå§‹åŒ– multiGroup
    String group = directoryUrl.getParameter(Constants.GROUP_KEY, "");
    this.multiGroup = group != null && ("*".equals(group) || group.contains(","));
    // åˆå§‹åŒ– serviceMethods
    String methods = queryMap.get(Constants.METHODS_KEY);
    this.serviceMethods = methods == null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);
}
```

- åˆ†æˆ**äº”ç±»**å˜é‡ã€‚èƒ–å‹è‡ªå·±çœ‹æ³¨é‡Šã€‚
- å¦‚æœä¸ç†è§£ï¼Œå¯ä»¥ç»“åˆä¸‹é¢çš„å…·ä½“æ–¹æ³•çš„ä½¿ç”¨ã€‚ğŸ™‚ å½“ç„¶ä¹Ÿå¯ä»¥ç»™æˆ‘ç•™è¨€ï¼Œå› ä¸ºç¡®å®å˜é‡æœ‰ç‚¹å¤šå’Œå¤æ‚ã€‚

#### 4.2 subscribe

`#subscribe(URL)` æ–¹æ³•ï¼Œå‘**æ³¨å†Œä¸­å¿ƒ**å‘èµ·è®¢é˜…ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public void subscribe(URL url) {
    // è®¾ç½®æ¶ˆè´¹è€… URL
    setConsumerUrl(url);
    // å‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…
    registry.subscribe(url, this);
}
```

- è°ƒç”¨**çˆ¶** `#setConsumerUrl(url)` æ–¹æ³•ï¼Œè®¾ç½® `consumerUrl` æ¶ˆè´¹è€… URL ã€‚
- è°ƒç”¨ `Registry#subscribe(url, NotifyListener)` æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…ã€‚

æœåŠ¡æ¶ˆè´¹è€…ï¼Œå†å¼•ç”¨æœåŠ¡æ—¶ï¼Œä¼šåˆ›å»º RegistryDirectory å¯¹è±¡ï¼Œå¹¶å‘èµ·**1ï¼‰æœåŠ¡æä¾›è€… + 2ï¼‰è·¯ç”±è§„åˆ™ + 3ï¼‰é…ç½®è§„åˆ™**çš„æ•°æ®è®¢é˜…ã€‚å¦‚ä¸‹å›¾ï¼š

[![doRefer](http://static.iocoder.cn/images/Dubbo/2019_04_10/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/02.png)doRefer

- å¯¹åº”ä¸º `RegistryProtocol#doRefer(Cluster, Registry, Class<T> type, URL url)` æ–¹æ³•ã€‚

#### 4.3 notify

åœ¨æ³¨å†Œä¸­å¿ƒ( Registry )å‘ç°æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šé€šçŸ¥å¯¹åº”çš„ NotifyListener ä»¬ã€‚å¦‚ä¸‹å›¾ï¼š

[![notify](http://static.iocoder.cn/images/Dubbo/2019_04_10/03.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/03.png)notify

- å¯¹åº”ä¸º `AbstractRegistry#notify(URL url, NotifyListener, List<URL> urls)` æ–¹æ³•ã€‚
- å› ä¸º RegistryDirectory ä½œä¸ºä¸€ä¸ª NotifyListener ï¼Œå‘æ³¨å†Œä¸­å¿ƒ( Registry )å‘èµ·äº†è®¢é˜…ï¼Œæ‰€ä»¥æ­¤æ—¶ä¼šè¢«é€šçŸ¥ã€‚**æ³¨æ„ï¼Œæ˜¯æŒ‰ç…§åˆ†ç±»å¾ªç¯é€šçŸ¥çš„**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ**ä¸€æ¬¡åªæœ‰ä¸€ç±» URL** ã€‚

`#notify(List<URL> urls)` **å®ç°**æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // æ ¹æ® URL çš„åˆ†ç±»æˆ–åè®®ï¼Œåˆ†ç»„æˆä¸‰ä¸ªé›†åˆ ã€‚
 4:     List<URL> invokerUrls = new ArrayList<URL>(); // æœåŠ¡æä¾›è€… URL é›†åˆ
 5:     List<URL> routerUrls = new ArrayList<URL>();
 6:     List<URL> configuratorUrls = new ArrayList<URL>();
 7:     for (URL url : urls) {
 8:         String protocol = url.getProtocol();
 9:         String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
10:         if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) {
11:             routerUrls.add(url);
12:         } else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {
13:             configuratorUrls.add(url);
14:         } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {
15:             invokerUrls.add(url);
16:         } else {
17:             logger.warn("Unsupported category " + category + " in notified url: " + url + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost());
18:         }
19:     }
20:     // å¤„ç†é…ç½®è§„åˆ™ URL é›†åˆ
21:     // configurators
22:     if (!configuratorUrls.isEmpty()) {
23:         this.configurators = toConfigurators(configuratorUrls);
24:     }
25:     // å¤„ç†è·¯ç”±è§„åˆ™ URL é›†åˆ
26:     // routers
27:     if (!routerUrls.isEmpty()) {
28:         List<Router> routers = toRouters(routerUrls);
29:         if (routers != null) { // null - do nothing
30:             setRouters(routers);
31:         }
32:     }
33:     // åˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ° `directoryUrl` ä¸­ï¼Œå½¢æˆ `overrideDirectoryUrl` å˜é‡ã€‚
34:     List<Configurator> localConfigurators = this.configurators; // local reference
35:     // merge override parameters
36:     this.overrideDirectoryUrl = directoryUrl;
37:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
38:         for (Configurator configurator : localConfigurators) {
39:             this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);
40:         }
41:     }
42:     // å¤„ç†æœåŠ¡æä¾›è€… URL é›†åˆ
43:     refreshInvoker(invokerUrls);
44: }
```

- **æ³¨æ„**ï¼Œè¿™æ˜¯ä¸€ä¸ª**åŒæ­¥**çš„æ–¹æ³•ã€‚

- ç¬¬ 3 è‡³ 19 è¡Œï¼šæ ¹æ® URL çš„**åˆ†ç±»**æˆ–åè®®ï¼Œåˆ†æˆç»„**ä¸‰ä¸ª**é›†åˆï¼š**1ï¼‰æœåŠ¡æä¾›è€… + 2ï¼‰è·¯ç”±è§„åˆ™ + 3ï¼‰é…ç½®è§„åˆ™**ã€‚

- ç¬¬ 20 è‡³ 24 è¡Œï¼šéç©ºï¼Œè°ƒç”¨ `#toConfigurators(configuratorUrls)` æ–¹æ³•ï¼Œå¤„ç†**é…ç½®è§„åˆ™** URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.1 toConfiguratorsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 25 è‡³ 32 è¡Œï¼šéç©ºï¼Œè°ƒç”¨

   

  ```
  #toRouters(routerUrls)
  ```

   

  æ–¹æ³•ï¼Œå¤„ç†

  è·¯ç”±è§„åˆ™

   

  URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§

   

  ã€Œ4.3.2 toRoutersã€

   

  ã€‚

  - è‹¥è½¬æ¢åˆ° `routers` éç©ºï¼Œè°ƒç”¨**çˆ¶** `#setRouters(routers)` æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™ã€‚

- ç¬¬ 33 è‡³ 41 è¡Œï¼šåˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ° `directoryUrl` ä¸­ï¼Œå½¢æˆ `overrideDirectoryUrl` å˜é‡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) çš„ [ã€Œ4.1.2 mergeUrlã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 43 è¡Œï¼šè°ƒç”¨ `#refreshInvoker(invokerUrls)` æ–¹æ³•ï¼Œå¤„ç†**æœåŠ¡æä¾›è€…** URL é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3 refreshInvokerã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

###### 4.3.1 toConfigurators

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator?self) çš„ [ã€Œ4.1.1 toConfiguratorsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

###### 4.3.2 toRouters

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚

#### 4.7 å†…éƒ¨ç±»

###### 4.7.1 InvokerDelegate

InvokerDelegate ï¼Œå®ç° `com.alibaba.dubbo.rpc.protocol.InvokerWrapper` ç±»ï¼ŒInvoker ä»£ç†ç±»ï¼Œä¸»è¦ç”¨äºå­˜å‚¨**æ³¨å†Œä¸­å¿ƒä¸‹å‘çš„ url åœ°å€**( `providerUrl` )ï¼Œç”¨äºé‡æ–°é‡æ–° refer æ—¶èƒ½å¤Ÿæ ¹æ® `providerURL` queryMap overrideMap é‡æ–°ç»„è£…ã€‚ ä»£ç å¦‚ä¸‹ï¼š

> è€è‰¿è‰¿ï¼šç›®å‰è²Œä¼¼æ²¡çœ‹åˆ°è¿™å—é€»è¾‘å™¢ ğŸ˜¯ğŸ˜¯ğŸ˜¯

```
private static class InvokerDelegate<T> extends InvokerWrapper<T> {

    /**
     * æœåŠ¡æä¾›è€… URL
     *
     * æœªç»è¿‡é…ç½®åˆå¹¶
     */
    private URL providerUrl;

    public InvokerDelegate(Invoker<T> invoker, URL url, URL providerUrl) {
        super(invoker, url);
        this.providerUrl = providerUrl;
    }

    public URL getProviderUrl() {
        return providerUrl;
    }

}
```

###### 4.7.2 InvokerComparator

InvokerComparator ï¼Œå®ç° Comparator æ¥å£ï¼ŒInvoker æ’åºå™¨å®ç°ç±»ï¼Œ**æ ¹æ® URL å‡åº** ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private static class InvokerComparator implements Comparator<Invoker<?>> {

    /**
     * å•ä¾‹
     */
    private static final InvokerComparator comparator = new InvokerComparator();

    private InvokerComparator() {
    }

    public static InvokerComparator getComparator() {
        return comparator;
    }

    @Override
    public int compare(Invoker<?> o1, Invoker<?> o2) {
        return o1.getUrl().toString().compareTo(o2.getUrl().toString());
    }

}
```

###### 4.3.3 refreshInvoker

`#refreshInvoker(List<URL> invokerUrls)` æ–¹æ³•ï¼Œå®˜æ–¹æ³¨é‡Šå…¶å¦‚ä¸‹ï¼š

> æ ¹æ® invokerURL åˆ—è¡¨è½¬æ¢ä¸º invoker åˆ—è¡¨ã€‚è½¬æ¢è§„åˆ™å¦‚ä¸‹ï¼š
>
> 1. å¦‚æœ url å·²ç»è¢«è½¬æ¢ä¸º invoker ï¼Œåˆ™ä¸åœ¨é‡æ–°å¼•ç”¨ï¼Œç›´æ¥ä»ç¼“å­˜ä¸­è·å–ï¼Œæ³¨æ„å¦‚æœ url ä¸­ä»»ä½•ä¸€ä¸ªå‚æ•°å˜æ›´ä¹Ÿä¼šé‡æ–°å¼•ç”¨
> 2. å¦‚æœä¼ å…¥çš„ invoker åˆ—è¡¨ä¸ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºæœ€æ–°çš„ invoker åˆ—è¡¨
> 3. å¦‚æœä¼ å…¥çš„ invokerUrl åˆ—è¡¨æ˜¯ç©ºï¼Œåˆ™è¡¨ç¤ºåªæ˜¯ä¸‹å‘çš„ override è§„åˆ™æˆ– route è§„åˆ™ï¼Œéœ€è¦é‡æ–°äº¤å‰å¯¹æ¯”ï¼Œå†³å®šæ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨ã€‚

- æ˜¯ä¸æ˜¯çœ‹èµ·æ¥æœ‰ç‚¹ç‚¹æ‡µé€¼ï¼Ÿæ·¡å®šï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ä»£ç ã€‚

```
 1: private void refreshInvoker(List<URL> invokerUrls) {
 2:     if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null
 3:             && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
 4:         // è®¾ç½®ç¦æ­¢è®¿é—®
 5:         this.forbidden = true; // Forbid to access
 6:         // methodInvokerMap ç½®ç©º
 7:         this.methodInvokerMap = null; // Set the method invoker map to null
 8:         // é”€æ¯æ‰€æœ‰ Invoker é›†åˆ
 9:         destroyAllInvokers(); // Close all invokers
10:     } else {
11:         // è®¾ç½®å…è®¸è®¿é—®
12:         this.forbidden = false; // Allow to access
13:         // å¼•ç”¨è€çš„ urlInvokerMap
14:         Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
15:         // ä¼ å…¥çš„ invokerUrls ä¸ºç©ºï¼Œè¯´æ˜æ˜¯è·¯ç”±è§„åˆ™æˆ–é…ç½®è§„åˆ™å‘ç”Ÿæ”¹å˜ï¼Œæ­¤æ—¶ invokerUrls æ˜¯ç©ºçš„ï¼Œç›´æ¥ä½¿ç”¨ cachedInvokerUrls ã€‚
16:         if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
17:             invokerUrls.addAll(this.cachedInvokerUrls);
18:         // ä¼ å…¥çš„ invokerUrls éç©ºï¼Œæ›´æ–° cachedInvokerUrls ã€‚
19:         } else {
20:             this.cachedInvokerUrls = new HashSet<URL>();
21:             this.cachedInvokerUrls.addAll(invokerUrls); //Cached invoker urls, convenient for comparison //ç¼“å­˜invokerUrlsåˆ—è¡¨ï¼Œä¾¿äºäº¤å‰å¯¹æ¯”
22:         }
23:         // å¿½ç•¥ï¼Œè‹¥æ—  invokerUrls
24:         if (invokerUrls.isEmpty()) {
25:             return;
26:         }
27:         // å°†ä¼ å…¥çš„ invokerUrls ï¼Œè½¬æˆæ–°çš„ urlInvokerMap
28:         Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map
29:         // è½¬æ¢å‡ºæ–°çš„ methodInvokerMap
30:         Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map
31:         // state change
32:         // If the calculation is wrong, it is not processed. å¦‚æœè®¡ç®—é”™è¯¯ï¼Œåˆ™ä¸è¿›è¡Œå¤„ç†.
33:         if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
34:             logger.error(new IllegalStateException("urls to invokers error .invokerUrls.size :" + invokerUrls.size() + ", invoker.size :0. urls :" + invokerUrls.toString()));
35:             return;
36:         }
37:         // è‹¥æœåŠ¡å¼•ç”¨å¤š group ï¼Œåˆ™æŒ‰ç…§ method + group èšåˆ Invoker é›†åˆ
38:         this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;
39:         this.urlInvokerMap = newUrlInvokerMap;
40:         // é”€æ¯ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆ
41:         try {
42:             destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
43:         } catch (Exception e) {
44:             logger.warn("destroyUnusedInvokers error. ", e);
45:         }
46:     }
47: }
```

- ========== ç¬¬ä¸€éƒ¨åˆ† ==========

- ç¬¬ 2 è‡³ 3 è¡Œï¼šå½“ `invokerUrls` é›†åˆå¤§å°ä¸º **1** ï¼Œå¹¶ä¸”åè®®ä¸º `empty://` ï¼Œè¯´æ˜æ‰€æœ‰æœåŠ¡æä¾›è€…éƒ½å·²ç»**ä¸‹çº¿**ã€‚è‹¥æ³¨å†Œä¸­å¿ƒä¸º Zookeeper ï¼Œå¯å‚è§ `ZookeeperRegistry#toUrlsWithEmpty(URL consumer, String path, List<String> providers)` æ–¹æ³•ã€‚

- ç¬¬ 5 è¡Œï¼šè®¾ç½®**ç¦æ­¢**è®¿é—®ï¼Œå› ä¸ºæ²¡æœ‰æœåŠ¡æä¾›è€…äº†ã€‚

- ç¬¬ 7 è¡Œï¼š`methodInvokerMap` ç½®ç©ºã€‚

- ç¬¬ 9 è¡Œï¼šè°ƒç”¨ `#destroyAllInvokers()` æ–¹æ³•ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.5 destroyAllInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ========== ç¬¬äºŒéƒ¨åˆ† ==========

- ç¬¬ 12 è¡Œï¼šè®¾ç½®**å…è®¸**è®¿é—®ï¼Œå› ä¸ºæœ‰æœåŠ¡æä¾›è€…äº†ã€‚

- ç¬¬ 15 è‡³ 17 è¡Œï¼šä¼ å…¥çš„ `invokerUrls` ä¸ºç©ºï¼Œ**è¯´æ˜æ˜¯è·¯ç”±è§„åˆ™æˆ–é…ç½®è§„åˆ™å‘ç”Ÿæ”¹å˜**ï¼Œæ­¤æ—¶ `invokerUrls` æ˜¯ç©ºçš„ï¼Œç›´æ¥ä½¿ç”¨ `cachedInvokerUrls` ã€‚å¯¹åº”å®˜æ–¹æ³¨é‡Šã€ç¬¬ 3 ç‚¹ã€‘ï¼ˆéƒ¨åˆ†ï¼Œä¸åŒ…æ‹¬â€œéœ€è¦é‡æ–°äº¤å‰å¯¹æ¯”ï¼Œå†³å®šæ˜¯å¦éœ€è¦é‡æ–°å¼•ç”¨â€ï¼‰ã€‚

- ç¬¬ 18 è‡³ 22 è¡Œï¼šä¼ å…¥çš„

   

  ```
  invokerUrls
  ```

   

  éç©ºï¼Œæ›´æ–°

   

  ```
  cachedInvokerUrls
  ```

   

  ã€‚è€ƒè™‘åˆ°å¹¶å‘çš„é—®é¢˜ï¼Œæ›´æ–°çš„æ–¹å¼ä¸ºåˆ›å»º

  æ–°çš„

   

  HashSet ã€‚å¯¹åº”å®˜æ–¹æ³¨é‡Šã€ç¬¬ 2 ç‚¹ã€‘ã€‚

  - ä¸ºä»€ä¹ˆã€ç¬¬ 15 è‡³ 17 è¡Œã€‘**ä¸éœ€è¦æ›´æ–°**å‘¢ï¼Ÿå› ä¸º `invokerUrls` ä¸ºç©ºï¼Œç›´æ¥ä½¿ç”¨ `cachedInvokerUrls` ï¼Œç›¸å½“äºè¿›è¡Œäº†â€œæ›´æ–°â€ã€‚

- ç¬¬ 23 è‡³ 26 è¡Œï¼šå¿½ç•¥ï¼Œè‹¥æ—  `invokerUrls` ã€‚å‡ºç°æƒ…å†µä¸ºï¼Œåˆå§‹æ˜¯æŒ‰ç…§ `configurators => routers => providers` ï¼Œæ‰€ä»¥å‰ä¸¤ä¸ªä¼šå‡ºç°è¿™ä¸ªæƒ…å†µã€‚å…³äºè¿™ä¸€ç‚¹ï¼Œèƒ–å‹å¯ä»¥è°ƒè¯•æ„Ÿå—ä¸‹ã€‚

- ç¬¬ 28 è¡Œï¼šè°ƒç”¨ `#toInvokers(List<URL> urls)` æ–¹æ³•ï¼Œå°†ä¼ å…¥çš„ `invokerUrls` ï¼Œè½¬æ¢æˆ**æ–°çš„** `urlInvokerMap` ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.1 toInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 30 è¡Œï¼šè°ƒç”¨ `#toMethodInvokers(newUrlInvokerMap)` æ–¹æ³•ï¼Œå°† `urlInvokerMap` è½¬æˆä¸æ–¹æ³•çš„æ˜ å°„å…³ç³»ï¼Œå³**æ–°çš„** `methodInvokerMap` ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.2 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 31 è‡³ 36 è¡Œï¼šå¦‚æœè®¡ç®—é”™è¯¯ï¼Œåˆ™ä¸è¿›è¡Œå¤„ç†ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ˜¯é˜²å¾¡æ€§ç¼–ç¨‹ã€‚

- ç¬¬ 38 è¡Œï¼šè‹¥æœåŠ¡å¼•ç”¨**å¤š** group ï¼Œåˆ™è°ƒç”¨ `#toMergeMethodInvokerMap(newMethodInvokerMap)` æ–¹æ³•ï¼ŒæŒ‰ç…§ **method + group** èšåˆ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.3 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 39 è¡Œï¼šèµ‹å€¼ `urlInvokerMap` å±æ€§ã€‚

- ç¬¬ 40 è‡³ 45 è¡Œï¼šè°ƒç”¨ `#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)` æ–¹æ³•ï¼Œ**é”€æ¯**ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.4 toMethodInvokersã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

####### 4.3.3.1 toInvokers

`#toInvokers(List<URL> urls)` æ–¹æ³•ï¼Œ

```
 1: private Map<String, Invoker<T>> toInvokers(List<URL> urls) {
 2:     // æ–°çš„ `newUrlInvokerMap`
 3:     Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();
 4:     // è‹¥ä¸ºç©ºï¼Œç›´æ¥è¿”å›
 5:     if (urls == null || urls.isEmpty()) {
 6:         return newUrlInvokerMap;
 7:     }
 8:     // å·²åˆå§‹åŒ–çš„æœåŠ¡å™¨æä¾› URL é›†åˆ
 9:     Set<String> keys = new HashSet<String>();
10:     // è·å¾—å¼•ç”¨æœåŠ¡çš„åè®®
11:     String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);
12:     // å¾ªç¯æœåŠ¡æä¾›è€… URL é›†åˆï¼Œè½¬æˆ Invoker é›†åˆ
13:     for (URL providerUrl : urls) {
14:         // If protocol is configured at the reference side, only the matching protocol is selected
15:         // å¦‚æœ reference ç«¯é…ç½®äº† protocol ï¼Œåˆ™åªé€‰æ‹©åŒ¹é…çš„ protocol
16:         if (queryProtocols != null && queryProtocols.length() > 0) {
17:             boolean accept = false;
18:             String[] acceptProtocols = queryProtocols.split(","); // å¯é…ç½®å¤šä¸ªåè®®
19:             for (String acceptProtocol : acceptProtocols) {
20:                 if (providerUrl.getProtocol().equals(acceptProtocol)) {
21:                     accept = true;
22:                     break;
23:                 }
24:             }
25:             if (!accept) {
26:                 continue;
27:             }
28:         }
29:         // å¿½ç•¥ï¼Œè‹¥ä¸º `empty://` åè®®
30:         if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
31:             continue;
32:         }
33:         // å¿½ç•¥ï¼Œè‹¥åº”ç”¨ç¨‹åºä¸æ”¯æŒè¯¥åè®®
34:         if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
35:             logger.error(new IllegalStateException("Unsupported protocol " + providerUrl.getProtocol() + " in notified url: " + providerUrl + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost()
36:                     + ", supported protocol: " + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
37:             continue;
38:         }
39:         // åˆå¹¶ URL å‚æ•°
40:         URL url = mergeUrl(providerUrl);
41:         // å¿½ç•¥ï¼Œè‹¥å·²ç»åˆå§‹åŒ–
42:         String key = url.toFullString(); // The parameter urls are sorted
43:         if (keys.contains(key)) { // Repeated url
44:             continue;
45:         }
46:         // æ·»åŠ åˆ° `keys` ä¸­
47:         keys.add(key);
48:         // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
49:         // å¦‚æœæœåŠ¡ç«¯ URL å‘ç”Ÿå˜åŒ–ï¼Œåˆ™é‡æ–° refer å¼•ç”¨
50:         Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference
51:         Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
52:         if (invoker == null) { // Not in the cache, refer again æœªåœ¨ç¼“å­˜ä¸­ï¼Œé‡æ–°å¼•ç”¨
53:             try {
54:                 // åˆ¤æ–­æ˜¯å¦å¼€å¯
55:                 boolean enabled;
56:                 if (url.hasParameter(Constants.DISABLED_KEY)) {
57:                     enabled = !url.getParameter(Constants.DISABLED_KEY, false);
58:                 } else {
59:                     enabled = url.getParameter(Constants.ENABLED_KEY, true);
60:                 }
61:                 // è‹¥å¼€å¯ï¼Œåˆ›å»º Invoker å¯¹è±¡
62:                 if (enabled) {
63:                     // æ³¨æ„ï¼Œå¼•ç”¨æœåŠ¡
64:                     invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);
65:                 }
66:             } catch (Throwable t) {
67:                 logger.error("Failed to refer invoker for interface:" + serviceType + ",url:(" + url + ")" + t.getMessage(), t);
68:             }
69:             // æ·»åŠ åˆ° newUrlInvokerMap ä¸­
70:             if (invoker != null) { // Put new invoker in cache
71:                 newUrlInvokerMap.put(key, invoker);
72:             }
73:         } else { // åœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ Invoker å¯¹è±¡ï¼Œæ·»åŠ åˆ° newUrlInvokerMap ä¸­
74:             newUrlInvokerMap.put(key, invoker);
75:         }
76:     }
77:     // æ¸…ç©º keys
78:     keys.clear();
79:     return newUrlInvokerMap;
80: }
```

- ç¬¬ 3 è¡Œï¼š`newUrlInvokerMap` å˜é‡ï¼Œæ–°çš„ `urlInvokerMap` å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚

- ç¬¬ 4 è‡³ 7 è¡Œï¼šè‹¥ `urls` ä¸ºç©ºï¼Œç›´æ¥è¿”å›ï¼Œé˜²å¾¡æ€§ç¼–ç¨‹ã€‚

- ç¬¬ 9 è¡Œï¼š`keys` å˜é‡ï¼Œ**å·²åˆå§‹åŒ–**çš„æœåŠ¡å™¨æä¾› URL é›†åˆï¼Œå³æœåŠ¡æä¾›è€… URL å·²ç»å¤„ç†ã€‚

- ç¬¬ 11 è¡Œï¼šè·å¾—å¼•ç”¨æœåŠ¡çš„åè®®ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä¼šè®¾ç½® `<dubbo:reference protocol=""/>` é…ç½®é¡¹ã€‚

- ç¬¬ 13 è¡Œï¼š**å¾ªç¯** `urls` é›†åˆï¼Œè½¬æˆ Invoker é›†åˆã€‚

- åè®®å¤„ç†ç›¸å…³

  - ç¬¬ 14 è‡³ 28 è¡Œï¼šå¦‚æœ reference ç«¯é…ç½®äº† protocol ï¼Œåˆ™**åªé€‰æ‹©åŒ¹é…**çš„ protocol ã€‚
  - ç¬¬ 29 è‡³ 32 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥ä¸º `empty://` åè®®ã€‚
  - ç¬¬ 33 è‡³ 38 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥åº”ç”¨ç¨‹åºä¸æ”¯æŒè¯¥åè®®ã€‚

- ç¬¬ 40 è¡Œï¼šè°ƒç”¨ `#mergeUrl(providerUrl)` æ–¹æ³•ï¼Œ**åˆå¹¶** URL å‚æ•°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.3.3.1 mergeUrlã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

- ç¬¬ 41 è‡³ 47 è¡Œï¼š

  å¿½ç•¥

  ï¼Œé€šè¿‡

   

  ```
  keys
  ```

   

  åˆ¤æ–­å·²ç»åˆå§‹åŒ–ã€‚

  - è‹¥æœªåˆå§‹åŒ–ï¼Œæ·»åŠ åˆ° `keys` ä¸­ã€‚

- ç¬¬ 48 è‡³ 75 è¡Œï¼šâ€œåˆ›å»ºâ€æœåŠ¡ Invoker å¯¹è±¡ã€‚

  - ç¬¬ 50 è‡³ 51 è¡Œï¼šè·å¾— `url` å¯¹åº”åœ¨ `localUrlInvokerMap` ç¼“å­˜çš„ Invoker å¯¹è±¡ã€‚
  - ç¬¬ 52 è‡³ 72 è¡Œï¼šä¸åœ¨ç¼“å­˜ä¸­ï¼Œéœ€è¦é‡æ–° refer å¼•ç”¨ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚
    - ç¬¬ 54 è‡³ 60 è¡Œï¼šé€šè¿‡é…ç½®é¡¹ `enable` å’Œ `disable` åˆ¤æ–­ï¼ŒæœåŠ¡æ˜¯å¦å¼€å¯ã€‚
    - ç¬¬ 61 è‡³ 65 è¡Œï¼š è‹¥å¼€å¯ï¼Œåˆ›å»º Invoker å¯¹è±¡ã€‚
      - ã€é‡è¦ã€‘**ç¬¬ 64 è¡Œï¼šè°ƒç”¨ `Protocol$Adaptive#refer(serviceType, url)` æ–¹æ³•ï¼Œå¼•ç”¨æœåŠ¡ï¼Œåˆ›å»ºæœåŠ¡æä¾›è€… Invoker å¯¹è±¡**ã€‚è¯¦ç»†è§£æï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” æœåŠ¡å¼•ç”¨ã€‹](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) å·²ç»æœ‰äº†ã€‚
      - ç¬¬ 64 è¡Œï¼šåˆ›å»º InvokerDelegate å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.7.1 InvokerDelegateã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚
  - ç¬¬ 73 è‡³ 75 è¡Œï¼šåœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ Invoker å¯¹è±¡ï¼Œæ·»åŠ åˆ° `newUrlInvokerMap` ä¸­ã€‚

- ç¬¬ 78 è¡Œï¼šæ¸…ç©º `keys` ã€‚

- ç¬¬ 79 è¡Œï¼šè¿”å›ç»“æœ `newUrlInvokerMap` ã€‚

######## 4.3.3.1.1 mergeUrl

`#mergeUrl(providerUrl)` æ–¹æ³•ï¼Œåˆå¹¶ URL å‚æ•°ï¼Œ**ä¼˜å…ˆçº§**ä¸ºé…ç½®è§„åˆ™ > æœåŠ¡æ¶ˆè´¹è€…é…ç½® > æœåŠ¡æä¾›è€…é…ç½®ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private URL mergeUrl(URL providerUrl) {
 2:     // åˆå¹¶æ¶ˆè´¹ç«¯å‚æ•°
 3:     providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
 4: 
 5:     // åˆå¹¶é…ç½®è§„åˆ™
 6:     List<Configurator> localConfigurators = this.configurators; // local reference
 7:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
 8:         for (Configurator configurator : localConfigurators) {
 9:             providerUrl = configurator.configure(providerUrl);
10:         }
11:     }
12: 
13:     // ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
14:     providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15: 
16:     // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17:     // ä»…åˆå¹¶æä¾›è€…å‚æ•°ï¼Œå› ä¸º directoryUrl ä¸ override åˆå¹¶æ˜¯åœ¨ notify çš„æœ€åï¼Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†
18:     this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters // åˆå¹¶æä¾›è€…å‚æ•°
19: 
20:     // ã€å¿½ç•¥ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹
21:     if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22:             && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23:         //fix by tony.chenl DUBBO-44
24:         String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25:         if (path != null) {
26:             int i = path.indexOf('/');
27:             if (i >= 0) {
28:                 path = path.substring(i + 1);
29:             }
30:             i = path.lastIndexOf(':');
31:             if (i >= 0) {
32:                 path = path.substring(0, i);
33:             }
34:             providerUrl = providerUrl.setPath(path);
35:         }
36:     }
37: 
38:     // è¿”å›æœåŠ¡æä¾›è€… URL
39:     return providerUrl;
40: }
```

- ã€**é‡è¦**ã€‘ç¬¬ 3 è¡Œï¼šè°ƒç”¨ `ClusterUtils#mergeUrl(providerUrl, queryMap)` æ–¹æ³•ï¼Œåˆå¹¶æœåŠ¡æ¶ˆè´¹è€…é…ç½®åˆ° `providerUrl` ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ6. ClusterUtilsã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚
- ç¬¬ 5 è‡³ 11 è¡Œï¼šåˆå¹¶**é…ç½®è§„åˆ™**åˆ° `providerUrl` ä¸­ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
- ç¬¬ 14 è¡Œï¼šè®¾ç½® `providerUrl` ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
- ç¬¬ 18 è¡Œï¼šä»…åˆå¹¶æä¾›è€…å‚æ•°ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self)
- ç¬¬ 20 è‡³ 36 è¡Œï¼šã€**å¿½ç•¥**ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹ã€‚

####### 4.3.3.2 toMethodInvokers

`#toMethodInvokers(Map<String, Invoker<T>> invokersMap)` æ–¹æ³•ï¼Œå°† `invokersMap` è½¬æˆ**ä¸æ–¹æ³•**çš„æ˜ å°„å…³ç³»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
 2:     // åˆ›å»ºæ–°çš„ `methodInvokerMap`
 3:     Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
 4:     // åˆ›å»º Invoker é›†åˆ
 5:     List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
 6:     // According to the methods classification declared by the provider URL, the methods is compatible with the registry to execute the filtered methods
 7:     // æŒ‰æœåŠ¡æä¾›è€… URL æ‰€å£°æ˜çš„ methods åˆ†ç±»ï¼Œå…¼å®¹æ³¨å†Œä¸­å¿ƒæ‰§è¡Œè·¯ç”±è¿‡æ»¤æ‰çš„ methods
 8:     if (invokersMap != null && invokersMap.size() > 0) {
 9:         // å¾ªç¯æ¯ä¸ªæœåŠ¡æä¾›è€… Invoker
10:         for (Invoker<T> invoker : invokersMap.values()) {
11:             String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY); // methods
12:             if (parameter != null && parameter.length() > 0) {
13:                 String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);
14:                 if (methods != null && methods.length > 0) {
15:                     // å¾ªç¯æ¯ä¸ªæ–¹æ³•ï¼ŒæŒ‰ç…§æ–¹æ³•åä¸ºç»´åº¦ï¼Œèšåˆåˆ° `methodInvokerMap` ä¸­
16:                     for (String method : methods) {
17:                         if (method != null && method.length() > 0 && !Constants.ANY_VALUE.equals(method)) { // å½“æœåŠ¡æä¾›è€…çš„æ–¹æ³•ä¸º "*" ï¼Œä»£è¡¨æ³›åŒ–è°ƒç”¨
18:                             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
19:                             if (methodInvokers == null) {
20:                                 methodInvokers = new ArrayList<Invoker<T>>();
21:                                 newMethodInvokerMap.put(method, methodInvokers);
22:                             }
23:                             methodInvokers.add(invoker);
24:                         }
25:                     }
26:                 }
27:             }
28:             // æ·»åŠ åˆ° `invokersList` ä¸­
29:             invokersList.add(invoker);
30:         }
31:     }
32:     // è·¯ç”±å…¨ `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚
33:     List<Invoker<T>> newInvokersList = route(invokersList, null);
34:     // æ·»åŠ  `newInvokersList` åˆ° `newMethodInvokerMap` ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„å…¨é‡ Invoker é›†åˆ
35:     newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
36:     // å¾ªç¯ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
37:     if (serviceMethods != null && serviceMethods.length > 0) {
38:         for (String method : serviceMethods) {
39:             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
40:             if (methodInvokers == null || methodInvokers.isEmpty()) {
41:                 methodInvokers = newInvokersList;
42:             }
43:             newMethodInvokerMap.put(method, route(methodInvokers, method));
44:         }
45:     }
46:     // å¾ªç¯æ’åºæ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸ºä¸å¯å˜
47:     // sort and unmodifiable
48:     for (String method : new HashSet<String>(newMethodInvokerMap.keySet())) {
49:         List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
50:         Collections.sort(methodInvokers, InvokerComparator.getComparator());
51:         newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));
52:     }
53:     return Collections.unmodifiableMap(newMethodInvokerMap);
54: }
```

- ç¬¬ 3 è¡Œï¼š`newMethodInvokerMap` å˜é‡ï¼Œæ–°çš„ `methodInvokerMap` å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚
- ç¬¬ 5 è¡Œï¼šåˆ›å»º Invoker é›†åˆã€‚åœ¨ã€ç¬¬ 29 è¡Œã€‘ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®é™…å°±æ˜¯ `invokersMap` çš„å€¼çš„é›†åˆã€‚
- ç¬¬ 8 è‡³ 31 è¡Œï¼šæŒ‰ç…§æ–¹æ³•åä¸º**ç»´åº¦**( KEY ) ï¼Œèšåˆ**å¯¹åº”çš„ Invoker é›†åˆ**åˆ° `newMethodInvokerMap` ä¸­ã€‚
- ç¬¬ 33 è¡Œï¼šè·¯ç”±å…¨ `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚
- ç¬¬ 35 è¡Œï¼šæ·»åŠ  `newInvokersList` åˆ° `newMethodInvokerMap` ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„**å…¨é‡** Invoker é›†åˆã€‚
- ç¬¬ 36 è‡³ 45 è¡Œï¼š**å¾ªç¯**ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ã€‚
- ç¬¬ 46 è‡³ 53 è¡Œï¼šå¾ªç¯**æ’åº**æ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸º**ä¸å¯å˜**ã€‚

####### 4.3.3.3 toMergeMethodInvokerMap

`#toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap)` ï¼ŒæŒ‰ç…§ **method + group** èšåˆ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private Map<String, List<Invoker<T>>> toMergeMethodInvokerMap(Map<String, List<Invoker<T>>> methodMap) {
 2:     Map<String, List<Invoker<T>>> result = new HashMap<String, List<Invoker<T>>>();
 3:     // å¾ªç¯æ–¹æ³•ï¼ŒæŒ‰ç…§ method + group èšåˆ Invoker é›†åˆ
 4:     for (Map.Entry<String, List<Invoker<T>>> entry : methodMap.entrySet()) {
 5:         String method = entry.getKey();
 6:         List<Invoker<T>> invokers = entry.getValue();
 7:         // æŒ‰ç…§ Group èšåˆ Invoker é›†åˆçš„ç»“æœã€‚å…¶ä¸­ï¼ŒKEYï¼šgroup VALUEï¼šInvoker é›†åˆã€‚
 8:         Map<String, List<Invoker<T>>> groupMap = new HashMap<String, List<Invoker<T>>>();
 9:         // å¾ªç¯ Invoker é›†åˆï¼ŒæŒ‰ç…§ group èšåˆ Invoker é›†åˆ
10:         for (Invoker<T> invoker : invokers) {
11:             String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, "");
12:             List<Invoker<T>> groupInvokers = groupMap.get(group);
13:             if (groupInvokers == null) {
14:                 groupInvokers = new ArrayList<Invoker<T>>();
15:                 groupMap.put(group, groupInvokers);
16:             }
17:             groupInvokers.add(invoker);
18:         }
19:         // å¤§å°ä¸º 1ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ª
20:         if (groupMap.size() == 1) {
21:             result.put(method, groupMap.values().iterator().next());
22:         // å¤§äº 1ï¼Œå°†æ¯ä¸ª Group çš„ Invoker é›†åˆï¼Œåˆ›å»ºæˆ Cluster Invoker å¯¹è±¡ã€‚
23:         } else if (groupMap.size() > 1) {
24:             List<Invoker<T>> groupInvokers = new ArrayList<Invoker<T>>();
25:             for (List<Invoker<T>> groupList : groupMap.values()) {
26:                 groupInvokers.add(cluster.join(new StaticDirectory<T>(groupList)));
27:             }
28:             result.put(method, groupInvokers);
29:         // å¤§å°ä¸º 0 ï¼Œä½¿ç”¨åŸæœ‰å€¼
30:         } else {
31:             result.put(method, invokers);
32:         }
33:     }
34:     return result;
35: }
```

- ç¬¬ 2 è¡Œï¼š`result` å±æ€§ï¼Œ**æ–°çš„** `methodInvokerMap` å­—æ®µï¼Œåé¢ä¼šèµ‹å€¼ç»™å®ƒã€‚

- ç¬¬ 3 ç»ˆ 33 è¡Œï¼š

  å¾ªç¯

  ï¼ŒæŒ‰ç…§

   

  method + group

   

  èšåˆ Invoker é›†åˆã€‚

  - ç¬¬ 8 è¡Œï¼š æŒ‰ç…§ Group èšåˆ Invoker é›†åˆçš„ç»“æœã€‚å…¶ä¸­ï¼Œ**KEY**ï¼šgroup ï¼Œ**VALUE**ï¼šInvoker é›†åˆã€‚

  - ç¬¬ 9 è‡³ 18 è¡Œï¼š**å¾ªç¯** Invoker é›†åˆï¼ŒæŒ‰ç…§ **group** èšåˆ Invoker é›†åˆã€‚

  - ========== ç»“æœ `groupMap` å¤„ç† ==========

  - ç¬¬ 19 è‡³ 21 è¡Œï¼šè‹¥æ•°é‡ä¸º 1 ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªã€‚

  - ç¬¬ 29 è‡³ 32 è¡Œï¼šè‹¥æ•°é‡ä¸º 0 ï¼Œä½¿ç”¨åŸæœ‰å€¼ `invokers` ã€‚å®é™…ä¸Šï¼Œå’Œã€ç¬¬ 19 è‡³ 21 è¡Œã€‘**ç­‰ä»·**ã€‚

  - ç¬¬ 22 è‡³ 28 è¡Œï¼šè‹¥æ•°é‡

    å¤§äº

     

    1 ï¼Œå¾ªç¯

    æ¯ä¸ª

     

    Group çš„ Invoker é›†åˆï¼Œè°ƒç”¨

     

    ```
    Cluster$Adaptive#join(Directory)
    ```

     

    æ–¹æ³•ï¼Œåˆ›å»ºå¯¹åº”çš„ Cluster Invoker å¯¹è±¡ã€‚

    - æˆ‘ä»¬å‘ç°ï¼Œæ­¤å¤„åˆ›å»º **StaticDirectory** å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5. StaticDirectoryã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) ã€‚

é‚£ä¹ˆï¼Œå¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿä¸ºä»€ä¹ˆè¦æŒ‰ç…§ **group** è¿›è¡Œèšåˆï¼Œç›´æ¥è°ƒç”¨ä¸å¯ä»¥ä¹ˆï¼Ÿè®©æˆ‘ä»¬æ¥æ‰“å¼€ `ProtocolRegistry#refer(Class<T> type, URL url)` æ–¹æ³•ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

[![refer](http://static.iocoder.cn/images/Dubbo/2019_04_10/04.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/04.png)refer

- å½“å¼•ç”¨å¤šä¸ªæœåŠ¡åˆ†ç»„æ—¶ï¼Œä¼š**è‡ªåŠ¨**ä½¿ç”¨åˆ°**åˆ†ç»„èšåˆ**çš„ç‰¹æ€§ã€‚é‚£ä¹ˆä¹‹å MergeableCluster ä¼šæ€ä¹ˆåšå‘¢ï¼Ÿè¯¦ç»†è§£æï¼Œè§åæ–‡ ğŸ˜ˆã€‚

####### 4.3.3.4 destroyUnusedInvokers

`#destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap)` æ–¹æ³•ï¼Œ**é”€æ¯**ä¸å†ä½¿ç”¨çš„ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private void destroyUnusedInvokers(Map<String, Invoker<T>> oldUrlInvokerMap, Map<String, Invoker<T>> newUrlInvokerMap) {
    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œç›®å‰ä¸å­˜åœ¨è¿™ä¸ªæƒ…å†µ
    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {
        // é”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker
        destroyAllInvokers();
        return;
    }
    // check deleted invoker
    // å¯¹æ¯”æ–°è€é›†åˆï¼Œè®¡ç®—éœ€è¦é”€æ¯çš„ Invoker é›†åˆ
    List<String> deleted = null;
    if (oldUrlInvokerMap != null) {
        Collection<Invoker<T>> newInvokers = newUrlInvokerMap.values();
        for (Map.Entry<String, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {
            // è‹¥ä¸å­˜åœ¨ï¼Œæ·»åŠ åˆ° `deleted` ä¸­
            if (!newInvokers.contains(entry.getValue())) {
                if (deleted == null) {
                    deleted = new ArrayList<String>();
                }
                deleted.add(entry.getKey());
            }
        }
    }

    // è‹¥æœ‰éœ€è¦é”€æ¯çš„ Invoker ï¼Œåˆ™è¿›è¡Œé”€æ¯
    if (deleted != null) {
        for (String url : deleted) {
            if (url != null) {
                // ç§»é™¤å‡º `urlInvokerMap`
                Invoker<T> invoker = oldUrlInvokerMap.remove(url);
                if (invoker != null) {
                    try {
                        // é”€æ¯ Invoker
                        invoker.destroy();
                        if (logger.isDebugEnabled()) {
                            logger.debug("destroy invoker[" + invoker.getUrl() + "] success. ");
                        }
                    } catch (Exception e) {
                        logger.warn("destroy invoker[" + invoker.getUrl() + "] failed. " + e.getMessage(), e);
                    }
                }
            }
        }
    }
}
```

####### 4.3.3.5 destroyAllInvokers

`#destroyAllInvokers()` æ–¹æ³•ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private void destroyAllInvokers() {
    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
    if (localUrlInvokerMap != null) {
        // å¾ªç¯ urlInvokerMap ï¼Œé”€æ¯æ‰€æœ‰æœåŠ¡æä¾›è€… Invoker
        for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
            try {
                invoker.destroy();
            } catch (Throwable t) {
                logger.warn("Failed to destroy service " + serviceKey + " to provider " + invoker.getUrl(), t);
            }
        }
        // urlInvokerMap æ¸…ç©º
        localUrlInvokerMap.clear();
    }
    // methodInvokerMap ç½®ç©º
    methodInvokerMap = null;
}
```

#### 4.4 doList

`#doList(Invocation)` **å®ç°**æ–¹æ³•ï¼Œè·å¾—å¯¹åº”çš„ Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public List<Invoker<T>> doList(Invocation invocation) {
 3:     if (forbidden) {
 4:         // 1. No service provider 2. Service providers are disabled
 5:         throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,
 6:             "No provider available from registry " + getUrl().getAddress() + " for service " + getConsumerUrl().getServiceKey() + " on consumer " +  NetUtils.getLocalHost()
 7:                     + " use dubbo version " + Version.getVersion() + ", please check status of providers(disabled, not registered or in blacklist).");
 8:     }
 9:     List<Invoker<T>> invokers = null;
10:     Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap; // local reference
11:     // è·å¾— Invoker é›†åˆ
12:     if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {
13:         // è·å¾—æ–¹æ³•åã€æ–¹æ³•å‚æ•°
14:         String methodName = RpcUtils.getMethodName(invocation);
15:         Object[] args = RpcUtils.getArguments(invocation);
16:         // ã€ç¬¬ä¸€ã€‘å¯æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°æšä¸¾è·¯ç”±
17:         if (args != null && args.length > 0 && args[0] != null
18:                 && (args[0] instanceof String || args[0].getClass().isEnum())) {
19: //            invokers = localMethodInvokerMap.get(methodName + "." + args[0]); // The routing can be enumerated according to the first parameter
20:             invokers = localMethodInvokerMap.get(methodName + args[0]); // The routing can be enumerated according to the first parameter
21:         }
22:         // ã€ç¬¬äºŒã€‘æ ¹æ®æ–¹æ³•åè·å¾— Invoker é›†åˆ
23:         if (invokers == null) {
24:             invokers = localMethodInvokerMap.get(methodName);
25:         }
26:         // ã€ç¬¬ä¸‰ã€‘ä½¿ç”¨å…¨é‡ Invoker é›†åˆã€‚ä¾‹å¦‚ï¼Œ`#$echo(name)` ï¼Œå›å£°æ–¹æ³•
27:         if (invokers == null) {
28:             invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);
29:         }
30:         // ã€ç¬¬å››ã€‘ä½¿ç”¨ `methodInvokerMap` ç¬¬ä¸€ä¸ª Invoker é›†åˆã€‚é˜²å¾¡æ€§ç¼–ç¨‹ã€‚
31:         if (invokers == null) {
32:             Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();
33:             if (iterator.hasNext()) {
34:                 invokers = iterator.next();
35:             }
36:         }
37:     }
38:     return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;
39: }
```

- é€šè¿‡å››ç§æ–¹å¼ï¼Œä» `methodInvokerMap` ä¸­ï¼Œè·å¾—å¯¹åº”çš„ Invoker é›†åˆã€‚

- ç¬¬ä¸€ç§ï¼Œå¯æ ¹æ®**ç¬¬ä¸€ä¸ªå‚æ•°**æšä¸¾è·¯ç”±ã€‚è¿™æ˜¯ä¸ªéå¸¸å°ä¼—çš„åœºæ™¯ï¼Œèƒ–å‹ä¸å¿…ç†è§£ã€‚ä¾‹å­å¦‚ä¸‹ï¼š

  ```
  // DemoService æ¥å£å®šä¹‰
  public interface DemoService {
      void hello(String name);
  
      void hello01(String name);
  
      void hello02(String name);
  }
  
  // æ¶ˆè´¹è€…è°ƒç”¨
  DemoService demoService = (DemoService) context.getBean("demoService");
  demoService.hello("01");
  ```

  - é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œè°ƒç”¨åˆ°çš„æœåŠ¡æä¾›è€…çš„ `DemoServiceImpl#hello01(name)` æ–¹æ³•ã€‚

  - å¦‚æœä½¿ç”¨è¯¥**ç‰¹æ€§**ï¼Œæ³¨æ„é¿å…å‡ºç°**æ— å…³**çš„å‡ ä¸ªæ–¹æ³•ï¼Œä¾‹å¦‚ `#hello(name)` å’Œ `#hello01(name)` æ˜¯æ¯«æ— å…³ç³»çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œè€Œæˆ‘çœŸçš„æƒ³è°ƒç”¨ `#hello(name)` æ–¹æ³•ï¼Œç»“æœè°ƒç”¨åˆ°äº† `#hello01(name)` æ–¹æ³•ã€‚

  - å¦‚ä¸‹æ˜¯ Dubbo Commiter **è¯£æ** çš„è§£æƒ‘ï¼Œéå¸¸æ„Ÿè°¢ã€‚

    > åŠ¨æ€çš„æ–¹æ³•åæœ¬èº«å°±æ˜¯æ¥å£ä¸­å·²ç»å®šä¹‰çš„
    >
    > ä¸¾ä¸ªä¾‹å­å§å€Ÿå£å®šä¹‰äº† method, method1,method2ï¼Œ å¦‚æœæˆ‘å‘èµ·rpcè°ƒç”¨method(1, 2, 3), è¿™ä¸ªæ—¶å€™ä¼šå»æŸ¥æ‰¾æ–¹æ³•method1çš„invokersï¼Œ å¦‚æœæˆ‘è¿™ä¸ªæ—¶å€™å‘èµ·rpc method(2, 1, 3), è¿™ä¸ªæ—¶å€™ä¼šå»æŸ¥æ‰¾æ–¹æ³•method2çš„invokersï¼Œ ç„¶åè°ƒç”¨invokersçš„methodæ–¹æ³•

    - å¦å¤–ï¼Œç»è¿‡æ²Ÿé€šï¼Œã€ç¬¬ 19 è¡Œã€‘çš„ `"."` æ˜¯ä¸ª BUG ï¼Œæ–¹æ³•é‡Œä¸èƒ½åŒ…å«è¯¥å­—ç¬¦ï¼Œå› æ­¤ï¼Œç¬”è€…æ”¹æˆäº†ã€ç¬¬ 20 è¡Œã€‘ï¼Œå»æ‰äº† `"."` è¿›è¡Œæµ‹è¯•ã€‚

- ç¬¬äºŒç§ï¼Œæ ¹æ®**æ–¹æ³•å**è·å¾— Invoker é›†åˆã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œéƒ½èƒ½åŒ¹é…åˆ°ã€‚

- ç¬¬ä¸‰ç§ï¼Œä½¿ç”¨å…¨é‡ Invoker é›†åˆã€‚ä¾‹å¦‚ï¼Œ`#$echo(name)` å›å£°æ–¹æ³•ã€‚

- ç¬¬å››ç§ï¼Œä½¿ç”¨ `methodInvokerMap` ç¬¬ä¸€ä¸ª Invoker é›†åˆã€‚é˜²å¾¡æ€§ç¼–ç¨‹ã€‚

#### 4.5 isAvailable

```
@Override
public boolean isAvailable() {
    // è‹¥å·²é”€æ¯ï¼Œè¿”å›ä¸å¯ç”¨
    if (isDestroyed()) {
        return false;
    }
    // ä»»æ„ä¸€ä¸ª Invoker å¯ç”¨ï¼Œåˆ™è¿”å›å¯ç”¨
    Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap;
    if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {
        for (Invoker<T> invoker : new ArrayList<Invoker<T>>(localUrlInvokerMap.values())) {
            if (invoker.isAvailable()) {
                return true;
            }
        }
    }
    return false;
}
```

#### 4.6 destroy

```
@Override
public void destroy() {
    if (isDestroyed()) {
        return;
    }
    // å–æ¶ˆè®¢é˜…
    // unsubscribe.
    try {
        if (getConsumerUrl() != null && registry != null && registry.isAvailable()) {
            registry.unsubscribe(getConsumerUrl(), this);
        }
    } catch (Throwable t) {
        logger.warn("unexpeced error when unsubscribe service " + serviceKey + "from registry" + registry.getUrl(), t);
    }
    // æ ‡è®°å·²ç»é”€æ¯
    super.destroy(); // must be executed after unsubscribing
    // é”€æ¯æ‰€æœ‰ Invoker 
    try {
        destroyAllInvokers();
    } catch (Throwable t) {
        logger.warn("Failed to destroy service " + serviceKey, t);
    }
}
```

## 5. StaticDirectory

`com.alibaba.dubbo.rpc.cluster.directory.StaticDirectory` ï¼Œå®ç° AbstractDirectory æŠ½è±¡ç±»ï¼Œ**é™æ€** Directory å®ç°ç±»ã€‚é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå°†ä¼ å…¥çš„ `invokers` é›†åˆï¼Œå°è£…æˆé™æ€çš„ Directory å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class StaticDirectory<T> extends AbstractDirectory<T> {

    /**
     * Invoker é›†åˆ
     */
    private final List<Invoker<T>> invokers;

    public StaticDirectory(List<Invoker<T>> invokers) {
        this(null, invokers, null);
    }

    public StaticDirectory(List<Invoker<T>> invokers, List<Router> routers) {
        this(null, invokers, routers);
    }

    public StaticDirectory(URL url, List<Invoker<T>> invokers) {
        this(url, invokers, null);
    }

    public StaticDirectory(URL url, List<Invoker<T>> invokers, List<Router> routers) {
        // é»˜è®¤ä½¿ç”¨ `url` å‚æ•°ã€‚å½“å®ƒä¸ºç©ºæ—¶ï¼Œä½¿ç”¨ `invokers[0].url` ã€‚
        super(url == null && invokers != null && !invokers.isEmpty() ? invokers.get(0).getUrl() : url, routers);
        if (invokers == null || invokers.isEmpty()) {
            throw new IllegalArgumentException("invokers == null");
        }
        this.invokers = invokers;
    }

    @Override
    public Class<T> getInterface() {
        return invokers.get(0).getInterface();
    }

    @Override
    public boolean isAvailable() {
        // è‹¥å·²ç»é”€æ¯ï¼Œåˆ™ä¸å¯ç”¨
        if (isDestroyed()) {
            return false;
        }
        // ä»»ä¸€ä¸€ä¸ª Invoker å¯ç”¨ï¼Œåˆ™ä¸ºå¯ç”¨
        for (Invoker<T> invoker : invokers) {
            if (invoker.isAvailable()) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void destroy() {
        // è‹¥å·²ç»é”€æ¯ï¼Œ è·³è¿‡
        if (isDestroyed()) {
            return;
        }
        // é”€æ¯
        super.destroy();
        // é”€æ¯æ¯ä¸ª Invoker
        for (Invoker<T> invoker : invokers) {
            invoker.destroy();
        }
        // æ¸…ç©º Invoker é›†åˆ
        invokers.clear();
    }

    @Override
    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
        return invokers;
    }

}
```

- ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹è‡ªå·±çœ‹ä¸‹ã€‚

------

é™¤äº†åœ¨ [ã€Œ4.3.3.3 toMergeMethodInvokerMapã€](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory/#) æ–¹æ³•ä¸­ï¼Œä½¿ç”¨åˆ°äº† StaticDirectory å¯¹è±¡ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹ `ReferenceConfig#createProxy(Map<String, String> map)` çš„ä½¿ç”¨ï¼Œä»£ç å¦‚ä¸‹å›¾ï¼š

[![createProxy](http://static.iocoder.cn/images/Dubbo/2019_04_10/05.png)](http://static.iocoder.cn/images/Dubbo/2019_04_10/05.png)createProxy

- ç¬¬ 522 è‡³ 527 è¡Œï¼šå½“ `registryURL` éç©ºæ—¶ï¼Œæ„å‘³ç€**æœ‰æ³¨å†Œä¸­å¿ƒ**ï¼Œä½¿ç”¨ `cluster=available` é›†ç¾¤æ–¹å¼ï¼Œå¹¶è°ƒç”¨ `Cluster$Adaptive#join(StaticDirectory)` æ–¹æ³•ï¼Œåˆ›å»ºå¯¹åº”çš„ Cluster Invoker å¯¹è±¡ã€‚è¿™æ„å‘³ç€ï¼ŒæœåŠ¡è°ƒç”¨æ—¶ï¼Œå› ä¸ºä½¿ç”¨çš„æ˜¯ `cluster=available` ï¼Œ**ä»…è°ƒç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„ Invoker å¯¹è±¡**ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥åšä¸€ä¸ª YY ï¼š

  - ç›®å‰æˆ‘ä»¬æœ‰ A , B ä¸¤ä¸ªæœºæˆ¿ï¼Œåˆ†åˆ«å¯¹åº” zk01 é›†ç¾¤ï¼Œzk02 é›†ç¾¤ã€‚è¿™ä¸¤ä¸ª zk é›†ç¾¤**ä¸äº’é€š** ã€‚

  - A , B æœºæˆ¿ï¼Œåˆ†åˆ«éƒ¨ç½²äº† **User æœåŠ¡æä¾›è€…**ï¼Œä»…æ³¨å†Œåˆ°è‡ªå·±æœºæˆ¿çš„ zk é›†ç¾¤ã€‚

  - A , B æœºæˆ¿ï¼Œéƒ¨ç½²äº†å¯¹åº”çš„ **User æœåŠ¡æ¶ˆè´¹**ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬å¸Œæœ›ä¼˜å…ˆè°ƒç”¨æœ¬æœºæˆ¿ã€‚å½“æœ¬æœºæˆ¿ **User æœåŠ¡æä¾›è€…**å…¨æŒ‚çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨å¦å¤–ä¸€ä¸ªæœºæˆ¿ï¼Œè¯¥å¦‚ä½•é…ç½®å‘¢ï¼Ÿ

    ```
    // A æœºæˆ¿
    <dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk01,zk02" />
    // B æœºæˆ¿
    <dubbo:reference interface="com.alibaba.dubbo.demo.UserService" registry="zk02,zk01" />
    ```

    - å³åœ¨ `"registry"` é…ç½®é¡¹ä¸­ï¼Œå°†è‡ªå·±çš„ zk é›†ç¾¤æ”¾åœ¨å‰é¢ã€‚
    - å½“ç„¶ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå¾ˆå°‘ä¼šå‡ºç°ä¸€ä¸ªæœºæˆ¿æœåŠ¡æä¾›è€…å…¨æŒ‚ï¼Œzk é›†ç¾¤è¿˜å­˜æ´»ç€ã€‚

## 6. ClusterUtils

`com.alibaba.dubbo.rpc.cluster.support.ClusterUtils` ï¼ŒCluster å·¥å…·ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: public class ClusterUtils {
 2:
 3:     private ClusterUtils() {
 4:     }
 5:
 6:     public static URL mergeUrl(URL remoteUrl, Map<String, String> localMap) {
 7:         // åˆå¹¶é…ç½® Map ç»“æœ
 8:         Map<String, String> map = new HashMap<String, String>();
 9:         // è¿œç¨‹é…ç½® Map ç»“æœ
10:         Map<String, String> remoteMap = remoteUrl.getParameters();
11:
12:         // æ·»åŠ  `remoteMap` åˆ° `map` ä¸­ï¼Œå¹¶ç§»é™¤ä¸å¿…è¦çš„é…ç½®
13:         if (remoteMap != null && remoteMap.size() > 0) {
14:             map.putAll(remoteMap);
15:
16:             // Remove configurations from provider, some items should be affected by provider. çº¿ç¨‹æ± é…ç½®ä¸ä½¿ç”¨æä¾›è€…çš„
17:             map.remove(Constants.THREAD_NAME_KEY);
18:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREAD_NAME_KEY);
19:
20:             map.remove(Constants.THREADPOOL_KEY);
21:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADPOOL_KEY);
22:
23:             map.remove(Constants.CORE_THREADS_KEY);
24:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.CORE_THREADS_KEY);
25:
26:             map.remove(Constants.THREADS_KEY);
27:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.THREADS_KEY);
28:
29:             map.remove(Constants.QUEUES_KEY);
30:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.QUEUES_KEY);
31:
32:             map.remove(Constants.ALIVE_KEY);
33:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.ALIVE_KEY);
34:
35:             map.remove(Constants.TRANSPORTER_KEY);
36:             map.remove(Constants.DEFAULT_KEY_PREFIX + Constants.TRANSPORTER_KEY);
37:         }
38:         // æ·»åŠ  `localMap` åˆ° `map` ä¸­
39:         if (localMap != null && localMap.size() > 0) {
40:             map.putAll(localMap);
41:         }
42:
43:         // æ·»åŠ æŒ‡å®šçš„ `remoteMap` çš„é…ç½®é¡¹åˆ° `map` ä¸­ï¼Œå› ä¸ºä¸Šé¢è¢« `localMap` è¦†ç›–äº†ã€‚
44:         if (remoteMap != null && remoteMap.size() > 0) {
45:             // Use version passed from provider side
46:             String dubbo = remoteMap.get(Constants.DUBBO_VERSION_KEY);
47:             if (dubbo != null && dubbo.length() > 0) {
48:                 map.put(Constants.DUBBO_VERSION_KEY, dubbo);
49:             }
50:             String version = remoteMap.get(Constants.VERSION_KEY);
51:             if (version != null && version.length() > 0) {
52:                 map.put(Constants.VERSION_KEY, version);
53:             }
54:             String group = remoteMap.get(Constants.GROUP_KEY);
55:             if (group != null && group.length() > 0) {
56:                 map.put(Constants.GROUP_KEY, group);
57:             }
58:             String methods = remoteMap.get(Constants.METHODS_KEY);
59:             if (methods != null && methods.length() > 0) {
60:                 map.put(Constants.METHODS_KEY, methods);
61:             }
62:             // Reserve timestamp of provider url. ä¿ç•™ provider çš„å¯åŠ¨ timestamp
63:             String remoteTimestamp = remoteMap.get(Constants.TIMESTAMP_KEY);
64:             if (remoteTimestamp != null && remoteTimestamp.length() > 0) {
65:                 map.put(Constants.REMOTE_TIMESTAMP_KEY, remoteMap.get(Constants.TIMESTAMP_KEY));
66:             }
67:             // Combine filters and listeners on Provider and Consumer åˆå¹¶ filter å’Œ listener
68:             String remoteFilter = remoteMap.get(Constants.REFERENCE_FILTER_KEY);
69:             String localFilter = localMap.get(Constants.REFERENCE_FILTER_KEY);
70:             if (remoteFilter != null && remoteFilter.length() > 0
71:                     && localFilter != null && localFilter.length() > 0) {
72:                 localMap.put(Constants.REFERENCE_FILTER_KEY, remoteFilter + "," + localFilter);
73:             }
74:             String remoteListener = remoteMap.get(Constants.INVOKER_LISTENER_KEY);
75:             String localListener = localMap.get(Constants.INVOKER_LISTENER_KEY);
76:             if (remoteListener != null && remoteListener.length() > 0
77:                     && localListener != null && localListener.length() > 0) {
78:                 localMap.put(Constants.INVOKER_LISTENER_KEY, remoteListener + "," + localListener);
79:             }
80:         }
81:
82:         // æ¸…ç©ºåŸæœ‰é…ç½®ï¼Œä½¿ç”¨åˆå¹¶çš„é…ç½®è¦†ç›–
83:         return remoteUrl.clearParameters().addParameters(map);
84:     }
85:
86: }
```

- å°† `localMap` å’Œ `remoteUrl.parameters` **åˆå¹¶**æˆ `map` ï¼Œå¤§å¤šæ•°ä»¥**å‰è€…**ä¸ºä¸»ã€ç¬¬ 12 è‡³ 41 è¡Œã€‘ï¼Œéƒ¨åˆ†**æŒ‡å®š**ä»¥åè€…ä¸ºä¸»ã€ç¬¬ 43 è‡³ 80 è¡Œã€‘ã€‚
- å°†åˆå¹¶çš„ `map` çš„ç»“æœï¼Œ**è¦†ç›–**è®¾ç½®åˆ° `remoteUrl` ä¸­ã€‚

# 4ã€LoadBalance 

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸‰ï¼‰ä¹‹ Directory å®ç°ã€‹](http://www.iocoder.cn.dubbo/cluster-3-impl-directory/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `loadbalance` åŒ…ï¼Œ**å„ç§ LoadBalance å®ç°ç±»**ã€‚

LoadBalance å­ç±»å¦‚ä¸‹å›¾ï¼š

[![LoadBalance å­ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_15/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_15/01.png)LoadBalance å­ç±»

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç›®å‰ä¸€å…±æœ‰å››ä¸ªå­ç±»ï¼Œæ„å‘³ç€**å†…ç½®**äº†å››ç§è´Ÿè½½å‡è¡¡çš„é€‰æ‹©ç®—æ³•ã€‚

> è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è´Ÿè½½å‡è¡¡ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html) æ–‡æ¡£ã€‚

## 2. LoadBalance

`com.alibaba.dubbo.rpc.cluster.LoadBalance` ï¼Œ LoadBalance **æ¥å£**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@SPI(RandomLoadBalance.NAME)
public interface LoadBalance {

    /**
     * select one invoker in list.
     *
     * ä» Invoker é›†åˆä¸­ï¼Œé€‰æ‹©ä¸€ä¸ª
     *
     * @param invokers   invokers.
     * @param url        refer url
     * @param invocation invocation.
     * @return selected invoker.
     */
    @Adaptive("loadbalance")
    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;

}
```

- `@SPI(RandomLoadBalance.NAME)` æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œé»˜è®¤ä¸º `"random"` ï¼Œå³**éšæœº**ã€‚
- `@Adaptive` æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Cluster å®ç°ï¼Œä½¿ç”¨ `URL.loadbalance` å±æ€§ã€‚
- `#selectList<Invoker<T>>, URL, Invocation)` æ¥å£æ–¹æ³•ï¼Œä» Invoker é›†åˆä¸­ï¼Œé€‰æ‹©ä¸€ä¸ªã€‚

## 3. AbstractLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance` ï¼Œå®ç° LoadBalance æ¥å£ï¼ŒLoadBalance æŠ½è±¡ç±»ï¼Œæä¾›äº†æƒé‡è®¡ç®—çš„åŠŸèƒ½ã€‚

#### 3.1 select

`#select(List<Invoker<T>>, URL, Invocation)` **å®ç°**æ–¹æ³•ï¼Œé»˜è®¤åªæœ‰ä¸€ä¸ª Invoker æ—¶ï¼Œç›´æ¥é€‰æ‹©è¿”å›ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
    @Override
public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    if (invokers == null || invokers.isEmpty()) {
        return null;
    }
    if (invokers.size() == 1) {
        return invokers.get(0);
    }
    return doSelect(invokers, url, invocation);
}
```

- å­ç±»å®ç° `#doSelect(List<Invoker<T>>, URL, Invocation)` **æŠ½è±¡**æ–¹æ³•ï¼Œæä¾›è‡ªå®šä¹‰çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚

  ```
  protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);
  ```

#### 3.2 getWeight

```
protected int getWeight(Invoker<?> invoker, Invocation invocation) {
    // è·å¾— weight é…ç½®ï¼Œå³æœåŠ¡æƒé‡ã€‚é»˜è®¤ä¸º 100
    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
    if (weight > 0) {
        long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);
        if (timestamp > 0L) {
            // è·å¾—å¯åŠ¨æ€»æ—¶é•¿
            int uptime = (int) (System.currentTimeMillis() - timestamp);
            // è·å¾—é¢„çƒ­éœ€è¦æ€»æ—¶é•¿ã€‚é»˜è®¤ä¸º 10 * 60 * 1000 = 10 åˆ†é’Ÿ
            int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);
            // å¤„äºé¢„çƒ­ä¸­ï¼Œè®¡ç®—å½“å‰çš„æƒé‡
            if (uptime > 0 && uptime < warmup) {
                weight = calculateWarmupWeight(uptime, warmup, weight);
            }
        }
    }
    return weight;
}
```

- è€ƒè™‘åˆ° JVM è‡ªèº«ä¼šæœ‰**é¢„çƒ­**çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æœåŠ¡æä¾›è€…ä¸€å¯åŠ¨å°±ç›´æ¥æ‰¿æ‹… 100% çš„æµé‡ï¼Œå¯èƒ½ä¼šå‡ºç°å¾ˆåƒåŠ›çš„æƒ…å†µã€‚å› æ­¤æƒé‡çš„è®¡ç®—ï¼Œ**é»˜è®¤è‡ªå¸¦äº†é¢„çƒ­çš„è¿‡ç¨‹**ã€‚`#calculateWarmupWeight(uptime, warmup, weight)` **é™æ€**æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  static int calculateWarmupWeight(int uptime, int warmup, int weight) {
      // è®¡ç®—æƒé‡
      int ww = (int) ((float) uptime / ((float) warmup / (float) weight));
      // æƒé‡èŒƒå›´ä¸º [0, weight] ä¹‹é—´
      return ww < 1 ? 1 : (ww > weight ? weight : ww);
  }
  ```

  - è®¡ç®—æƒé‡çš„ä»£ç è¿™ä¹ˆå†™çœ‹èµ·æ¥æ¯”è¾ƒâ€œç»•â€ï¼Œæˆ‘ä»¬æ¥ä¿®æ”¹æˆ `(uptime / warmup) * weight` ï¼Œæ˜¯å¦å°±å¥½ç†è§£å¤šäº†ï¼Œç›¸å½“äº**è¿›åº¦ç™¾åˆ†æ¯” \* æƒé‡**ã€‚

  - å¦‚ä¸‹æ˜¯æˆ‘é£å“¥ä¸¾çš„ä¸€ä¸ªä¾‹å­ï¼Œæ„Ÿè§‰éå¸¸èµã€‚

    > æ ¹æ®calculateWarmupWeight()æ–¹æ³•å®ç°å¯çŸ¥ï¼Œéšç€providerçš„å¯åŠ¨æ—¶é—´è¶Šæ¥è¶Šé•¿ï¼Œæ…¢æ…¢æå‡æƒé‡ç›´åˆ°weightï¼Œä¸”æƒé‡æœ€å°å€¼ä¸º1ï¼Œæ‰€ä»¥ï¼š
    >
    > - å¦‚æœ provider è¿è¡Œäº† 1 åˆ†é’Ÿï¼Œé‚£ä¹ˆ weight ä¸º 10ï¼Œå³åªæœ‰æœ€ç»ˆéœ€è¦æ‰¿æ‹…çš„ 10% æµé‡ï¼›
    > - å¦‚æœ provider è¿è¡Œäº† 2 åˆ†é’Ÿï¼Œé‚£ä¹ˆ weight ä¸º 20ï¼Œå³åªæœ‰æœ€ç»ˆéœ€è¦æ‰¿æ‹…çš„ 20% æµé‡ï¼›
    > - å¦‚æœ provider è¿è¡Œäº† 5 åˆ†é’Ÿï¼Œé‚£ä¹ˆ weight ä¸º 50ï¼Œå³åªæœ‰æœ€ç»ˆéœ€è¦æ‰¿æ‹…çš„ 50% æµé‡ï¼›
    >   â€¦ â€¦
    > - å¦‚æœ provider è¿è¡Œäº† 10 åˆ†é’Ÿï¼Œé‚£ä¹ˆ weight ä¸º 100ï¼Œå³åªæœ‰æœ€ç»ˆéœ€è¦æ‰¿æ‹…çš„ 100% æµé‡ï¼›

- `"weight"` é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º 100 ã€‚

- `"warmup"` é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º 10 `*` 60 `*` 1000 = 10 åˆ†é’Ÿã€‚

## 4. RandomLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance` ï¼Œå®ç° AbstractLoadBalance æŠ½è±¡ç±»ï¼Œ**éšæœº**ï¼ŒæŒ‰æƒé‡è®¾ç½®éšæœºæ¦‚ç‡ã€‚

> åœ¨ä¸€ä¸ªæˆªé¢ä¸Šç¢°æ’çš„æ¦‚ç‡é«˜ï¼Œä½†è°ƒç”¨é‡è¶Šå¤§åˆ†å¸ƒè¶Šå‡åŒ€ï¼Œè€Œä¸”æŒ‰æ¦‚ç‡ä½¿ç”¨æƒé‡åä¹Ÿæ¯”è¾ƒå‡åŒ€ï¼Œæœ‰åˆ©äºåŠ¨æ€è°ƒæ•´æä¾›è€…æƒé‡ã€‚

```
 1: public class RandomLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "random";
 4: 
 5:     private final Random random = new Random();
 6: 
 7:     @Override
 8:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
 9:         int length = invokers.size(); // Number of invokers
10:         int totalWeight = 0; // The sum of weights
11:         boolean sameWeight = true; // Every invoker has the same weight?
12:         // è®¡ç®—æ€»æƒé™
13:         for (int i = 0; i < length; i++) {
14:             int weight = getWeight(invokers.get(i), invocation); // è·å¾—æƒé‡
15:             totalWeight += weight; // Sum
16:             if (sameWeight && i > 0 && weight != getWeight(invokers.get(i - 1), invocation)) {
17:                 sameWeight = false;
18:             }
19:         }
20:         // æƒé‡ä¸ç›¸ç­‰ï¼Œéšæœºåï¼Œåˆ¤æ–­åœ¨å“ªä¸ª Invoker çš„æƒé‡åŒºé—´ä¸­
21:         if (totalWeight > 0 && !sameWeight) {
22:             // éšæœº
23:             // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.
24:             int offset = random.nextInt(totalWeight);
25:             // Return a invoker based on the random value.
26:             // åŒºé—´åˆ¤æ–­
27:             for (Invoker<T> invoker : invokers) {
28:                 offset -= getWeight(invoker, invocation);
29:                 if (offset < 0) {
30:                     return invoker;
31:                 }
32:             }
33:         }
34:         // æƒé‡ç›¸ç­‰ï¼Œå¹³å‡éšæœº
35:         // If all invokers have the same weight value or totalWeight=0, return evenly.
36:         return invokers.get(random.nextInt(length));
37:     }
38: 
39: }
```

- ç¬¬ 12 è‡³ 19 è¡Œï¼šè®¡ç®—**æ€»**æƒé‡ï¼Œå¹¶åˆ¤æ–­æ‰€æœ‰ Invoker æ˜¯å¦**ç›¸åŒ**æƒé‡ã€‚
- ç¬¬ 20 è‡³ 33 è¡Œï¼šæƒé‡**ä¸ç›¸ç­‰**ï¼Œéšæœºæƒé‡åï¼Œåˆ¤æ–­åœ¨å“ªä¸ª Invoker çš„æƒé‡åŒºé—´ä¸­ã€‚
- ç¬¬ 36 è¡Œï¼šæƒé‡**ç›¸ç­‰**ï¼Œç›´æ¥éšæœºé€‰æ‹© Invoker å³å¯ã€‚ç›¸ç­‰äºå¯¹ã€ç¬¬ 20 è‡³ 33 è¡Œã€‘çš„**ä¼˜åŒ–**ã€‚

**ç®—æ³•è¯´æ˜**

> FROM é£å“¥çš„ [ã€Šdubboæºç -è´Ÿè½½å‡è¡¡ã€‹](https://www.jianshu.com/p/10c30d7b8b6a)
>
> å‡å®šæœ‰3å°dubbo provider:
>
> - 10.0.0.1:20884, weight=2
> - 10.0.0.1:20886, weight=3
> - 10.0.0.1:20888, weight=4
>
> éšæœºç®—æ³•çš„å®ç°ï¼š
> totalWeight=9;
>
> - å‡è®¾offset=1ï¼ˆå³random.nextInt(9)=1ï¼‰
>   1-2=-1<0ï¼Ÿæ˜¯ï¼Œæ‰€ä»¥é€‰ä¸­ 10.0.0.1:20884, weight=2
> - å‡è®¾offset=4ï¼ˆå³random.nextInt(9)=4ï¼‰
>   4-2=2<0ï¼Ÿå¦ï¼Œè¿™æ—¶å€™offset=2ï¼Œ 2-3<0ï¼Ÿæ˜¯ï¼Œæ‰€ä»¥é€‰ä¸­ 10.0.0.1:20886, weight=3
> - å‡è®¾offset=7ï¼ˆå³random.nextInt(9)=7ï¼‰
>   7-2=5<0ï¼Ÿå¦ï¼Œè¿™æ—¶å€™offset=5ï¼Œ 5-3=2<0ï¼Ÿå¦ï¼Œè¿™æ—¶å€™offset=2ï¼Œ 2-4<0ï¼Ÿæ˜¯ï¼Œæ‰€ä»¥é€‰ä¸­ 10.0.0.1:20888, weight=4

## 5. RoundRobinLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance` ï¼Œå®ç° AbstractLoadBalance æŠ½è±¡ç±»ï¼Œ**è½®å¾ª**ï¼ŒæŒ‰å…¬çº¦åçš„æƒé‡è®¾ç½®è½®å¾ªæ¯”ç‡ã€‚

> å­˜åœ¨æ…¢çš„æä¾›è€…ç´¯ç§¯è¯·æ±‚çš„é—®é¢˜ï¼Œæ¯”å¦‚ï¼šç¬¬äºŒå°æœºå™¨å¾ˆæ…¢ï¼Œä½†æ²¡æŒ‚ï¼Œå½“è¯·æ±‚è°ƒåˆ°ç¬¬äºŒå°æ—¶å°±å¡åœ¨é‚£ï¼Œä¹…è€Œä¹…ä¹‹ï¼Œæ‰€æœ‰è¯·æ±‚éƒ½å¡åœ¨è°ƒåˆ°ç¬¬äºŒå°ä¸Šã€‚

```
 1: public class RoundRobinLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "roundrobin";
 4: 
 5:     /**
 6:      * æœåŠ¡æ–¹æ³•ä¸è®¡æ•°å™¨çš„æ˜ å°„
 7:      *
 8:      * KEYï¼šserviceKey + "." + methodName
 9:      */
10:     private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();
11: 
12:     @Override
13:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
14:         String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
15:         int length = invokers.size(); // Number of invokers
16:         int maxWeight = 0; // The maximum weight
17:         int minWeight = Integer.MAX_VALUE; // The minimum weight
18:         final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
19:         int weightSum = 0;
20:         // è®¡ç®—æœ€å°ã€æœ€å¤§æƒé‡ï¼Œæ€»çš„æƒé‡å’Œã€‚
21:         for (int i = 0; i < length; i++) {
22:             int weight = getWeight(invokers.get(i), invocation);
23:             maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
24:             minWeight = Math.min(minWeight, weight); // Choose the minimum weight
25:             if (weight > 0) {
26:                 invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
27:                 weightSum += weight;
28:             }
29:         }
30:         // è·å¾— AtomicPositiveInteger å¯¹è±¡
31:         AtomicPositiveInteger sequence = sequences.get(key);
32:         if (sequence == null) {
33:             sequences.putIfAbsent(key, new AtomicPositiveInteger());
34:             sequence = sequences.get(key);
35:         }
36:         // è·å¾—å½“å‰é¡ºåºå·ï¼Œå¹¶é€’å¢ + 1
37:         int currentSequence = sequence.getAndIncrement();
38:         // æƒé‡ä¸ç›¸ç­‰ï¼Œé¡ºåºæ ¹æ®æƒé‡åˆ†é…
39:         if (maxWeight > 0 && minWeight < maxWeight) {
40:             int mod = currentSequence % weightSum; // å‰©ä½™æƒé‡
41:             for (int i = 0; i < maxWeight; i++) { // å¾ªç¯æœ€å¤§æƒé‡
42:                 for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) { // å¾ªç¯ Invoker é›†åˆ
43:                     final Invoker<T> k = each.getKey();
44:                     final IntegerWrapper v = each.getValue();
45:                     // å‰©ä½™æƒé‡å½’ 0 ï¼Œå½“å‰ Invoker è¿˜æœ‰å‰©ä½™æƒé‡ï¼Œè¿”å›è¯¥ Invoker å¯¹è±¡
46:                     if (mod == 0 && v.getValue() > 0) {
47:                         return k;
48:                     }
49:                     // è‹¥ Invoker è¿˜æœ‰æƒé‡å€¼ï¼Œæ‰£é™¤å®ƒ( value )å’Œå‰©ä½™æƒé‡( mod )ã€‚
50:                     if (v.getValue() > 0) {
51:                         v.decrement();
52:                         mod--;
53:                     }
54:                 }
55:             }
56:         }
57:         // æƒé‡ç›¸ç­‰ï¼Œå¹³å‡é¡ºåºè·å¾—
58:         // Round robin
59:         return invokers.get(currentSequence % length);
60:     }
61:     
62: }
```

- ç¬¬ 18 è¡Œï¼š`invokerToWeightMap` å˜é‡ï¼ŒInvoker ä¸å…¶æƒé‡çš„æ˜ å°„ã€‚å…¶ä¸­ï¼ŒIntegerWrapper ä¸º RoundRobinLoadBalance çš„å†…éƒ¨ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private static final class IntegerWrapper {
  
      // æƒé‡å€¼
      private int value;
  
      // ... çœç•¥ æ„é€  / getting / setting æ–¹æ³•
  
      // æ‰£é™¤ä¸€
      public void decrement() {
          this.value--;
      }
  
  }
  ```

- ç¬¬ 20 è‡³ 29 è¡Œï¼šè®¡ç®—æœ€å°ã€æœ€å¤§æƒé‡ï¼Œæ€»çš„æƒé‡å’Œï¼Œå¹¶åˆå§‹åŒ– `invokerToWeightMap` ã€‚

  - å…¶ä¸­ï¼Œæœ€å°æƒé‡ç”¨æ¥åˆ¤æ–­ï¼Œæ‰€æœ‰ Invoker çš„æƒé‡æ˜¯å¦éƒ½ç›¸ç­‰ã€‚

- ç¬¬ 30 è‡³ 35 è¡Œï¼šè·å¾—**å¯¹åº”çš„** AtomicPositiveInteger å¯¹è±¡ï¼Œä½œä¸º**é¡ºåºè®¡æ•°å™¨**ã€‚

- ç¬¬ 37 è¡Œï¼šè·å¾—å½“å‰é¡ºåºå·ï¼Œå¹¶é€’å¢ + 1 ã€‚**æ³¨æ„**ï¼Œé€’å¢è¦æ”¾åé¢ï¼Œä¸ç„¶å°±ä¸æ˜¯ä»**å¤´**å¼€å§‹äº†ã€‚

- ç¬¬ 38 è‡³ 56 è¡Œï¼šæƒé‡

  ä¸ç›¸ç­‰

  ï¼Œé¡ºåºæ ¹æ®æƒé‡åˆ†é…ã€‚å› ä¸ºé¡ºåºåˆ†é…çš„è¿‡ç¨‹éœ€è¦è€ƒè™‘

  æƒé‡

  ï¼Œæ‰€ä»¥çœ‹èµ·æ¥æ¯”è¾ƒâ€œç»•â€ã€‚æˆ‘ä»¬å¯ä»¥ç†è§£æˆï¼š

  - é¡ºåºå‘ `mod` æ¬¡ç‰Œ
  - æ¯å‘ä¸€ä¸ª Invoker å‘ä¸€æ¬¡ç‰Œï¼Œå®ƒçš„å‰©ä½™ `weight` å‡ä¸€ã€‚**å½“ä¸”ä»…å½“å‘æœ‰å‰©ä½™ `weight` çš„ Invoker å‘ç‰Œ**ã€‚
  - å½“æ²¡æœ‰å¯å‘çš„ `mod` ç‰Œæ—¶ï¼Œé€‰æ‹©è¯¥ Invoker ã€‚

- ç¬¬ 59 è¡Œï¼šæƒé‡**ç›¸ç­‰**ï¼Œç›´æ¥å¹³å‡é¡ºåºåˆ†é…ã€‚ç›¸ç­‰äºå¯¹ã€ç¬¬ 38 è‡³ 56 è¡Œã€‘çš„ä¼˜åŒ–ã€‚

> FROM é£å“¥çš„ [ã€Šdubboæºç -è´Ÿè½½å‡è¡¡ã€‹](https://www.jianshu.com/p/10c30d7b8b6a)
>
> å‡å®šæœ‰3å°æƒé‡éƒ½ä¸€æ ·çš„dubbo provider:
>
> - 10.0.0.1:20884, weight=100
> - 10.0.0.1:20886, weight=100
> - 10.0.0.1:20888, weight=100
>
> è½®è¯¢ç®—æ³•çš„å®ç°ï¼š
> å…¶è°ƒç”¨æ–¹æ³•æŸä¸ªæ–¹æ³•(key)çš„ sequence ä» 0 å¼€å§‹ï¼š
>
> - sequence=0æ—¶ï¼Œé€‰æ‹©invokers.get(0%3)=10.0.0.1:20884
> - sequence=1æ—¶ï¼Œé€‰æ‹©invokers.get(1%3)=10.0.0.1:20886
> - sequence=2æ—¶ï¼Œé€‰æ‹©invokers.get(2%3)=10.0.0.1:20888
> - sequence=3æ—¶ï¼Œé€‰æ‹©invokers.get(3%3)=10.0.0.1:20884
> - sequence=4æ—¶ï¼Œé€‰æ‹©invokers.get(4%3)=10.0.0.1:20886
> - sequence=5æ—¶ï¼Œé€‰æ‹©invokers.get(5%3)=10.0.0.1:20888

> å¦‚æœæœ‰3å°æƒé‡ä¸ä¸€æ ·çš„dubbo providerï¼š
>
> - 10.0.0.1:20884, weight=50
> - 10.0.0.1:20886, weight=100
> - 10.0.0.1:20888, weight=150
>
> è°ƒè¯•è¿‡å¾ˆå¤šæ¬¡ï¼Œè¿™ç§æƒ…å†µä¸‹æœ‰é—®é¢˜ï¼›ç•™ä¸€ä¸ªTODOï¼›

## 6. LeastActiveLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance` ï¼Œå®ç° AbstractLoadBalance æŠ½è±¡ç±»ï¼Œ**æœ€å°‘æ´»è·ƒè°ƒç”¨æ•°**ï¼Œç›¸åŒæ´»è·ƒæ•°çš„éšæœºï¼Œæ´»è·ƒæ•°æŒ‡è°ƒç”¨å‰åè®¡æ•°å·®ã€‚

> ä½¿æ…¢çš„æä¾›è€…æ”¶åˆ°æ›´å°‘è¯·æ±‚ï¼Œå› ä¸ºè¶Šæ…¢çš„æä¾›è€…çš„è°ƒç”¨å‰åè®¡æ•°å·®ä¼šè¶Šå¤§ã€‚

ç›¸æ¯”æ¥è¯´ï¼ŒLeastActiveLoadBalance æ˜¯ RandomLoadBalance çš„**åŠ å¼ºç‰ˆ**ï¼ŒåŸº**äºæœ€å°‘æ´»è·ƒè°ƒç”¨æ•°**ã€‚

```
 1: public class LeastActiveLoadBalance extends AbstractLoadBalance {
 2: 
 3:     public static final String NAME = "leastactive";
 4: 
 5:     private final Random random = new Random();
 6: 
 7:     @Override
 8:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
 9:         int length = invokers.size(); // æ€»ä¸ªæ•°
10:         int leastActive = -1; // æœ€å°çš„æ´»è·ƒæ•°
11:         int leastCount = 0; // ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„ä¸ªæ•°
12:         int[] leastIndexes = new int[length]; // ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„ä¸‹æ ‡
13:         int totalWeight = 0; // æ€»æƒé‡
14:         int firstWeight = 0; // ç¬¬ä¸€ä¸ªæƒé‡ï¼Œç”¨äºäºè®¡ç®—æ˜¯å¦ç›¸åŒ
15:         boolean sameWeight = true; // æ˜¯å¦æ‰€æœ‰æƒé‡ç›¸åŒ
16:         // è®¡ç®—è·å¾—ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„æ•°ç»„å’Œä¸ªæ•°
17:         for (int i = 0; i < length; i++) {
18:             Invoker<T> invoker = invokers.get(i);
19:             int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // æ´»è·ƒæ•°
20:             int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // æƒé‡
21:             if (leastActive == -1 || active < leastActive) { // å‘ç°æ›´å°çš„æ´»è·ƒæ•°ï¼Œé‡æ–°å¼€å§‹
22:                 leastActive = active; // è®°å½•æœ€å°æ´»è·ƒæ•°
23:                 leastCount = 1; // é‡æ–°ç»Ÿè®¡ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„ä¸ªæ•°
24:                 leastIndexes[0] = i; // é‡æ–°è®°å½•æœ€å°æ´»è·ƒæ•°ä¸‹æ ‡
25:                 totalWeight = weight; // é‡æ–°ç´¯è®¡æ€»æƒé‡
26:                 firstWeight = weight; // è®°å½•ç¬¬ä¸€ä¸ªæƒé‡
27:                 sameWeight = true; // è¿˜åŸæƒé‡ç›¸åŒæ ‡è¯†
28:             } else if (active == leastActive) { // ç´¯è®¡ç›¸åŒæœ€å°çš„æ´»è·ƒæ•°
29:                 leastIndexes[leastCount++] = i; // ç´¯è®¡ç›¸åŒæœ€å°æ´»è·ƒæ•°ä¸‹æ ‡
30:                 totalWeight += weight; // ç´¯è®¡æ€»æƒé‡
31:                 // åˆ¤æ–­æ‰€æœ‰æƒé‡æ˜¯å¦ä¸€æ ·
32:                 if (sameWeight && weight != firstWeight) {
33:                     sameWeight = false;
34:                 }
35:             }
36:         }
37:         // assert(leastCount > 0)
38:         if (leastCount == 1) {
39:             // å¦‚æœåªæœ‰ä¸€ä¸ªæœ€å°åˆ™ç›´æ¥è¿”å›
40:             return invokers.get(leastIndexes[0]);
41:         }
42:         if (!sameWeight && totalWeight > 0) {
43:             // å¦‚æœæƒé‡ä¸ç›¸åŒä¸”æƒé‡å¤§äº0åˆ™æŒ‰æ€»æƒé‡æ•°éšæœº
44:             int offsetWeight = random.nextInt(totalWeight);
45:             // å¹¶ç¡®å®šéšæœºå€¼è½åœ¨å“ªä¸ªç‰‡æ–­ä¸Š
46:             for (int i = 0; i < leastCount; i++) {
47:                 int leastIndex = leastIndexes[i];
48:                 offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
49:                 if (offsetWeight <= 0) {
50:                     return invokers.get(leastIndex);
51:                 }
52:             }
53:         }
54:         // å¦‚æœæƒé‡ç›¸åŒæˆ–æƒé‡ä¸º0åˆ™å‡ç­‰éšæœº
55:         return invokers.get(leastIndexes[random.nextInt(leastCount)]);
56:     }
57: 
58: }
```

- ç¬¬ 16 è‡³ 36 è¡Œï¼š

  è®¡ç®—

  è·å¾—ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„æ•°ç»„(

   

  ```
  leastIndexes
  ```

   

  )å’Œä¸ªæ•°(

   

  ```
  leastCount
  ```

   

  )ã€‚

  æ³¨æ„

  ï¼Œ

  ```
  leastIndexes
  ```

   

  æ˜¯é‡ç”¨çš„ï¼Œæ‰€ä»¥éœ€è¦

   

  ```
  leastCount
  ```

   

  ä½œä¸ºä¸‹æ ‡ã€‚

  - æ¯ä¸ª Invoker çš„æ´»è·ƒæ•°è®¡ç®—ï¼Œé€šè¿‡ RpcStatus ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” è¿‡æ»¤å™¨ï¼ˆå››ï¼‰ä¹‹ ActiveLimitFilter && ExecuteLimitFilterã€‹](http://svip.iocoder.cn/Dubbo/filter-method-limit-filter/?self) å·²ç»æœ‰è¯¦ç»†è§£æã€‚

- ç¬¬ 38 è¡Œï¼šå¦‚æœåªæœ‰ä¸€ä¸ªæœ€å°åˆ™ç›´æ¥è¿”å›ã€‚

- ========== å¦‚ä¸‹éƒ¨åˆ†ï¼Œå’Œ RandomLoadBalance **ç±»ä¼¼** ==========

- ç¬¬ 42 è‡³ 53 è¡Œï¼šæƒé‡**ä¸ç›¸ç­‰**ï¼Œéšæœºæƒé‡åï¼Œåˆ¤æ–­åœ¨å“ªä¸ª Invoker çš„æƒé‡åŒºé—´ä¸­ã€‚

- ç¬¬ 55 è¡Œï¼šæƒé‡**ç›¸ç­‰**ï¼Œç›´æ¥éšæœºé€‰æ‹© Invoker å³å¯ã€‚ç›¸ç­‰äºå¯¹ã€ç¬¬ 42 è‡³ 53 è¡Œã€‘çš„**ä¼˜åŒ–**ã€‚

**ç®—æ³•è¯´æ˜**

> FROM é£å“¥çš„ [ã€Šdubboæºç -è´Ÿè½½å‡è¡¡ã€‹](https://www.jianshu.com/p/10c30d7b8b6a)
>
> æœ€å°æ´»è·ƒæ•°ç®—æ³•å®ç°ï¼š
> å‡å®šæœ‰3å°dubbo provider:
>
> - 10.0.0.1:20884, weight=2ï¼Œactive=2
> - 10.0.0.1:20886, weight=3ï¼Œactive=4
> - 10.0.0.1:20888, weight=4ï¼Œactive=3
>
> active=2æœ€å°ï¼Œä¸”åªæœ‰ä¸€ä¸ª2ï¼Œæ‰€ä»¥é€‰æ‹©10.0.0.1:20884
>
> å‡å®šæœ‰3å°dubbo provider:
>
> - 10.0.0.1:20884, weight=2ï¼Œactive=2
> - 10.0.0.1:20886, weight=3ï¼Œactive=2
> - 10.0.0.1:20888, weight=4ï¼Œactive=3
>   active=2æœ€å°ï¼Œä¸”æœ‰2ä¸ªï¼Œæ‰€ä»¥ä»[10.0.0.1:20884,10.0.0.1:20886 ]ä¸­é€‰æ‹©ï¼›
>
> æ¥ä¸‹æ¥çš„ç®—æ³•ä¸éšæœºç®—æ³•ç±»ä¼¼ï¼š
>
> - å‡è®¾offset=1ï¼ˆå³random.nextInt(5)=1ï¼‰
>   1-2=-1<0ï¼Ÿæ˜¯ï¼Œæ‰€ä»¥é€‰ä¸­ 10.0.0.1:20884, weight=2
> - å‡è®¾offset=4ï¼ˆå³random.nextInt(5)=4ï¼‰
>   4-2=2<0ï¼Ÿå¦ï¼Œè¿™æ—¶å€™offset=2ï¼Œ 2-3<0ï¼Ÿæ˜¯ï¼Œæ‰€ä»¥é€‰ä¸­ 10.0.0.1:20886, weight=3

## 7. ConsistentHashLoadBalance

`com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance` ï¼Œå®ç° AbstractLoadBalance æŠ½è±¡ç±»ï¼Œ**ä¸€è‡´æ€§ Hash**ï¼Œç›¸åŒå‚æ•°çš„è¯·æ±‚æ€»æ˜¯å‘åˆ°åŒä¸€æä¾›è€…ã€‚

> å½“æŸä¸€å°æä¾›è€…æŒ‚æ—¶ï¼ŒåŸæœ¬å‘å¾€è¯¥æä¾›è€…çš„è¯·æ±‚ï¼ŒåŸºäºè™šæ‹ŸèŠ‚ç‚¹ï¼Œå¹³æ‘Šåˆ°å…¶å®ƒæä¾›è€…ï¼Œä¸ä¼šå¼•èµ·å‰§çƒˆå˜åŠ¨ã€‚

```
 1: public class ConsistentHashLoadBalance extends AbstractLoadBalance {
 2: 
 3:     /**
 4:      * æœåŠ¡æ–¹æ³•ä¸ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©å™¨çš„æ˜ å°„
 5:      *
 6:      * KEYï¼šserviceKey + "." + methodName
 7:      */
 8:     private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<String, ConsistentHashSelector<?>>();
 9: 
10:     @SuppressWarnings("unchecked")
11:     @Override
12:     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
13:         String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
14:         // åŸºäº invokers é›†åˆï¼Œæ ¹æ®å¯¹è±¡å†…å­˜åœ°å€æ¥è®¡ç®—å®šä¹‰å“ˆå¸Œå€¼
15:         int identityHashCode = System.identityHashCode(invokers);
16:         // è·å¾— ConsistentHashSelector å¯¹è±¡ã€‚è‹¥ä¸ºç©ºï¼Œæˆ–è€…å®šä¹‰å“ˆå¸Œå€¼å˜æ›´ï¼ˆè¯´æ˜ invokers é›†åˆå‘ç”Ÿå˜åŒ–ï¼‰ï¼Œè¿›è¡Œåˆ›å»ºæ–°çš„ ConsistentHashSelector å¯¹è±¡
17:         ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);
18:         if (selector == null || selector.identityHashCode != identityHashCode) {
19:             selectors.put(key, new ConsistentHashSelector<T>(invokers, invocation.getMethodName(), identityHashCode));
20:             selector = (ConsistentHashSelector<T>) selectors.get(key);
21:         }
22:         return selector.select(invocation);
23:     }
24: }
```

- ç¬¬ 15 è¡Œï¼šè°ƒç”¨ `System#identityHashCode(Object)` æ–¹æ³•ï¼ŒåŸºäº `invokers` é›†åˆï¼Œæ ¹æ®å¯¹è±¡**å†…å­˜åœ°å€**æ¥è®¡ç®—å®šä¹‰å“ˆå¸Œå€¼ã€‚
- ç¬¬ 16 è‡³ 21 è¡Œï¼šè·å¾— ConsistentHashSelector å¯¹è±¡ã€‚è‹¥ä¸ºç©ºï¼Œæˆ–è€…å®šä¹‰å“ˆå¸Œå€¼å˜æ›´ï¼ˆ**è¯´æ˜ `invokers` é›†åˆå‘ç”Ÿå˜åŒ–**ï¼‰ï¼Œè¿›è¡Œåˆ›å»º**æ–°çš„** ConsistentHashSelector å¯¹è±¡ã€‚
- ç¬¬ 22 è¡Œï¼šè°ƒç”¨ `ConsistentHashSelector#select(invocation)` æ–¹æ³•ï¼Œé€‰æ‹©ä¸€ä¸ª Invoker å¯¹è±¡ã€‚

#### 7.1 ConsistentHashSelector

ConsistentHashSelector ï¼Œæ˜¯ ConsistentHashLoadBalance çš„**å†…éƒ¨ç±»**ï¼Œä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©å™¨ï¼ŒåŸºäº **Ketama** ç®—æ³•ã€‚

> è€è‰¿è‰¿ï¼šä¸‹æ–‡å‚è€ƒ [ã€ŠKetamaä¸€è‡´æ€§Hashç®—æ³•(å«Javaä»£ç )ã€‹](http://langyu.iteye.com/blog/684087) æ–‡ç« ã€‚ä»è¯¥æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼ŒSpy Memcached Client ä¹Ÿé‡‡ç”¨è¿™ç§ç®—æ³•ã€‚

###### 7.1.1 æ„é€ æ–¹æ³•

```
/**
 * è™šæ‹ŸèŠ‚ç‚¹ä¸ Invoker çš„æ˜ å°„å…³ç³»
 */
private final TreeMap<Long, Invoker<T>> virtualInvokers;
/**
 * æ¯ä¸ªInvoker å¯¹åº”çš„è™šæ‹ŸèŠ‚ç‚¹æ•°
 */
private final int replicaNumber;
/**
 * å®šä¹‰å“ˆå¸Œå€¼
 */
private final int identityHashCode;
/**
 * å–å€¼å‚æ•°ä½ç½®æ•°ç»„
 */
private final int[] argumentIndex;

  1: ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {
  2:     this.virtualInvokers = new TreeMap<Long, Invoker<T>>();
  3:     // è®¾ç½® identityHashCode
  4:     this.identityHashCode = identityHashCode;
  5:     URL url = invokers.get(0).getUrl();
  6:     // åˆå§‹åŒ– replicaNumber
  7:     this.replicaNumber = url.getMethodParameter(methodName, "hash.nodes", 160);
  8:     // åˆå§‹åŒ– argumentIndex
  9:     String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, "hash.arguments", "0"));
 10:     argumentIndex = new int[index.length];
 11:     for (int i = 0; i < index.length; i++) {
 12:         argumentIndex[i] = Integer.parseInt(index[i]);
 13:     }
 14:     // åˆå§‹åŒ– virtualInvokers
 15:     for (Invoker<T> invoker : invokers) {
 16:         String address = invoker.getUrl().getAddress();
 17:         // æ¯å››ä¸ªè™šæ‹Ÿç»“ç‚¹ä¸ºä¸€ç»„ï¼Œä¸ºä»€ä¹ˆè¿™æ ·ï¼Ÿä¸‹é¢ä¼šè¯´åˆ°
 18:         for (int i = 0; i < replicaNumber / 4; i++) {
 19:             // è¿™ç»„è™šæ‹Ÿç»“ç‚¹å¾—åˆ°æƒŸä¸€åç§°
 20:             byte[] digest = md5(address + i);
 21:             // Md5æ˜¯ä¸€ä¸ª16å­—èŠ‚é•¿åº¦çš„æ•°ç»„ï¼Œå°†16å­—èŠ‚çš„æ•°ç»„æ¯å››ä¸ªå­—èŠ‚ä¸€ç»„ï¼Œåˆ†åˆ«å¯¹åº”ä¸€ä¸ªè™šæ‹Ÿç»“ç‚¹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸Šé¢æŠŠè™šæ‹Ÿç»“ç‚¹å››ä¸ªåˆ’åˆ†ä¸€ç»„çš„åŸå› 
 22:             for (int h = 0; h < 4; h++) {
 23:                 // å¯¹äºæ¯å››ä¸ªå­—èŠ‚ï¼Œç»„æˆä¸€ä¸ªlongå€¼æ•°å€¼ï¼Œåšä¸ºè¿™ä¸ªè™šæ‹ŸèŠ‚ç‚¹çš„åœ¨ç¯ä¸­çš„æƒŸä¸€key
 24:                 long m = hash(digest, h);
 25:                 virtualInvokers.put(m, invoker);
 26:             }
 27:         }
 28:     }
 29: }
```

- `identityHashCode` å­—æ®µï¼Œå®šä¹‰å“ˆå¸Œå€¼ã€‚

- ```
  replicaNumber
  ```

   

  å­—æ®µï¼Œ

  æ¯ä¸ª

   

  Invoker å¯¹åº”çš„

  è™šæ‹ŸèŠ‚ç‚¹æ•°

  ï¼Œé»˜è®¤ä¸º 160 ã€‚

  - å¯é€šè¿‡ `<dubbo:parameter key="hash.nodes" value="320" />` è‡ªå®šä¹‰ï¼Œå¯¹åº”ã€ç¬¬ 7 è¡Œã€‘ä»£ç ã€‚

- ```
  argumentIndex
  ```

   

  å­—æ®µï¼Œé€‰æ‹© Invoker æ—¶ï¼Œè®¡ç®— Hash å€¼çš„å‚æ•°ä½ç½®æ•°ç»„ï¼Œé»˜è®¤ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚

  - å¯é€šè¿‡ `<dubbo:parameter key="hash.arguments" value="0,1" />` è‡ªå®šä¹‰ï¼Œ å¯¹åº”ã€ç¬¬ 8 è‡³ 13 è¡Œã€‘ä»£ç ã€‚

- `virtualInvokers` å­—æ®µï¼Œè™šæ‹ŸèŠ‚ç‚¹ä¸ Invoker çš„æ˜ å°„å…³ç³»ã€‚å¯¹åº”ã€ç¬¬ 14 è‡³ 28 è¡Œã€‘è¿›è¡Œåˆå§‹åŒ–ã€‚

  - ç¬¬ 15 è¡Œï¼š**å¾ªç¯**æ¯ä¸ª Invoker å¯¹è±¡ã€‚

  - ç¬¬ 18 è¡Œï¼š**å¾ªç¯** `replicaNumber / 4` æ¬¡ï¼Œæ¯**å››ä¸ª**è™šæ‹ŸèŠ‚ç‚¹ä¸ºä¸€ç»„ï¼Œä¸ºä»€ä¹ˆè¿™æ ·å‘¢ï¼Ÿè¯¦ç»†è§ã€ç¬¬ 20 è¡Œã€‘ã€‚

  - ç¬¬ 20 è¡Œï¼šæ‹¼æ¥ `address + i` ä½œä¸ºè™šæ‹ŸèŠ‚ç‚¹åçš„**å”¯ä¸€åç§°**ã€‚è°ƒç”¨ `#md5(value)` æ–¹æ³•ï¼Œè®¡ç®— MD5 ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    private byte[] md5(String value) {
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        md5.reset();
        byte[] bytes;
        try {
            bytes = value.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
        md5.update(bytes);
        return md5.digest();
    }
    ```

    - **MD5 æ˜¯ä¸€ä¸ª 16 å­—èŠ‚é•¿åº¦çš„æ•°ç»„ï¼Œå°† 16 å­—èŠ‚çš„æ•°ç»„æ¯å››ä¸ªå­—èŠ‚ä¸€ç»„ï¼Œåˆ†åˆ«å¯¹åº”ä¸€ä¸ªè™šæ‹Ÿç»“ç‚¹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸Šé¢æŠŠè™šæ‹Ÿç»“ç‚¹å››ä¸ªåˆ’åˆ†ä¸€ç»„çš„åŸå› **

  - ç¬¬ 22 è¡Œï¼šé¡ºåº**å¾ªç¯**æ¯å››ä¸ªå­—èŠ‚ã€‚

  - ç¬¬ 24 è¡Œï¼šè°ƒç”¨ `#hash(byte[] digest, int number)` æ–¹æ³•ï¼Œå¯¹äº**æ¯å››ä¸ªå­—èŠ‚**ï¼Œç»„æˆä¸€ä¸ª Long å€¼æ•°å€¼ï¼Œåšä¸ºè¿™ä¸ªè™šæ‹ŸèŠ‚ç‚¹çš„åœ¨ç¯ä¸­çš„**æƒŸä¸€ KEY** ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    private long hash(byte[] digest, int number) {
        return (((long) (digest[3 + number * 4] & 0xFF) << 24)
                | ((long) (digest[2 + number * 4] & 0xFF) << 16)
                | ((long) (digest[1 + number * 4] & 0xFF) << 8)
                | (digest[number * 4] & 0xFF))
                & 0xFFFFFFFFL;
    }
    ```

    - x

  - ç¬¬ 25 è¡Œï¼šæ·»åŠ  Invoker åˆ° `virtualInvokers` ä¸­ã€‚

###### 7.1.2 select

```
public Invoker<T> select(Invocation invocation) {
    // åŸºäºæ–¹æ³•å‚æ•°ï¼Œè·å¾— KEY
    String key = toKey(invocation.getArguments());
    // è®¡ç®— MD5 å€¼
    byte[] digest = md5(key);
    // è®¡ç®— KEY å€¼
    return selectForKey(hash(digest, 0));
}
```

- è°ƒç”¨ `#toKey(Object[] args)` æ–¹æ³•ï¼ŒåŸºäº**æ–¹æ³•å‚æ•°**ï¼Œè·å¾— KEY ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private String toKey(Object[] args) {
      StringBuilder buf = new StringBuilder();
      for (int i : argumentIndex) {
          if (i >= 0 && i < args.length) {
              buf.append(args[i]);
          }
      }
      return buf.toString();
  }
  ```

- è°ƒç”¨ `#md5(key)` æ–¹æ³•ï¼Œè®¡ç®— MD5 å€¼ã€‚

- è°ƒç”¨ `#hash(digest, hash)` æ–¹æ³•ï¼Œè®¡ç®— KEY å€¼ã€‚

- è°ƒç”¨ `#selectForKey(hash)` æ–¹æ³•ï¼Œé€‰ä¸€ä¸ª Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private Invoker<T> selectForKey(long hash) {
      // å¾—åˆ°å¤§äºå½“å‰ key çš„é‚£ä¸ªå­ Map ï¼Œç„¶åä»ä¸­å–å‡ºç¬¬ä¸€ä¸ª key ï¼Œå°±æ˜¯å¤§äºä¸”ç¦»å®ƒæœ€è¿‘çš„é‚£ä¸ª key
      Map.Entry<Long, Invoker<T>> entry = virtualInvokers.tailMap(hash, true).firstEntry();
      // ä¸å­˜åœ¨ï¼Œåˆ™å– virtualInvokers ç¬¬ä¸€ä¸ª
  	if (entry == null) {
  		entry = virtualInvokers.firstEntry();
  	}
  	// å­˜åœ¨ï¼Œåˆ™è¿”å›
  	return entry.getValue();
  }
  ```

# 5ã€Merger å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå››ï¼‰ä¹‹ LoadBalance å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-4-impl-loadbalance/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `merger` åŒ…ï¼Œ**å„ç§ Merger å®ç°ç±»**ã€‚

Merger ç›¸å…³ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

[![Merger ç›¸å…³ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_20/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_20/01.png)Merger ç›¸å…³ç±»

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç›®å‰ä¸€å…±æœ‰**ä¸¤éƒ¨åˆ†**ï¼š

- Merger ä»¥åŠå…¶å®ç°ç±»ã€‚
- MergerCluster ä»¥åŠå…¶ MergerClusterInvoker

> è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” åˆ†ç»„èšåˆã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) æ–‡æ¡£ã€‚

## 2. Merger

`com.alibaba.dubbo.rpc.cluster.Merger` ï¼ŒMerger **æ¥å£**ï¼Œæä¾›æ¥å£æ–¹æ³•ï¼Œå°†**å¯¹è±¡æ•°ç»„**åˆå¹¶æˆ**ä¸€ä¸ªå¯¹è±¡**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@SPI
public interface Merger<T> {

    /**
     * åˆå¹¶ T æ•°ç»„ï¼Œè¿”å›åˆå¹¶åçš„ T å¯¹è±¡
     *
     * @param items T æ•°ç»„
     * @return T å¯¹è±¡
     */
    T merge(T... items);

}
```

- `@SPI` æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œæ— é»˜è®¤å€¼ã€‚

#### 2.1 Merger å®ç°ç±»

Merger å†…ç½®**åäºŒ**ä¸ªå®ç°ç±»ï¼Œä»ä»£ç ä¸Šçœ‹åŸºæœ¬ç±»ä¼¼ã€‚æˆ‘ä»¬ä»¥ MapMerger å’Œ ShortArrayMerger ä½œä¸ºä¾‹å­ã€‚

###### 2.1.1 MapMerger

`com.alibaba.dubbo.rpc.cluster.merger.MapMerger` ï¼Œå®ç° Merger æ¥å£ï¼ŒMap Merger å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class MapMerger implements Merger<Map<?, ?>> {

    @Override
    public Map<?, ?> merge(Map<?, ?>... items) {
        if (items.length == 0) {
            return null;
        }
        // åˆ›å»ºç»“æœ Map
        Map<Object, Object> result = new HashMap<Object, Object>();
        // åˆå¹¶å¤šä¸ª Map
        for (Map<?, ?> item : items) {
            if (item != null) {
                result.putAll(item);
            }
        }
        return result;
    }

}
```

###### 2.1.2 ShortArrayMerger

`com.alibaba.dubbo.rpc.cluster.merger.ShortArrayMerger` ï¼Œå®ç° Merger æ¥å£ï¼ŒShort æ•°ç»„ Merger å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class ShortArrayMerger implements Merger<short[]> {

    @Override
    public short[] merge(short[]... items) {
        // è®¡ç®—åˆå¹¶åçš„æ•°ç»„å¤§å°
        int total = 0;
        for (short[] array : items) {
            total += array.length;
        }
        // åˆ›å»ºç»“æœæ•°ç»„
        short[] result = new short[total];
        // åˆå¹¶å¤šä¸ªæ•°ç»„
        int index = 0;
        for (short[] array : items) {
            for (short item : array) {
                result[index++] = item;
            }
        }
        return result;
    }

}
```

#### 2.2 MergerFactory

`com.alibaba.dubbo.rpc.cluster.merger.MergerFactory` ï¼ŒMerger å·¥å‚ç±»ï¼Œæä¾› `#getMerger(Class<T> returnType)` æ–¹æ³•ï¼Œè·å¾—**æŒ‡å®šç±»**å¯¹åº”çš„ Merger å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class MergerFactory {

    /**
     * Merger å¯¹è±¡ç¼“å­˜
     */
    private static final ConcurrentMap<Class<?>, Merger<?>> mergerCache = new ConcurrentHashMap<Class<?>, Merger<?>>();

    public static <T> Merger<T> getMerger(Class<T> returnType) {
        Merger result;
        // æ•°ç»„ç±»å‹
        if (returnType.isArray()) {
            Class type = returnType.getComponentType();
            // ä»ç¼“å­˜ä¸­è·å¾— Merger å¯¹è±¡
            result = mergerCache.get(type);
            if (result == null) {
                loadMergers();
                result = mergerCache.get(type);
            }
            // è·å–ä¸åˆ°ï¼Œä½¿ç”¨ ArrayMerger
            if (result == null && !type.isPrimitive()) {
                result = ArrayMerger.INSTANCE;
            }
        // æ™®é€šç±»å‹
        } else {
            // ä»ç¼“å­˜ä¸­è·å¾— Merger å¯¹è±¡
            result = mergerCache.get(returnType);
            if (result == null) {
                loadMergers();
                result = mergerCache.get(returnType);
            }
        }
        return result;
    }

    /**
     * åˆå§‹åŒ–æ‰€æœ‰çš„ Merger æ‹“å±•å¯¹è±¡ï¼Œåˆ° mergerCache ç¼“å­˜ä¸­ã€‚
      */
    static void loadMergers() {
        Set<String> names = ExtensionLoader.getExtensionLoader(Merger.class).getSupportedExtensions();
        for (String name : names) {
            Merger m = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(name);
            mergerCache.putIfAbsent(ReflectUtils.getGenericClass(m.getClass()), m);
        }
    }

}
```

## 3. MergeableCluster

`com.alibaba.dubbo.rpc.cluster.support.MergeableCluster` ï¼Œå®ç° Cluster æ¥å£ï¼Œåˆ†ç»„èšåˆ Cluster å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class MergeableCluster implements Cluster {

    public static final String NAME = "mergeable";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new MergeableClusterInvoker<T>(directory);
    }

}
```

- å¯¹åº” Invoker å®ç°ç±»ä¸º MergeableClusterInvoker ã€‚

Merger çš„ä½¿ç”¨ï¼Œ**éœ€è¦è®¾ç½® Cluster çš„å®ç°ç±»ä¸º MergeableCluster** ã€‚ä½†æ˜¯å‘¢ï¼Œå®ƒçš„é…ç½®æ–¹å¼ï¼Œå’Œå…¶ä»– Cluster å®ç°ç±»ä¸åŒã€‚

- ä½¿ç”¨æ–¹å¼ï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” åˆ†ç»„èšåˆã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/group-merger.html) æ–‡æ¡£ã€‚
- åŸå› ï¼Œå‚è§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸‰ï¼‰ä¹‹ Directory å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-3-impl-directory?self) çš„ [ã€Œ4.3.3.3 toMergeMethodInvokerMapã€](http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/#) ã€‚

#### 3.1 MergeableClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.MergeableClusterInvoker` ï¼Œå®ç° Invoker æ¥å£ï¼ŒMergeableCluster Invoker å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
/**
 * Directory$Adaptive å¯¹è±¡
 */
private final Directory<T> directory;
/**
 * ExecutorService å¯¹è±¡ï¼Œå¹¶ä¸”ä¸º CachedThreadPool ã€‚
 */
private ExecutorService executor = Executors.newCachedThreadPool(new NamedThreadFactory("mergeable-cluster-executor", true));

  1: @Override
  2: public Result invoke(final Invocation invocation) throws RpcException {
  3:     // è·å¾— Invoker é›†åˆ
  4:     List<Invoker<T>> invokers = directory.list(invocation);
  5:     // è·å¾— Merger æ‹“å±•å
  6:     String merger = getUrl().getMethodParameter(invocation.getMethodName(), Constants.MERGER_KEY);
  7:     // è‹¥æœæœªé…ç½®æ‹“å±•ï¼Œç›´æ¥è°ƒç”¨é¦–ä¸ªå¯ç”¨çš„ Invoker å¯¹è±¡
  8:     if (ConfigUtils.isEmpty(merger)) { // If a method doesn't have a merger, only invoke one Group
  9:         for (final Invoker<T> invoker : invokers) {
 10:             if (invoker.isAvailable()) {
 11:                 return invoker.invoke(invocation);
 12:             }
 13:         }
 14:         return invokers.iterator().next().invoke(invocation);
 15:     }
 16: 
 17:     // é€šè¿‡åå°„ï¼Œè·å¾—è¿”å›ç±»å‹
 18:     Class<?> returnType;
 19:     try {
 20:         returnType = getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes()).getReturnType();
 21:     } catch (NoSuchMethodException e) {
 22:         returnType = null;
 23:     }
 24: 
 25:     // æäº¤çº¿ç¨‹æ± ï¼Œå¹¶è¡Œæ‰§è¡Œï¼Œå‘èµ· RPC è°ƒç”¨ï¼Œå¹¶æ·»åŠ åˆ° results ä¸­
 26:     Map<String, Future<Result>> results = new HashMap<String, Future<Result>>();
 27:     for (final Invoker<T> invoker : invokers) {
 28:         Future<Result> future = executor.submit(new Callable<Result>() {
 29:             public Result call() {
 30:                 // RPC è°ƒç”¨
 31:                 return invoker.invoke(new RpcInvocation(invocation, invoker));
 32:             }
 33:         });
 34:         results.put(invoker.getUrl().getServiceKey(), future);
 35:     }
 36: 
 37:     // é˜»å¡ç­‰å¾…æ‰§è¡Œæ‰§è¡Œç»“æœï¼Œå¹¶æ·»åŠ åˆ° resultList ä¸­
 38:     List<Result> resultList = new ArrayList<Result>(results.size());
 39:     int timeout = getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
 40:     for (Map.Entry<String, Future<Result>> entry : results.entrySet()) {
 41:         Future<Result> future = entry.getValue();
 42:         try {
 43:             Result r = future.get(timeout, TimeUnit.MILLISECONDS);
 44:             if (r.hasException()) { // å¼‚å¸¸ Result ï¼Œæ‰“å°é”™è¯¯æ—¥å¿—ï¼Œå¿½ç•¥
 45:                 log.error(new StringBuilder(32).append("Invoke ").append(getGroupDescFromServiceKey(entry.getKey())).append(" failed: ").append(r.getException().getMessage()).toString(), r.getException());
 46:             } else { // æ­£å¸¸ Result ï¼Œæ·»åŠ åˆ° resultList ä¸­
 47:                 resultList.add(r);
 48:             }
 49:         } catch (Exception e) { // å¼‚å¸¸ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸
 50:             throw new RpcException(new StringBuilder(32).append("Failed to invoke service ").append(entry.getKey()).append(": ").append(e.getMessage()).toString(), e);
 51:         }
 52:     }
 53: 
 54:     // ç»“æœå¤§å°ä¸ºç©ºï¼Œè¿”å›ç©ºçš„ RpcResult
 55:     if (resultList.isEmpty()) {
 56:         return new RpcResult((Object) null);
 57:     // ç»“æœå¤§å°ä¸º 1 ï¼Œè¿”å›é¦–ä¸ª RpcResult
 58:     } else if (resultList.size() == 1) {
 59:         return resultList.iterator().next();
 60:     }
 61:     // è¿”å›ç±»å‹ä¸º void ï¼Œè¿”å›ç©ºçš„ RpcResult
 62:     if (returnType == void.class) {
 63:         return new RpcResult((Object) null);
 64:     }
 65: 
 66:     Object result;
 67:     // ã€ç¬¬ 1 ç§ã€‘åŸºäºåˆå¹¶æ–¹æ³•
 68:     if (merger.startsWith(".")) {
 69:         // è·å¾—åˆå¹¶æ–¹æ³• Method
 70:         merger = merger.substring(1);
 71:         Method method;
 72:         try {
 73:             method = returnType.getMethod(merger, returnType);
 74:         } catch (NoSuchMethodException e) {
 75:             throw new RpcException(new StringBuilder(32).append("Can not merge result because missing method [ ").append(merger).append(" ] in class [ ").append(returnType.getClass().getName()).append(" ]").toString());
 76:         }
 77:         // æœ‰ Method ï¼Œè¿›è¡Œåˆå¹¶
 78:         if (method != null) {
 79:             if (!Modifier.isPublic(method.getModifiers())) {
 80:                 method.setAccessible(true);
 81:             }
 82:             result = resultList.remove(0).getValue();
 83:             try {
 84:                 // æ–¹æ³•è¿”å›ç±»å‹åŒ¹é…ï¼Œåˆå¹¶æ—¶ï¼Œä¿®æ”¹ result
 85:                 if (method.getReturnType() != void.class && method.getReturnType().isAssignableFrom(result.getClass())) {
 86:                     for (Result r : resultList) {
 87:                         result = method.invoke(result, r.getValue());
 88:                     }
 89:                 // æ–¹æ³•è¿”å›ç±»å‹ä¸åŒ¹é…ï¼Œåˆå¹¶æ—¶ï¼Œä¸ä¿®æ”¹ result
 90:                 } else {
 91:                     for (Result r : resultList) {
 92:                         method.invoke(result, r.getValue());
 93:                     }
 94:                 }
 95:             } catch (Exception e) {
 96:                 throw new RpcException(new StringBuilder(32).append("Can not merge result: ").append(e.getMessage()).toString(), e);
 97:             }
 98:         // æ—  Method ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸
 99:         } else {
100:             throw new RpcException(new StringBuilder(32).append("Can not merge result because missing method [ ").append(merger).append(" ] in class [ ").append(returnType.getClass().getName()).append(" ]").toString());
101:         }
102:     // ã€ç¬¬ 2 ç§ã€‘åŸºäº Merger
103:     } else {
104:         Merger resultMerger;
105:         // ã€ç¬¬ 2.1 ç§ã€‘æ ¹æ®è¿”å›å€¼ç±»å‹è‡ªåŠ¨åŒ¹é… Merger
106:         if (ConfigUtils.isDefault(merger)) {
107:             resultMerger = MergerFactory.getMerger(returnType);
108:         // ã€ç¬¬ 2.2 ç§ã€‘æŒ‡å®š Merger
109:         } else {
110:             resultMerger = ExtensionLoader.getExtensionLoader(Merger.class).getExtension(merger);
111:         }
112:         // æœ‰ Merger ï¼Œè¿›è¡Œåˆå¹¶
113:         if (resultMerger != null) {
114:             List<Object> rets = new ArrayList<Object>(resultList.size());
115:             for (Result r : resultList) {
116:                 rets.add(r.getValue());
117:             }
118:             result = resultMerger.merge(rets.toArray((Object[]) Array.newInstance(returnType, 0)));
119:         // æ—  Merger ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸
120:         } else {
121:             throw new RpcException("There is no merger to merge result.");
122:         }
123:     }
124:     // è¿”å› RpcResult ç»“æœ
125:     return new RpcResult(result);
126: }
```

- ğŸ™‚ çœ‹ä¼¼æ¯”è¾ƒé•¿ï¼Œå®é™…å¾ˆæ˜“æ‡‚ã€‚
- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `Directory#list(invocation)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡ Invoker **é›†åˆ**ã€‚
- ç¬¬ 6 è¡Œï¼šè°ƒç”¨ `URL#getMethodParameter(methodName, "merger")` æ–¹æ³•ï¼Œè·å¾— Merger æ‹“å±•åï¼Œ**æ–¹æ³•çº§**ã€‚
- ç¬¬ 7 è‡³ 15 è¡Œï¼šè‹¥**æœªé…ç½®** Merger æ‹“å±•åï¼Œä¼˜å…ˆè°ƒç”¨é¦–ä¸ª**å¯ç”¨**çš„ Invoker å¯¹è±¡ï¼Œå…¶æ¬¡è°ƒç”¨é¦–ä¸ª Invoker å¯¹è±¡ã€‚
- ç¬¬ 17 è‡³ 23 è¡Œï¼šé€šè¿‡åå°„ï¼Œè·å¾—è°ƒç”¨æ–¹æ³•çš„**è¿”å›ç±»å‹**ã€‚
- ç¬¬ 25 è‡³ 35 è¡Œï¼šæäº¤çº¿ç¨‹æ± ï¼Œ**å¹¶è¡Œ**æ‰§è¡Œï¼Œå‘èµ· RPC è°ƒç”¨ï¼Œå¹¶æ·»åŠ  Future åˆ° `results` ä¸­ã€‚
- ç¬¬ 37 è‡³ 52 è¡Œï¼š**é˜»å¡**ç­‰å¾…æ‰§è¡Œç»“æœï¼Œå¹¶æ·»åŠ åˆ° `resultList` ä¸­ã€‚**æ³¨æ„**ï¼Œåˆ†æˆæ­£å¸¸ Resultã€å¼‚å¸¸ Resultï¼ˆ**å¿½ç•¥**ï¼‰ã€Exception ä¸‰ç§æƒ…å†µã€‚
- ç¬¬ 54 è‡³ 56 è¡Œï¼šç»“æœå¤§å°ä¸º**ç©º**ï¼Œè¿”å›**ç©º**çš„ RpcResult ã€‚
- ç¬¬ 57 è‡³ 60 è¡Œï¼šç»“æœå¤§å°ä¸º **1** ï¼Œè¿”å›**é¦–ä¸ª** RpcResult ã€‚
- ç¬¬ 61 è‡³ 64 è¡Œï¼šè¿”å›ç±»å‹ä¸º **void** ï¼Œè¿”å›**ç©º**çš„ RpcResult ã€‚
- ========== ã€**ç¬¬ 1 ç§**ã€‘åŸºäº Method åˆå¹¶==========
- ç¬¬ 68 è¡Œï¼šè‹¥ `merger` ä¸º `"."` å¼€å¤´ï¼ŒæŒ‡å®šåˆå¹¶æ–¹æ³•ï¼Œå°†è°ƒç”¨è¿”å›ç»“æœçš„æŒ‡å®šæ–¹æ³•è¿›è¡Œåˆå¹¶ï¼Œåˆå¹¶æ–¹æ³•çš„å‚æ•°ç±»å‹å¿…é¡»æ˜¯è¿”å›ç»“æœç±»å‹**æœ¬èº«**ã€‚
- ç¬¬ 69 è‡³ 76 è¡Œï¼šè°ƒç”¨ `Class#getMethod(String name, Class<?>... parameterTypes)` æ–¹æ³•ï¼Œè·å¾—**åˆå¹¶æ–¹æ³• Method** ã€‚è¿™ä¸ªæ–¹æ³•ï¼Œæ„å‘³ç€â€œåˆå¹¶æ–¹æ³•çš„å‚æ•°ç±»å‹å¿…é¡»æ˜¯è¿”å›ç»“æœç±»å‹**æœ¬èº«**â€ï¼ï¼ï¼å…·ä½“åŸå› ï¼Œè§ [ã€Šdubboæºç -é›†ç¾¤å®¹é”™ä¹‹MergeableClusterã€‹](https://www.jianshu.com/p/512e2211f84c) ï¼Œæœç´¢ `"åœ¨æ¡ä»¶åˆ†æ”¯if ( merger.startsWith(".") ) {}"` ã€‚
- ç¬¬ 77 è‡³ 97 è¡Œï¼š**æœ‰** Method ï¼Œ**å¾ªç¯**è°ƒç”¨ `Method#invoke(Object obj, Object... args)` æ–¹æ³•ï¼Œè¿›è¡Œåˆå¹¶ã€‚
- ç¬¬ 98 è‡³ 101 è¡Œï¼š**æ— ** Method ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚
- ========== ã€**ç¬¬ 2 ç§**ã€‘åŸºäº Merger åˆå¹¶ ==========
- ã€ç¬¬ **2.1** ç§ã€‘ç¬¬ 105 è‡³ 107 è¡Œï¼šå½“ `merger` ä¸º `"default"` æˆ– `"true"` æ—¶ï¼Œè°ƒç”¨ `MergerFactory#getMerger(Class<T> returnType)` æ–¹æ³•ï¼Œæ ¹æ®**è¿”å›å€¼ç±»å‹**è‡ªåŠ¨åŒ¹é… Merger ã€‚
- ã€ç¬¬ **2.2** ç§ã€‘ç¬¬ 108 è‡³ 111 è¡Œï¼šè°ƒç”¨ `ExtensionLoader#getExtension(merger)` æ–¹æ³•å•Šï¼Œè·å¾—**æŒ‡å®š** Merger ã€‚
- ç¬¬ 112 è‡³ 118 è¡Œï¼š**æœ‰** Merger ï¼Œ**å¾ªç¯**è°ƒç”¨ `Merger#merge(T... items)` æ–¹æ³•ï¼Œè¿›è¡Œåˆå¹¶ã€‚
- ç¬¬ 119 è‡³ 122 è¡Œï¼š**æ— ** Method ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸ã€‚

# 6ã€Configurator å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆäº”ï¼‰ä¹‹ Merger å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-5-impl-merger/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `configurator` åŒ…ï¼Œå®ç° Dubbo çš„**é…ç½®è§„åˆ™**åŠŸèƒ½ã€‚

Configurator ç›¸å…³ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

[![Configurator ç›¸å…³ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_25/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/01.png)Configurator ç›¸å…³ç±»

> è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” é…ç½®è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html) æ–‡æ¡£ã€‚å¦‚æœä¹‹å‰æ²¡äº†è§£è¿‡è¯¥åŠŸèƒ½çš„èƒ–å‹ï¼Œè¯·å…ˆé˜…è¯»äº†è§£ä¸‹å“ˆã€‚

## 2. ConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.ConfiguratorFactory` ï¼ŒConfigurator å·¥å‚æ¥å£ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
@SPI
public interface ConfiguratorFactory {

    /**
     * get the configurator instance.
     *
     * @param url - configurator url.
     * @return configurator instance.
     */
    @Adaptive("protocol")
    Configurator getConfigurator(URL url);

}
```

- `@SPI` æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œæ— é»˜è®¤å€¼ã€‚
- `@Adaptive("protocol")` æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Configurator å®ç°ï¼Œä½¿ç”¨ `URL.protocol` å±æ€§ã€‚
- `#getConfigurator(URL url)` æ¥å£æ–¹æ³•ï¼Œè·å¾— Configurator å¯¹è±¡ã€‚

#### 2.1 OverrideConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfiguratorFactory` ï¼Œå®ç° ConfiguratorFactory æ¥å£ï¼Œ**OverrideConfigurator** å·¥å‚ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class OverrideConfiguratorFactory implements ConfiguratorFactory {

    @Override
    public Configurator getConfigurator(URL url) {
        return new OverrideConfigurator(url);
    }

}
```

#### 2.2 AbsentConfiguratorFactory

`com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfiguratorFactory` ï¼Œå®ç° ConfiguratorFactory æ¥å£ï¼Œ**AbsentConfigurator** å·¥å‚ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class AbsentConfiguratorFactory implements ConfiguratorFactory {

    @Override
    public Configurator getConfigurator(URL url) {
        return new AbsentConfigurator(url);
    }

}
```

## 3. Configurator

`com.alibaba.dubbo.rpc.cluster.Configurator` ï¼Œå®ç° Comparable æ¥å£ï¼Œ**é…ç½®è§„åˆ™**æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public interface Configurator extends Comparable<Configurator> {

    /**
     * get the configurator url.
     *
     * é…ç½®è§„åˆ™
     *
     * @return configurator url.
     */
    URL getUrl();

    /**
     * Configure the provider url.
     *
     * é…ç½®åˆ° URL ä¸­
     *
     * @param url - old rovider url.
     * @return new provider url.
     */
    URL configure(URL url);

}
```

- **ä¸€ä¸ª Configurator å¯¹è±¡ï¼Œå¯¹åº”ä¸€æ¡é…ç½®è§„åˆ™**ã€‚
- Configurator æœ‰**ä¼˜å…ˆçº§**çš„è¦æ±‚ï¼Œæ‰€ä»¥å®ç° Comparable æ¥å£ã€‚
- `#getUrl()` æ¥å£æ–¹æ³•ï¼Œè·å¾—é…ç½® URL ï¼Œé‡Œé¢å¸¦æœ‰é…ç½®è§„åˆ™ã€‚
- `#configure(Url url)` æ¥å£æ–¹æ³•ï¼Œ**è®¾ç½®**é…ç½®è§„åˆ™åˆ°æŒ‡å®š URL ä¸­ã€‚

#### 3.1 AbstractConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.AbstractConfigurator` ï¼Œå®ç° Configurator æ¥å£ï¼Œå®ç°å…¬ç”¨çš„é…ç½®è§„åˆ™çš„**åŒ¹é…**ã€**æ’åº**çš„é€»è¾‘ã€‚

###### 3.1.1 getUrl

```
/**
 * é…ç½®è§„åˆ™ URL
 */
private final URL configuratorUrl;

public AbstractConfigurator(URL url) {
    if (url == null) {
        throw new IllegalArgumentException("configurator url == null");
    }
    this.configuratorUrl = url;
}

@Override
public URL getUrl() {
    return configuratorUrl;
}
```

###### 3.1.2 configure

```
 1: @Override
 2: public URL configure(URL url) {
 3:     if (configuratorUrl.getHost() == null || url == null || url.getHost() == null) {
 4:         return url;
 5:     }
 6:     // If override url has port, means it is a provider address. We want to control a specific provider with this override url, it may take effect on the specific provider instance or on consumers holding this provider instance.
 7:     // é…ç½®è§„åˆ™ï¼ŒURL å¸¦æœ‰ç«¯å£( port )ï¼Œæ„å›¾æ˜¯æ§åˆ¶æä¾›è€…æœºå™¨ã€‚å¯ä»¥åœ¨æä¾›ç«¯ç”Ÿæ•ˆ ä¹Ÿå¯ä»¥åœ¨æ¶ˆè´¹ç«¯ç”Ÿæ•ˆ
 8:     if (configuratorUrl.getPort() != 0) {
 9:         if (url.getPort() == configuratorUrl.getPort()) {
10:             return configureIfMatch(url.getHost(), url);
11:         }
12:     // override url don't have a port, means the ip override url specify is a consumer address or 0.0.0.0
13:     // é…ç½®è§„åˆ™ï¼ŒURL æ²¡æœ‰ç«¯å£ï¼Œoverride è¾“å…¥æ¶ˆè´¹ç«¯åœ°å€ æˆ–è€… 0.0.0.0
14:     } else {
15:         // 1.If it is a consumer ip address, the intention is to control a specific consumer instance, it must takes effect at the consumer side, any provider received this override url should ignore;
16:         // 2.If the ip is 0.0.0.0, this override url can be used on consumer, and also can be used on provider
17:         // 1. å¦‚æœæ˜¯æ¶ˆè´¹ç«¯åœ°å€ï¼Œåˆ™æ„å›¾æ˜¯æ§åˆ¶æ¶ˆè´¹è€…æœºå™¨ï¼Œå¿…å®šåœ¨æ¶ˆè´¹ç«¯ç”Ÿæ•ˆï¼Œæä¾›ç«¯å¿½ç•¥ï¼›
18:         // 2. å¦‚æœæ˜¯0.0.0.0å¯èƒ½æ˜¯æ§åˆ¶æä¾›ç«¯ï¼Œä¹Ÿå¯èƒ½æ˜¯æ§åˆ¶æä¾›ç«¯
19:         if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) {
20:             // NetUtils.getLocalHostæ˜¯æ¶ˆè´¹ç«¯æ³¨å†Œåˆ°zkçš„æ¶ˆè´¹è€…åœ°å€
21:             return configureIfMatch(NetUtils.getLocalHost(), url);// NetUtils.getLocalHost is the ip address consumer registered to registry.
22:         } else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) {
23:             // æ§åˆ¶æ‰€æœ‰æä¾›ç«¯ï¼Œåœ°å€å¿…å®šæ˜¯0.0.0.0ï¼Œå¦åˆ™å°±è¦é…ç«¯å£ä»è€Œæ‰§è¡Œä¸Šé¢çš„ifåˆ†æ”¯äº†
24:             return configureIfMatch(Constants.ANYHOST_VALUE, url);// take effect on all providers, so address must be 0.0.0.0, otherwise it won't flow to this if branch
25:         }
26:     }
27:     return url;
28: }
```

- æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œã€ç¬¬ 6 è‡³ 26 è¡Œã€‘ä¸€å…±æœ‰

  ä¸‰ç§

  æƒ…å†µçš„åˆ¤æ–­ï¼š

  - ã€ç¬¬ä¸€ç§ã€‘ç¬¬ 8 è¡Œï¼š `configuratorUrl` å¸¦æœ‰**ç«¯å£( port )**ï¼Œæ„å›¾æ˜¯åŒ¹é…**æŒ‡å®šä¸€ä¸ª**æœåŠ¡æä¾›è€…ï¼Œå› æ­¤ä½¿ç”¨ `url.host` å±æ€§ã€‚
  - ã€ç¬¬äºŒç§ã€‘ç¬¬ 19 è¡Œï¼š`url` çš„ `side = consumer` ï¼Œæ„å›¾æ˜¯åŒ¹é…æœåŠ¡æ¶ˆè´¹è€…ï¼Œå› æ­¤ä½¿ç”¨ `NetUtils#getLocalHost()` å±æ€§ã€‚
  - ã€ç¬¬ä¸‰ç§ã€‘ç¬¬ 22 è¡Œï¼š`url` çš„ `side = provider` ï¼Œæ„å›¾æ˜¯åŒ¹é…**å…¨éƒ¨**æœåŠ¡æä¾›è€…ï¼Œå› æ­¤ä½¿ç”¨ `Constants.ANYHOST_VALUE = *` å±æ€§ã€‚ğŸ™‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œç›®å‰æš‚ä¸æ”¯æŒ**æŒ‡å®šæœºå™¨**æœåŠ¡æä¾›è€…ã€‚

- ç¬¬ 10 è¡Œ || ç¬¬ 21 è¡Œ || ç¬¬ 24 è¡Œï¼šè°ƒç”¨ `#configureIfMatch(host, url)` æ–¹æ³•ï¼Œé…ç½®åˆ° `url` ä¸­ï¼Œè‹¥é…ç½®è§„åˆ™åŒ¹é…ã€‚

####### 3.1.2.1 configureIfMatch

```
 1: private URL configureIfMatch(String host, URL url) {
 2:     // åŒ¹é… Host
 3:     if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) {
 4:         // åŒ¹é… "application"
 5:         String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY, configuratorUrl.getUsername()); // TODO èŠ‹è‰¿ï¼Œä¸ºå•¥ username
 6:         String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());
 7:         if (configApplication == null || Constants.ANY_VALUE.equals(configApplication)
 8:                 || configApplication.equals(currentApplication)) {
 9:             // é…ç½® URL ä¸­çš„æ¡ä»¶ KEYS é›†åˆã€‚å…¶ä¸­ä¸‹é¢å››ä¸ª KEY ï¼Œä¸ç®—æ˜¯æ¡ä»¶ï¼Œè€Œæ˜¯å†…ç½®å±æ€§ã€‚è€ƒè™‘åˆ°ä¸‹é¢è¦ç§»é™¤ï¼Œæ‰€ä»¥æ·»åŠ åˆ°è¯¥é›†åˆä¸­ã€‚
10:             Set<String> conditionKeys = new HashSet<String>();
11:             conditionKeys.add(Constants.CATEGORY_KEY);
12:             conditionKeys.add(Constants.CHECK_KEY);
13:             conditionKeys.add(Constants.DYNAMIC_KEY);
14:             conditionKeys.add(Constants.ENABLED_KEY);
15:             // åˆ¤æ–­ä¼ å…¥çš„ url æ˜¯å¦åŒ¹é…é…ç½®è§„åˆ™ URL çš„æ¡ä»¶ã€‚é™¤äº† "application" å’Œ "side" ä¹‹å¤–ï¼Œå¸¦æœ‰ `"~"` å¼€å¤´çš„ KEY ï¼Œä¹Ÿæ˜¯æ¡ä»¶ã€‚
16:             for (Map.Entry<String, String> entry : configuratorUrl.getParameters().entrySet()) {
17:                 String key = entry.getKey();
18:                 String value = entry.getValue();
19:                 if (key.startsWith("~") || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) {
20:                     conditionKeys.add(key);
21:                     // è‹¥ä¸ç›¸ç­‰ï¼Œåˆ™ä¸åŒ¹é…é…ç½®è§„åˆ™ï¼Œç›´æ¥è¿”å›
22:                     if (value != null && !Constants.ANY_VALUE.equals(value)
23:                             && !value.equals(url.getParameter(key.startsWith("~") ? key.substring(1) : key))) {
24:                         return url;
25:                     }
26:                 }
27:             }
28:             // ç§»é™¤æ¡ä»¶ KEYS é›†åˆï¼Œå¹¶é…ç½®åˆ° URL ä¸­
29:             return doConfigure(url, configuratorUrl.removeParameters(conditionKeys));
30:         }
31:     }
32:     return url;
33: }
```

- ç¬¬ 3 è¡Œï¼šåŒ¹é… **HOST** ã€‚

- ç¬¬ 4 è‡³ 8 è¡Œï¼šåŒ¹é… **`"application"`** ã€‚

- ç¬¬ 9 è‡³ 14 è¡Œï¼šé…ç½® URL ä¸­çš„**æ¡ä»¶ KEYS é›†åˆ**ã€‚å…¶ä¸­ä¸‹é¢å››ä¸ª KEY ï¼Œä¸ç®—æ˜¯æ¡ä»¶ï¼Œè€Œæ˜¯**å†…ç½®å±æ€§**ã€‚è€ƒè™‘åˆ°ä¸‹é¢è¦ç§»é™¤ï¼Œæ‰€ä»¥æ·»åŠ åˆ°è¯¥é›†åˆä¸­ã€‚

- ç¬¬ 15 è‡³ 27 è¡Œï¼šåˆ¤æ–­ä¼ å…¥çš„

   

  ```
  url
  ```

   

  æ˜¯å¦åŒ¹é…é…ç½®è§„åˆ™ URL çš„æ¡ä»¶ã€‚é™¤äº†

   

  ```
  "application"
  ```

   

  å’Œ

   

  ```
  "side"
  ```

   

  ä¹‹å¤–ï¼Œ

  å¸¦æœ‰ `"~"` å¼€å¤´çš„ KEY ï¼Œä¹Ÿæ˜¯æ¡ä»¶

  ã€‚

  - ç¬¬ 21 è‡³ 25 è¡Œï¼š è‹¥**ä¸ç›¸ç­‰**ï¼Œåˆ™**ä¸åŒ¹é…**é…ç½®è§„åˆ™ï¼Œç›´æ¥è¿”å› `url` ã€‚

- ç¬¬ 29 è¡Œï¼šä» `configuratorUrl` **ç§»é™¤**æ¡ä»¶ KEYS é›†åˆï¼Œå¹¶è°ƒç”¨ `#doConfigure(URL currentUrl, URL configUrl)` **æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°**å­ç±»**è®¾ç½®**é…ç½®è§„åˆ™**åˆ° `url` ä¸­ã€‚

####### 3.1.2.2 doConfigure

```
protected abstract URL doConfigure(URL currentUrl, URL configUrl);
```

###### 3.1.3 compareTo

```
@Override
public int compareTo(Configurator o) {
    if (o == null) {
        return -1;
    }
    // host å‡åº
    int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());
    // è‹¥ host ç›¸åŒï¼ŒæŒ‰ç…§ priority é™åº
    if (ipCompare == 0) {//host is the same, sort by priority
        int i = getUrl().getParameter(Constants.PRIORITY_KEY, 0);
        int j = o.getUrl().getParameter(Constants.PRIORITY_KEY, 0);
        if (i < j) {
            return -1;
        } else if (i > j) {
            return 1;
        } else {
            return 0;
        }
    } else {
        return ipCompare;
    }
}
```

- ä¼˜å…ˆï¼ŒæŒ‰ç…§ host **å‡åº**ï¼Œå³**ç‰¹å®š** host **é«˜**äº **anyhost**( `"0.0.0.0"` ) ã€‚
- å…¶æ¬¡ï¼ŒæŒ‰ç…§ `"priority"` **é™åº**ã€‚

#### 3.2 OverrideConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.override.OverrideConfigurator` ï¼Œå®ç° AbstractConfigurator æŠ½è±¡ç±»ï¼Œ`override` Configurator å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class OverrideConfigurator extends AbstractConfigurator {

    public OverrideConfigurator(URL url) {
        super(url);
    }

    @Override
    public URL doConfigure(URL currentUrl, URL configUrl) {
        return currentUrl.addParameters(configUrl.getParameters()); // è¦†ç›–æ·»åŠ 
    }

}
```

- **è¦†ç›–**æ·»åŠ ã€‚

#### 3.3 AbsentConfigurator

`com.alibaba.dubbo.rpc.cluster.configurator.absent.AbsentConfigurator` ï¼Œå®ç° AbstractConfigurator æŠ½è±¡ç±»ï¼Œ`absent` Configurator å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class AbsentConfigurator extends AbstractConfigurator {

    public AbsentConfigurator(URL url) {
        super(url);
    }

    @Override
    public URL doConfigure(URL currentUrl, URL configUrl) {
        return currentUrl.addParametersIfAbsent(configUrl.getParameters()); // ä¸å­˜åœ¨æ—¶æ·»åŠ 
    }

}
```

- **ä¸å­˜åœ¨æ—¶**æ·»åŠ ã€‚

ä»ç›®å‰ `dubbo-admin` é¡¹ç›®æ¥çœ‹ï¼Œç›®å‰**æš‚æœªä½¿ç”¨** `absent` çš„é…ç½®è§„åˆ™ã€‚

## 4. é›†æˆ Configurator æ¨¡å—

å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ‰**ä¸‰ä¸ªç±»**ï¼Œè°ƒç”¨ `Configurator#configure(URL url)` æ–¹æ³•ï¼Œé›†æˆ Configurator æ¨¡å—ã€‚

[![é›†æˆ](http://static.iocoder.cn/images/Dubbo/2019_04_25/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/02.png)é›†æˆ

#### 4.1 RegistryDirectory

RegistryDirectory å°†é…ç½®è§„åˆ™é›†æˆåˆ°å…¶ä¸­ï¼Œä»è€Œé›†æˆåˆ°**æœåŠ¡æ¶ˆè´¹è€…**ä¸­ã€‚

###### 4.1.1 toConfigurators

`#toConfigurators(List<URL> urls)` æ–¹æ³•ï¼Œå®˜æ–¹æ³¨é‡Šå¦‚ä¸‹ï¼š

```
/**
 * å°†overrideURL è½¬æ¢ä¸º mapï¼Œä¾›é‡æ–° refer æ—¶ä½¿ç”¨.
 * æ¯æ¬¡ä¸‹å‘å…¨éƒ¨è§„åˆ™ï¼Œå…¨éƒ¨é‡æ–°ç»„è£…è®¡ç®—
 *
 * @param urls å¥‘çº¦ï¼š
 *             </br>1.override://0.0.0.0/...(æˆ–override://ip:port...?anyhost=true)&para1=value1...è¡¨ç¤ºå…¨å±€è§„åˆ™(å¯¹æ‰€æœ‰çš„æä¾›è€…å…¨éƒ¨ç”Ÿæ•ˆ)
 *             </br>2.override://ip:port...?anyhost=false ç‰¹ä¾‹è§„åˆ™ï¼ˆåªé’ˆå¯¹æŸä¸ªæä¾›è€…ç”Ÿæ•ˆï¼‰
 *             </br>3.ä¸æ”¯æŒoverride://è§„åˆ™... éœ€è¦æ³¨å†Œä¸­å¿ƒè‡ªè¡Œè®¡ç®—.
 *             </br>4.ä¸å¸¦å‚æ•°çš„override://0.0.0.0/ è¡¨ç¤ºæ¸…é™¤override
 *
 * @return Configurator é›†åˆ
 */
 public static List<Configurator> toConfigurators(List<URL> urls) {
    // ...çœç•¥ä»£ç 
 }
```

- å®é™…ä¸Šï¼Œè¯¥æ³¨é‡Šè¯´æ˜äº†é…ç½®è§„åˆ™ï¼Œåœ¨ RegistryDirectory ä¸­ï¼Œæ˜¯**å¦‚ä½•é›†æˆé…ç½®è§„åˆ™æ¨¡å—**ã€‚ç‰¹åˆ«æ˜¯**å››æ¡**å¥‘çº¦ï¼Œèƒ–å‹å¥½å¥½ç†è§£ä¸‹ã€‚

è¯¥æ–¹æ³•çš„çœŸæ­£æ³¨é‡Šï¼Œåº”è¯¥æ˜¯ï¼šå°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: public static List<Configurator> toConfigurators(List<URL> urls) {
 2:     // å¿½ç•¥ï¼Œè‹¥é…ç½®è§„åˆ™ URL é›†åˆä¸ºç©º
 3:     if (urls == null || urls.isEmpty()) {
 4:         return Collections.emptyList();
 5:     }
 6: 
 7:     // åˆ›å»º Configurator é›†åˆ
 8:     List<Configurator> configurators = new ArrayList<Configurator>(urls.size());
 9:     for (URL url : urls) {
10:         // è‹¥åè®®ä¸º `empty://` ï¼Œæ„å‘³ç€æ¸…ç©ºæ‰€æœ‰é…ç½®è§„åˆ™ï¼Œå› æ­¤è¿”å›ç©º Configurator é›†åˆ
11:         if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
12:             configurators.clear();
13:             break;
14:         }
15:         // å¯¹åº”ç¬¬ 4 æ¡å¥‘çº¦ï¼Œä¸å¸¦å‚æ•°çš„ override://0.0.0.0/ è¡¨ç¤ºæ¸…é™¤ override
16:         Map<String, String> override = new HashMap<String, String>(url.getParameters());
17:         // The anyhost parameter of override may be added automatically, it can't change the judgement of changing url
18:         // override ä¸Šçš„ anyhost å¯èƒ½æ˜¯è‡ªåŠ¨æ·»åŠ çš„ï¼Œä¸èƒ½å½±å“æ”¹å˜urlåˆ¤æ–­
19:         override.remove(Constants.ANYHOST_KEY);
20:         if (override.size() == 0) {
21:             configurators.clear();
22:             continue;
23:         }
24:         // è·å¾— Configurator å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° `configurators` ä¸­
25:         configurators.add(configuratorFactory.getConfigurator(url));
26:     }
27:     // æ’åº
28:     Collections.sort(configurators);
29:     return configurators;
30: }
```

- ç¬¬ 2 è‡³ 5 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥ `urls` é›†åˆä¸ºç©ºã€‚
- çš„ 8 è¡Œï¼šåˆ›å»º Configurator é›†åˆ `configurators` å˜é‡ã€‚
- ç¬¬ 9 è‡³ 26 è¡Œï¼š**å¾ªç¯** `urls` é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚ğŸ™‚ ä¸­é—´çš„è¿‡ç¨‹ï¼Œèƒ–å‹çœ‹ä¸‹æ³¨é‡Šã€‚
- ç¬¬ 28 è¡Œï¼šå°† `configurators` é›†åˆï¼Œ**æ’åº**ã€‚å…·ä½“çš„æ’åºè§„åˆ™ï¼Œåœ¨ [ã€Œ3.13 compareToã€](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/#) å·²ç»è§£æã€‚

###### 4.1.2 mergeUrl

```
 1: private URL mergeUrl(URL providerUrl) {
 2:     // åˆå¹¶æ¶ˆè´¹ç«¯å‚æ•°
 3:     providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
 4: 
 5:     // åˆå¹¶é…ç½®è§„åˆ™
 6:     List<Configurator> localConfigurators = this.configurators; // local reference
 7:     if (localConfigurators != null && !localConfigurators.isEmpty()) {
 8:         for (Configurator configurator : localConfigurators) {
 9:             providerUrl = configurator.configure(providerUrl);
10:         }
11:     }
12: 
13:     // ä¸æ£€æŸ¥è¿æ¥æ˜¯å¦æˆåŠŸï¼Œæ€»æ˜¯åˆ›å»º Invoker ï¼
14:     providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
15: 
16:     // The combination of directoryUrl and override is at the end of notify, which can't be handled here
17:     // ä»…åˆå¹¶æä¾›è€…å‚æ•°ï¼Œå› ä¸º directoryUrl ä¸ override åˆå¹¶æ˜¯åœ¨ notify çš„æœ€åï¼Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†
18:     this.overrideDirectoryUrl = this.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); // Merge the provider side parameters
19: 
20:     // ã€å¿½ç•¥ã€‘å› ä¸ºæ˜¯å¯¹ 1.0 ç‰ˆæœ¬çš„å…¼å®¹
21:     if ((providerUrl.getPath() == null || providerUrl.getPath().length() == 0)
22:             && "dubbo".equals(providerUrl.getProtocol())) { // Compatible version 1.0
23:         //fix by tony.chenl DUBBO-44
24:         String path = directoryUrl.getParameter(Constants.INTERFACE_KEY);
25:         if (path != null) {
26:             int i = path.indexOf('/');
27:             if (i >= 0) {
28:                 path = path.substring(i + 1);
29:             }
30:             i = path.lastIndexOf(':');
31:             if (i >= 0) {
32:                 path = path.substring(0, i);
33:             }
34:             providerUrl = providerUrl.setPath(path);
35:         }
36:     }
37: 
38:     // è¿”å›æœåŠ¡æä¾›è€… URL
39:     return providerUrl;
40: }
```

- ç¬¬ 5 è‡³ 11 è¡Œï¼šå¾ªç¯ `configurators` é›†åˆï¼Œè°ƒç”¨ `Configurator#configure(URL url)` æ–¹æ³•ï¼Œåˆå¹¶**é…ç½®è§„åˆ™**åˆ° `providerUrl` ä¸­ã€‚
- ç¬¬ 14 è¡Œï¼š**ä»…**åˆå¹¶æä¾›è€…å‚æ•°åˆ° `overrideDirectoryUrl` ä¸­ï¼Œå› ä¸º `directoryUrl` ä¸é…ç½®è§„åˆ™çš„åˆå¹¶æ˜¯åœ¨ `#notify(List<URL> urls)` æ–¹æ³•çš„**æœ€å**ï¼Œå› è€Œè¿™é‡Œä¸èƒ½å¤Ÿå¤„ç†ã€‚ä»£ç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š[![notify](http://static.iocoder.cn/images/Dubbo/2019_04_25/03.png)](http://static.iocoder.cn/images/Dubbo/2019_04_25/03.png)notify

#### 4.2 RegistryProtocol

RegistryProtocol é€šè¿‡å‘**æ³¨å†Œä¸­å¿ƒ**æ³¨å†Œ OverrideListener ç›‘å¬å™¨ï¼Œä»è€Œé›†æˆé…ç½®è§„åˆ™åˆ°**æœåŠ¡æä¾›è€…**ä¸­ã€‚

###### 4.2.1 export

```
 1: @Override
 2: public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
 3:     // æš´éœ²æœåŠ¡
 4:     // export invoker
 5:     final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);
 6: 
 7:     // è·å¾—æ³¨å†Œä¸­å¿ƒ URL
 8:     URL registryUrl = getRegistryUrl(originInvoker);
 9: 
10:     // è·å¾—æ³¨å†Œä¸­å¿ƒå¯¹è±¡
11:     // registry provider
12:     final Registry registry = getRegistry(originInvoker);
13: 
14:     // è·å¾—æœåŠ¡æä¾›è€… URL
15:     final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);
16: 
17:     //to judge to delay publish whether or not
18:     boolean register = registedProviderUrl.getParameter("register", true);
19: 
20:     // å‘æ³¨å†Œä¸­å¿ƒè®¢é˜…æœåŠ¡æ¶ˆè´¹è€…
21:     ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);
22: 
23:     // å‘æ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡æä¾›è€…ï¼ˆè‡ªå·±ï¼‰
24:     if (register) {
25:         register(registryUrl, registedProviderUrl);
26:         ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); // // æ ‡è®°å‘æœ¬åœ°æ³¨å†Œè¡¨çš„æ³¨å†ŒæœåŠ¡æä¾›è€…ï¼Œå·²ç»æ³¨å†Œ
27:     }
28: 
29:     // ä½¿ç”¨ OverrideListener å¯¹è±¡ï¼Œè®¢é˜…é…ç½®è§„åˆ™
30:     // Subscribe the override data
31:     // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.
32:     // åˆ›å»ºè®¢é˜…é…ç½®è§„åˆ™çš„ URL
33:     final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);
34:     // åˆ›å»º OverrideListener å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° `overrideListeners` ä¸­
35:     final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
36:     overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);
37:     // å‘æ³¨å†Œä¸­å¿ƒï¼Œå‘èµ·è®¢é˜…
38:     registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);
39:     //Ensure that a new exporter instance is returned every time export
40:     return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);
41: }
```

- ç¬¬ 29 è‡³ 38 è¡Œï¼šä½¿ç”¨ **OverrideListener** å¯¹è±¡ï¼Œè®¢é˜…é…ç½®è§„åˆ™ã€‚

  - ç¬¬ 33 è¡Œï¼šè°ƒç”¨ `#getSubscribedOverrideUrl(registedProviderUrl)` æ–¹æ³•ï¼Œåˆ›å»º**è®¢é˜…é…ç½®è§„åˆ™**çš„ URL ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    private URL getSubscribedOverrideUrl(URL registedProviderUrl) {
        return registedProviderUrl.setProtocol(Constants.PROVIDER_PROTOCOL)
                .addParameters(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY, // configurators
                        Constants.CHECK_KEY, String.valueOf(false)); // è®¢é˜…å¤±è´¥ï¼Œä¸æ ¡éªŒ
    }
    ```

    - x

  - ç¬¬ 34 è‡³ 36 è¡Œï¼šåˆ›å»º **OverrideListener** å¯¹è±¡ï¼Œå¹¶æ·»åŠ åˆ° `overrideListeners` ä¸­ã€‚

  - ç¬¬ 38 è¡Œï¼šè°ƒç”¨ `Registry#subscribe(overrideSubscribeUrl, overrideSubscribeListener)` æ–¹æ³•ï¼Œå‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ **OverrideListener** ç›‘å¬å™¨ï¼Œè®¢é˜…é…ç½®è§„åˆ™çš„å˜åŒ–ã€‚

###### 4.2.2 OverrideListener

OverrideListener æ˜¯ RegistryProtocol **å†…éƒ¨ç±»**ï¼Œå®ç° NotifyListener æ¥å£ï¼Œå®˜æ–¹æ³¨é‡Šå¦‚ä¸‹ï¼š

```
/**
 * é‡æ–° export ï¼šprotocol ä¸­çš„ exporter destroy é—®é¢˜
 *
 * 1. è¦æ±‚ registry protocol è¿”å›çš„ exporter å¯ä»¥æ­£å¸¸ destroy
 * 2. notify åä¸éœ€è¦é‡æ–°å‘æ³¨å†Œä¸­å¿ƒæ³¨å†Œ
 * 3. export æ–¹æ³•ä¼ å…¥çš„ invoker æœ€å¥½èƒ½ä¸€ç›´ä½œä¸º exporter çš„ invoker.
 */
```

- åˆçœ‹æœ‰ç‚¹ç»•ï¼Œæˆ‘ä»¬æ¥ç…ç…ä»£ç ã€‚

####### 4.2.2.1 æ„é€ æ–¹æ³•

```
/**
 * è®¢é˜… URL å¯¹è±¡
 */
private final URL subscribeUrl;
/**
 * åŸå§‹ Invoker å¯¹è±¡
 */
private final Invoker originInvoker;

public OverrideListener(URL subscribeUrl, Invoker originalInvoker) {
    this.subscribeUrl = subscribeUrl;
    this.originInvoker = originalInvoker;
}
```

####### 4.2.2.2 notify

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // è·å¾—åŒ¹é…çš„è§„åˆ™é…ç½® URL é›†åˆ
 4:     logger.debug("original override urls: " + urls);
 5:     List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl);
 6:     logger.debug("subscribe url: " + subscribeUrl + ", override urls: " + matchedUrls);
 7:     // No matching results
 8:     if (matchedUrls.isEmpty()) {
 9:         return;
10:     }
11:     // å°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆ
12:     List<Configurator> configurators = RegistryDirectory.toConfigurators(matchedUrls);
13: 
14:     // è·å¾—çœŸå®çš„ Invoker å¯¹è±¡
15:     final Invoker<?> invoker;
16:     if (originInvoker instanceof InvokerDelegete) {
17:         invoker = ((InvokerDelegete<?>) originInvoker).getInvoker();
18:     } else {
19:         invoker = originInvoker;
20:     }
21:     // The origin invoker
22:     // è·å¾—çœŸå®çš„ Invoker çš„ URL å¯¹è±¡
23:     URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);
24: 
25:     // å¿½ç•¥ï¼Œè‹¥å¯¹åº”çš„ Exporter å¯¹è±¡ä¸å­˜åœ¨
26:     String key = getCacheKey(originInvoker);
27:     ExporterChangeableWrapper<?> exporter = bounds.get(key);
28:     if (exporter == null) {
29:         logger.warn(new IllegalStateException("error state, exporter should not be null"));
30:         return;
31:     }
32: 
33:     // The current, may have been merged many times
34:     // è·å¾— Invoker å½“å‰çš„ URL å¯¹è±¡ï¼Œå¯èƒ½å·²ç»è¢«ä¹‹å‰çš„é…ç½®è§„åˆ™åˆå¹¶è¿‡
35:     URL currentUrl = exporter.getInvoker().getUrl();
36:     // Merged with this configuration
37:     // åŸºäº originUrl å¯¹è±¡ï¼Œåˆå¹¶é…ç½®è§„åˆ™ï¼Œç”Ÿæˆæ–°çš„ newUrl å¯¹è±¡
38:     URL newUrl = getConfigedInvokerUrl(configurators, originUrl);
39:     // åˆ¤æ–­æ–°è€ Url ä¸åŒ¹é…ï¼Œé‡æ–°æš´éœ² Invoker
40:     if (!currentUrl.equals(newUrl)) {
41:         RegistryProtocol.this.doChangeLocalExport(originInvoker, newUrl);
42:         logger.info("exported provider url changed, origin url: " + originUrl + ", old export url: " + currentUrl + ", new export url: " + newUrl);
43:     }
44: }
```

- ç¬¬ 3 è‡³ 10 è¡Œï¼šè°ƒç”¨ `#getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe)` æ–¹æ³•ï¼Œè·å¾—åŒ¹é…çš„**è§„åˆ™é…ç½®** URL é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {
      List<URL> result = new ArrayList<URL>();
      for (URL url : configuratorUrls) {
          URL overrideUrl = url;
          // ã€å¿½ç•¥ã€‘ï¼Œå…¼å®¹è€ç‰ˆæœ¬
          // Compatible with the old version
          if (url.getParameter(Constants.CATEGORY_KEY) == null
                  && Constants.OVERRIDE_PROTOCOL.equals(url.getProtocol())) {
              overrideUrl = url.addParameter(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);
          }
          // åˆ¤æ–­æ˜¯å¦åŒ¹é…
          // Check whether url is to be applied to the current service
          if (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {
              result.add(url);
          }
      }
      return result;
  }
  ```

  - é€šè¿‡è°ƒç”¨ `UrlUtils#isMatch(currentSubscribe, overrideUrl)` æ–¹æ³•ï¼Œè¿›è¡Œåˆ¤æ–­**æ˜¯å¦åŒ¹é…**ã€‚è¯¥æ–¹æ³•å…·ä½“å®ç°çš„é€»è¾‘ï¼Œæ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥åˆ¤æ–­è‡ªå·±æŸ¥çœ‹ã€‚

- ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `RegistryDirectory#toConfigurators(matchedUrls)` æ–¹æ³•ï¼Œå°†é…ç½®è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Configurator é›†åˆã€‚

- ç¬¬ 14 è‡³ 23 è¡Œï¼šè·å¾—**çœŸå®**çš„ Invoker å’Œ**å¯¹åº”**çš„ URL å¯¹åº”ã€‚

- ç¬¬ 25 è‡³ 31 è¡Œï¼š**å¿½ç•¥**ï¼Œè‹¥å¯¹åº”çš„ Exporter å¯¹è±¡ä¸å­˜åœ¨ã€‚

- ========== **é‡ç‚¹** ==========

- ç¬¬ 35 è¡Œï¼šé€šè¿‡ `exporter` çš„ Invoker ï¼Œè·å¾— Invoker **å½“å‰**çš„ URL å¯¹è±¡ï¼Œ**å¯èƒ½å·²ç»è¢«ä¹‹å‰çš„é…ç½®è§„åˆ™åˆå¹¶è¿‡**ã€‚

- ç¬¬ 38 è¡Œï¼šè°ƒç”¨ `#getConfigedInvokerUrl(configurators,originUrl)` æ–¹æ³•ï¼ŒåŸºäº `originUrl` å¯¹è±¡ï¼Œ**åˆå¹¶é…ç½®è§„åˆ™**ï¼Œç”Ÿæˆ**æ–°çš„** `newUrl` å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {
      for (Configurator configurator : configurators) {
          // åˆå¹¶é…ç½®è§„åˆ™
          url = configurator.configure(url);
      }
      return url;
  }
  ```

- ç¬¬ 39 è‡³ 43 è¡Œï¼šåˆ¤æ–­æ–°è€ URL è‹¥**ä¸åŒ¹é…**ï¼Œè°ƒç”¨ `RegistryProtocol#doChangeLocalExport(originInvoker, newUrl)` æ–¹æ³•ï¼Œ**é‡æ–°æš´éœ²** Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ4.2.3 doChangeLocalExportã€](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/#) ã€‚

###### 4.2.3 doChangeLocalExport

```
 1: private <T> void doChangeLocalExport(final Invoker<T> originInvoker, URL newInvokerUrl) {
 2:     // æ ¡éªŒå¯¹åº”çš„ Exporter æ˜¯å¦å­˜åœ¨ã€‚è‹¥ä¸å­˜åœ¨ï¼Œæ‰“å°å‘Šè­¦æ—¥å¿—ã€‚
 3:     String key = getCacheKey(originInvoker);
 4:     final ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);
 5:     if (exporter == null) {
 6:         logger.warn(new IllegalStateException("error state, exporter should not be null"));
 7:     } else {
 8:         // åˆ›å»º InvokerDelegete å¯¹è±¡
 9:         final Invoker<T> invokerDelegete = new InvokerDelegete<T>(originInvoker, newInvokerUrl);
10:         // é‡æ–°æš´éœ² Invoker
11:         // è®¾ç½®åˆ° ExporterChangeableWrapper ä¸­
12:         exporter.setExporter(protocol.export(invokerDelegete));
13:     }
14: }
```

- ç¬¬ 2 è‡³ 6 è¡Œï¼š**æ ¡éªŒ**å¯¹åº”çš„ ExporterChangeableWrapper æ˜¯å¦å­˜åœ¨ã€‚è‹¥ä¸å­˜åœ¨ï¼Œæ‰“å°**å‘Šè­¦**æ—¥å¿—ã€‚

- ç¬¬ 9 è¡Œï¼šåˆ›å»º InvokerDelegete å¯¹è±¡ã€‚

- ç¬¬ 12 è¡Œï¼šè°ƒç”¨

   

  ```
  Protocol$Adaptive#export(Invoker)
  ```

   

  æ–¹æ³•ï¼Œ

  é‡æ–°æš´éœ²

   

  Invoker å¯¹è±¡ã€‚

  ğŸ˜ˆ å¯èƒ½ä¼šæœ‰æœºæ™ºçš„èƒ–å‹ä¼šé—®ï¼ŒåŸæ¥çš„ Exporter ä¸è¿›è¡Œ

  é”€æ¯

  ä¹ˆ?å®é™…ä¸Š

  ä¸éœ€è¦

  ï¼ŒåŸå› æœ‰ä¸¤ç‚¹ï¼š

  - 1ã€æ¯ä¸ªåè®®åˆå§‹åŒ–çš„ Server æœ‰**ç¼“å­˜** ï¼Œæ‰€ä»¥é‡æ–°åˆå§‹åŒ–ï¼Œå¯ä»¥é‡ç”¨**ç¼“å­˜**ä¸­çš„ Server ã€‚
  - 2ã€å¦‚æœ**é”€æ¯**åŸæœ‰ Exporter ï¼Œä¼šå¯¼è‡´**ç¼“å­˜**çš„ Server ä¹Ÿä¸€èµ·é”€æ¯ã€‚**è€Œä¸”ï¼Œå³ä½¿ä¸é”€æ¯ï¼ŒåŸæœ‰ Exporter ä¹Ÿå°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¯ä»¥è¢«å›æ”¶æ‰**ã€‚

- ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `ExporterChangeableWrapper#setExporter(exporter)` æ–¹æ³•ï¼Œè®¾ç½®**æ–°çš„** Exporter å¯¹è±¡ã€‚

#### 4.3 ServiceConfig

TODO 8038 ServiceConfig ä¸ºå•¥åˆ¤æ–­äº† url.protocol

# 7ã€Router å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…­ï¼‰ä¹‹ Configurator å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-6-impl-configurator/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `router` åŒ…ï¼Œå®ç° Dubbo çš„**è·¯ç”±è§„åˆ™**åŠŸèƒ½ã€‚

Router ç›¸å…³ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

[![Router ç›¸å…³ç±»](http://static.iocoder.cn/images/Dubbo/2019_04_30/02.png)](http://static.iocoder.cn/images/Dubbo/2019_04_30/02.png)Router ç›¸å…³ç±»

> è€è‰¿è‰¿ï¼šæœ¬æ–‡å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è·¯ç”±è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html) æ–‡æ¡£ã€‚å¦‚æœä¹‹å‰æ²¡äº†è§£è¿‡è¯¥åŠŸèƒ½çš„èƒ–å‹ï¼Œè¯·å…ˆé˜…è¯»äº†è§£ä¸‹å“ˆã€‚

## 2. RouterFactory

`com.alibaba.dubbo.rpc.cluster.RouterFactory` ï¼ŒRouter å·¥å‚**æ¥å£**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
@SPI
public interface RouterFactory {

    /**
     * Create router.
     *
     * åˆ›å»º Router å¯¹è±¡
     *
     * @param url
     * @return router
     */
    @Adaptive("protocol")
    Router getRouter(URL url);

}
```

- `@SPI` æ³¨è§£ï¼ŒDubbo SPI **æ‹“å±•ç‚¹**ï¼Œæ— é»˜è®¤å€¼ã€‚
- `@Adaptive("protocol")` æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Adaptive æœºåˆ¶ï¼ŒåŠ è½½å¯¹åº”çš„ Router å®ç°ï¼Œä½¿ç”¨ `URL.protocol` å±æ€§ã€‚
- `#getRouter(URL url)` æ¥å£æ–¹æ³•ï¼Œè·å¾— Router å¯¹è±¡ã€‚

#### 2.1 ConditionRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouterFactory` ï¼Œå®ç° RouterFactory æ¥å£ï¼Œ**ConditionRouter** å·¥å‚å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class ConditionRouterFactory implements RouterFactory {

    public static final String NAME = "condition";

    @Override
    public Router getRouter(URL url) {
        return new ConditionRouter(url);
    }

}
```

- å¯¹åº” Router å®ç°ç±»ä¸º ConditionRouter ã€‚

#### 2.2 ScriptRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouterFactory` ï¼Œå®ç° RouterFactory æ¥å£ï¼Œ**ScriptRouter** å·¥å‚å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class ScriptRouterFactory implements RouterFactory {

    public static final String NAME = "script";

    @Override
    public Router getRouter(URL url) {
        return new ScriptRouter(url);
    }

}
```

- å¯¹åº” Router å®ç°ç±»ä¸º ScriptRouter ã€‚

#### 2.3 FileRouterFactory

`com.alibaba.dubbo.rpc.cluster.router.file.FileRouterFactory` ï¼Œå®ç° RouterFactory æ¥å£ï¼ŒåŸºäº**æ–‡ä»¶**è¯»å–è·¯ç”±è§„åˆ™ï¼Œåˆ›å»º**å¯¹åº”çš„ Router å®ç°ç±»çš„å¯¹è±¡**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: public class FileRouterFactory implements RouterFactory {
 2: 
 3:     public static final String NAME = "file";
 4: 
 5:     /**
 6:      * RouterFactory$Adaptive å¯¹è±¡
 7:      */
 8:     private RouterFactory routerFactory;
 9: 
10:     public void setRouterFactory(RouterFactory routerFactory) {
11:         this.routerFactory = routerFactory;
12:     }
13: 
14:     @Override
15:     public Router getRouter(URL url) {
16:         try {
17:             // Transform File URL into Script Route URL, and Load
18:             // file:///d:/path/to/route.js?router=script ==> script:///d:/path/to/route.js?type=js&rule=<file-content>
19:             // è·å¾— router é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º script
20:             String protocol = url.getParameter(Constants.ROUTER_KEY, ScriptRouterFactory.NAME); // Replace original protocol (maybe 'file') with 'script'
21:             // ä½¿ç”¨æ–‡ä»¶åç¼€åšä¸ºç±»å‹
22:             String type = null; // Use file suffix to config script type, e.g., js, groovy ...
23:             String path = url.getPath();
24:             if (path != null) {
25:                 int i = path.lastIndexOf('.');
26:                 if (i > 0) {
27:                     type = path.substring(i + 1);
28:                 }
29:             }
30:             // è¯»å–è§„åˆ™å†…å®¹
31:             String rule = IOUtils.read(new FileReader(new File(url.getAbsolutePath())));
32: 
33:             // åˆ›å»ºè·¯ç”±è§„åˆ™ URL
34:             boolean runtime = url.getParameter(Constants.RUNTIME_KEY, false);
35:             URL script = url.setProtocol(protocol).addParameter(Constants.TYPE_KEY, type)
36:                     .addParameter(Constants.RUNTIME_KEY, runtime)
37:                     .addParameterAndEncoded(Constants.RULE_KEY, rule);
38: 
39:             // é€šè¿‡ Dubbo SPI Adaptive æœºåˆ¶ï¼Œè·å¾— Router å¯¹è±¡
40:             return routerFactory.getRouter(script);
41:         } catch (IOException e) {
42:             throw new IllegalStateException(e.getMessage(), e);
43:         }
44:     }
45: 
46: }
```

- ç¬¬ 20 è¡Œï¼šè·å¾— `"router"` é…ç½®é¡¹ï¼Œé»˜è®¤ä¸º `"script"` ã€‚
- ç¬¬ 21 è‡³ 29 è¡Œï¼šè·å¾—**ç±»å‹**ï¼ŒåŸºäºæ–‡ä»¶åç¼€ã€‚
- ç¬¬ 31 è¡Œï¼šä»**æ–‡ä»¶**ä¸­ï¼Œè¯»å–**è§„åˆ™å†…å®¹**ã€‚
- ç¬¬ 33 è‡³ 37 è¡Œï¼šåˆ›å»ºè·¯ç”±è§„åˆ™ URL å¯¹è±¡ã€‚
- ç¬¬ 40 è¡Œï¼šé€šè¿‡ Dubbo SPI **Adaptive** æœºåˆ¶ï¼Œè·å¾—**å¯¹åº”çš„ Router å¯¹è±¡**ã€‚

## 3. Router

`com.alibaba.dubbo.rpc.cluster.Router` ï¼Œå®ç° Comparable æ¥å£ï¼Œ**è·¯ç”±è§„åˆ™**æ¥å£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public interface Router extends Comparable<Router> {

    /**
     * get the router url.
     * <p>
     * è·¯ç”±è§„åˆ™ URL
     *
     * @return url
     */
    URL getUrl();

    /**
     * route.
     *
     * è·¯ç”±ï¼Œç­›é€‰åŒ¹é…çš„ Invoker é›†åˆ
     *
     * @param invokers   Invoker é›†åˆ
     * @param url        refer url
     * @param invocation
     * @return routed invokers è·¯ç”±åçš„ Invoker é›†åˆ
     * @throws RpcException
     */
    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;

}
```

- **ä¸€ä¸ª Router å¯¹è±¡ï¼Œå¯¹åº”ä¸€æ¡è·¯ç”±è§„åˆ™**ã€‚
- Configurator æœ‰**ä¼˜å…ˆçº§**çš„è¦æ±‚ï¼Œæ‰€ä»¥å®ç° Comparable æ¥å£ã€‚
- `#getUrl()` æ¥å£æ–¹æ³•ï¼Œè·å¾—è·¯ç”± URL ï¼Œé‡Œé¢å¸¦æœ‰è·¯ç”±è§„åˆ™ã€‚
- `#route(List<Invoker<T>> invokers, URL url, Invocation invocation)` æ¥å£æ–¹æ³•ï¼Œè·¯ç”±ï¼Œç­›é€‰**åŒ¹é…çš„** Invoker é›†åˆã€‚

#### 3.1 ConditionRouter

`com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouter` ï¼Œå®ç° Router æ¥å£ï¼Œ**åŸºäºæ¡ä»¶è¡¨è¾¾å¼**çš„ Router å®ç°ç±»ã€‚

> åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„è·¯ç”±è§„åˆ™ï¼Œå¦‚ï¼š`host = 10.20.153.10 => host = 10.20.153.11`

**æ³¨æ„**ï¼Œèƒ–å‹ä¸€å®šè¦çœ‹äº† [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” è·¯ç”±è§„åˆ™ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#æ¡ä»¶è·¯ç”±è§„åˆ™) çš„ [æ¡ä»¶è·¯ç”±è§„åˆ™](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) éƒ¨åˆ†ï¼Œä¸ç„¶ä¸‹é¢å½±å“ç†è§£ã€‚

###### 3.1.1 æ„é€ æ–¹æ³•

```
/**
 * åˆ†ç»„æ­£åˆ™åŒ¹é…ï¼Œè¯¦ç»†è§ {@link #parseRule(String)} æ–¹æ³•
 *
 * å‰ [] ä¸ºåŒ¹é…ï¼Œåˆ†éš”ç¬¦
 * å [] ä¸ºåŒ¹é…ï¼Œå†…å®¹
 */
private static Pattern ROUTE_PATTERN = Pattern.compile("([&!=,]*)\\s*([^&!=,\\s]+)");

/**
 * è·¯ç”±è§„åˆ™ URL
 */
private final URL url;
/**
 * è·¯ç”±è§„åˆ™çš„ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º 0 ã€‚
 */
private final int priority;
/**
 * å½“è·¯ç”±ç»“æœä¸ºç©ºæ—¶ï¼Œæ˜¯å¦å¼ºåˆ¶æ‰§è¡Œï¼Œå¦‚æœä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè·¯ç”±ç»“æœä¸ºç©ºçš„è·¯ç”±è§„åˆ™å°†è‡ªåŠ¨å¤±æ•ˆï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º false ã€‚
 */
private final boolean force;
/**
 * æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶é›†åˆï¼Œé€šè¿‡è§£æã€æ¡ä»¶è¡¨è¾¾å¼ rule çš„ `=>` ä¹‹å‰åŠéƒ¨åˆ†ã€‘
 */
private final Map<String, MatchPair> whenCondition;
/**
 * æä¾›è€…åœ°å€åˆ—è¡¨çš„è¿‡æ»¤æ¡ä»¶ï¼Œé€šè¿‡è§£æã€æ¡ä»¶è¡¨è¾¾å¼ rule çš„ `=>` ä¹‹ååŠéƒ¨åˆ†ã€‘
 */
private final Map<String, MatchPair> thenCondition;

public ConditionRouter(URL url) {
    this.url = url;
    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
    this.force = url.getParameter(Constants.FORCE_KEY, false);
    try {
        // æ‹†åˆ†æ¡ä»¶å˜å¤§æ—¶ä¸º when å’Œ then ä¸¤éƒ¨åˆ†
        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
        if (rule == null || rule.trim().length() == 0) {
            throw new IllegalArgumentException("Illegal route rule!");
        }
        rule = rule.replace("consumer.", "").replace("provider.", "");
        int i = rule.indexOf("=>");
        String whenRule = i < 0 ? null : rule.substring(0, i).trim();
        String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
        // è§£æ `whenCondition`
        Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || "true".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
        // è§£æ `thenCondition`
        Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || "false".equals(thenRule) ? null : parseRule(thenRule);
        // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
        this.whenCondition = when;
        this.thenCondition = then;
    } catch (ParseException e) {
        throw new IllegalStateException(e.getMessage(), e);
    }
}
```

- æ¯ä¸ªå­—æ®µçš„è§£é‡Šï¼Œèƒ–å‹è‡ªå·±çœ‹ä¸‹æ³¨é‡Šã€‚
- MatchPair ï¼Œè§ [ã€Œ3.1.2 MatchPairã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) ä¸­ã€‚
- `#parseRule()` æ–¹æ³•ï¼Œè§ [ã€Œ3.1.3 parseRuleã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) ä¸­ã€‚

###### 3.1.2 MatchPair

MatchPair ä¸º ConditionRouter çš„**å†…éƒ¨é™æ€ç±»**ï¼Œç”¨äºåŒ¹é…çš„å€¼**ç»„**ã€‚**æ¯ä¸ª**å±æ€§æ¡ä»¶ï¼Œä¾‹å¦‚ `method` `host` ç­‰ï¼Œå¯¹åº”**ä¸€ä¸ª** MatchPair å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
private static final class MatchPair {

    /**
     * åŒ¹é…çš„å€¼é›†åˆ
     */
    final Set<String> matches = new HashSet<String>();
    /**
     * ä¸åŒ¹é…çš„å€¼é›†åˆ
     */
    final Set<String> mismatches = new HashSet<String>();

    /**
     * åˆ¤æ–­ value æ˜¯å¦åŒ¹é… matches + mismatches
     *
     * @param value å€¼
     * @param param URL
     * @return æ˜¯å¦åŒ¹é…
     */
    private boolean isMatch(String value, URL param) {
        // åªåŒ¹é… matches
        if (!matches.isEmpty() && mismatches.isEmpty()) {
            for (String match : matches) {
                if (UrlUtils.isMatchGlobPattern(match, value, param)) {
                    return true;
                }
            }
            return false; // å¦‚æœæ²¡åŒ¹é…ä¸Šï¼Œè®¤ä¸ºä¸º false ï¼Œå³ä¸åŒ¹é…
        }

        // åªåŒ¹é… mismatches
        if (!mismatches.isEmpty() && matches.isEmpty()) {
            for (String mismatch : mismatches) {
                if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
                    return false;
                }
            }
            return true; // æ³¨æ„ï¼Œè¿™é‡Œå’Œä¸Šé¢ä¸åŒã€‚åŸå› ï¼Œä½ æ‡‚çš„ã€‚
        }

        // åŒ¹é… mismatches + matches
        if (!matches.isEmpty()) {
            //when both mismatches and matches contain the same value, then using mismatches first
            for (String mismatch : mismatches) {
                if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) {
                    return false;
                }
            }
            for (String match : matches) {
                if (UrlUtils.isMatchGlobPattern(match, value, param)) {
                    return true;
                }
            }
            return false; // å¦‚æœæ²¡åŒ¹é…ä¸Šï¼Œè®¤ä¸ºä¸º false ï¼Œå³ä¸åŒ¹é…
        }
        return false;
    }
}
```

- `#isMatch(String value, URL param)` æ–¹æ³•ï¼Œåˆ¤æ–­ `value` æ˜¯å¦**åŒ¹é…** `matches` å’Œ `mismatches` ã€‚

  - é‚£ä¹ˆä¸ºä»€ä¹ˆä¼šæœ‰ `param` å‚æ•°å‘¢ï¼Ÿå› ä¸ºè¦æ”¯æŒ `$` ä» URL ä¸­ï¼Œè¯»å–å‚æ•°ã€‚

  - `#UrlUtils#isMatchGlobPattern(match, value, URL)` æ–¹æ³•ï¼Œæ”¯æŒ `*` é€šé…ï¼Œåˆ¤æ–­ `match` å’Œ `value` æ˜¯å¦åŒ¹é…ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    public static boolean isMatchGlobPattern(String pattern, String value, URL param) {
        // ä»¥ç¾å…ƒç¬¦ `$` å¼€å¤´ï¼Œè¡¨ç¤ºå¼•ç”¨å‚æ•°
        if (param != null && pattern.startsWith("$")) {
            pattern = param.getRawParameter(pattern.substring(1));
        }
        // åŒ¹é…
        return isMatchGlobPattern(pattern, value);
    }
    
    public static boolean isMatchGlobPattern(String pattern, String value) {
        // å…¨åŒ¹é…
        if ("*".equals(pattern)) {
            return true;
        }
        // å…¨éƒ¨ä¸ºç©ºï¼ŒåŒ¹é…
        if ((pattern == null || pattern.length() == 0) && (value == null || value.length() == 0)) {
            return true;
        }
        // æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œä¸åŒ¹é…
        if ((pattern == null || pattern.length() == 0) || (value == null || value.length() == 0)) {
            return false;
        }
    
        // æ”¯æŒ * çš„é€šé…
        int i = pattern.lastIndexOf('*');
        // doesn't find "*"
        if (i == -1) {
            return value.equals(pattern);
        }
        // "*" is at the end
        else if (i == pattern.length() - 1) {
            return value.startsWith(pattern.substring(0, i));
        }
        // "*" is at the beginning
        else if (i == 0) {
            return value.endsWith(pattern.substring(i + 1));
        }
        // "*" is in the middle
        else {
            String prefix = pattern.substring(0, i);
            String suffix = pattern.substring(i + 1);
            return value.startsWith(prefix) && value.endsWith(suffix);
        }
    }
    ```

    - x

ğŸ˜ˆ ä»£ç æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥èƒ–å‹è‡ªå·±è¯»ä¸‹ã€‚

###### 3.1.3 parseRule

`#parseRule(rule)` æ–¹æ³•ï¼Œè§£æè·¯ç”±é…ç½®å†…å®¹ `"rule"` ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: private static Map<String, MatchPair> parseRule(String rule) throws ParseException {
 2: //    System.out.println("rule: " + rule); // add by èŠ‹è‰¿ï¼Œæ–¹ä¾¿å¤§å®¶çœ‹
 3:     Map<String, MatchPair> condition = new HashMap<String, MatchPair>();
 4:     if (StringUtils.isBlank(rule)) {
 5:         return condition;
 6:     }
 7:     // Key-Value pair, stores both match and mismatch conditions
 8:     MatchPair pair = null;
 9:     // Multiple values
10:     Set<String> values = null;
11:     final Matcher matcher = ROUTE_PATTERN.matcher(rule);
12:     while (matcher.find()) { // Try to match one by one
13:         String separator = matcher.group(1);
14:         String content = matcher.group(2);
15: //        System.out.println(separator + "\t" + content); // add by èŠ‹è‰¿ï¼Œæ–¹ä¾¿å¤§å®¶çœ‹
16:         // Start part of the condition expression.
17:         if (separator == null || separator.length() == 0) {
18:             pair = new MatchPair();
19:             condition.put(content, pair);
20:         }
21:         // The KV part of the condition expression
22:         else if ("&".equals(separator)) {
23:             if (condition.get(content) == null) {
24:                 pair = new MatchPair();
25:                 condition.put(content, pair);
26:             } else {
27:                 pair = condition.get(content);
28:             }
29:         }
30:         // The Value in the KV part.
31:         else if ("=".equals(separator)) {
32:             if (pair == null) {
33:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
34:             }
35:             values = pair.matches;
36:             values.add(content);
37:         }
38:         // The Value in the KV part.
39:         else if ("!=".equals(separator)) {
40:             if (pair == null) {
41:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
42:             }
43:             values = pair.mismatches;
44:             values.add(content);
45:         }
46:         // The Value in the KV part, if Value have more than one items.
47:         else if (",".equals(separator)) { // Should be seperateed by ','
48:             if (values == null || values.isEmpty()) {
49:                 throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
50:             }
51:             values.add(content);
52:         } else {
53:             throw new ParseException("Illegal route rule \"" + rule + "\", The error char '" + separator + "' at index " + matcher.start() + " before \"" + content + "\".", matcher.start());
54:         }
55:     }
56:     return condition;
57: }
```

- ç¬¬ 11 è‡³ 14 è¡Œï¼šé€šè¿‡ `ROUTE_PATTERN` æ­£åˆ™åŒ¹é… `rule` ï¼Œ**å¾ªç¯**å¤šæ¬¡ï¼Œç›´åˆ°ç»“æŸã€‚å¦‚ä¸‹æ˜¯ä¸¤ä¸ªä¾‹å­ï¼š

  ```
  rule: host = 192.168.3.17 & method = say01
  	host
  =	192.168.3.17
  &	method
  =	say01
  
  ---------- åˆ†å‰²çº¿ ---------- 
  
  rule: host = 192.168.3.17
  	host
  =	192.168.3.17
  ```

- ç¬¬ 16 è‡³ 29 è¡Œï¼šå¤„ç†æ¡ä»¶**å±æ€§**çš„æƒ…å†µï¼Œä¾‹å¦‚ï¼š`host` å’Œ `& method` ç­‰ç­‰ï¼Œæ­¤æ—¶ä¼šè·å¾—å¯¹åº”çš„ MatchPair å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º MatchPair å¯¹è±¡ã€‚

- ç¬¬ 30 è‡³ 45 è¡Œï¼šå¤„ç†æ¡ä»¶

  æ¡ä»¶å€¼

  çš„æƒ…å†µï¼Œä¾‹å¦‚ï¼š

  ```
  = 192.168.3.17
  ```

   

  å’Œ

   

  ```
  != say01
  ```

   

  ç­‰ç­‰ï¼Œæ­¤æ—¶ä¼šæ·»åŠ åˆ° MatchPair çš„

   

  ```
  matches
  ```

   

  æˆ–

   

  ```
  mismatches
  ```

   

  ä¸­ã€‚

  - ç¬¬ 46 è‡³ 51 è¡Œï¼šå¤„ç†æ¡ä»¶**æ¡ä»¶å€¼**ä»¥é€—å·( `,` )åˆ†éš”å¤šä¸ªå€¼çš„æƒ…å†µï¼Œæ­¤æ—¶**ä¹Ÿä¼š**æ·»åŠ åˆ° MatchPair çš„ `matches` æˆ– `mismatches` ä¸­ã€‚

- ç¬¬ 52 è‡³ 54 è¡Œï¼šéæ³•ï¼ŒæŠ›å‡º ParseException å¼‚å¸¸ã€‚

###### 3.1.4 route

```
 1: @Override
 2: public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
 3:     // ä¸ºç©ºï¼Œç›´æ¥è¿”å›ç©º Invoker é›†åˆ
 4:     if (invokers == null || invokers.isEmpty()) {
 5:         return invokers;
 6:     }
 7:     try {
 8:         // ä¸åŒ¹é… `whenCondition` ï¼Œç›´æ¥è¿”å› `invokers` é›†åˆï¼Œå› ä¸ºä¸éœ€è¦èµ° `whenThen` çš„åŒ¹é…
 9:         if (!matchWhen(url, invocation)) {
10:             return invokers;
11:         }
12:         List<Invoker<T>> result = new ArrayList<Invoker<T>>();
13:         // `whenThen` ä¸ºç©ºï¼Œåˆ™è¿”å›ç©º Invoker é›†åˆ
14:         if (thenCondition == null) {
15:             logger.warn("The current consumer in the service blacklist. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey());
16:             return result;
17:         }
18:         // ä½¿ç”¨ `whenThen` ï¼ŒåŒ¹é… `invokers` é›†åˆã€‚è‹¥ç¬¦åˆï¼Œæ·»åŠ åˆ° `result` ä¸­
19:         for (Invoker<T> invoker : invokers) {
20:             if (matchThen(invoker.getUrl(), url)) {
21:                 result.add(invoker);
22:             }
23:         }
24:         // è‹¥ `result` éç©ºï¼Œè¿”å›å®ƒ
25:         if (!result.isEmpty()) {
26:             return result;
27:         // å¦‚æœ `force=true` ï¼Œä»£è¡¨å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›ç©º Invoker é›†åˆ
28:         } else if (force) {
29:             logger.warn("The route result is empty and force execute. consumer: " + NetUtils.getLocalHost() + ", service: " + url.getServiceKey() + ", router: " + url.getParameterAndDecoded(Constants.RULE_KEY));
30:             return result;
31:         }
32:     } catch (Throwable t) {
33:         logger.error("Failed to execute condition router rule: " + getUrl() + ", invokers: " + invokers + ", cause: " + t.getMessage(), t);
34:     }
35:     // å¦‚æœ `force=false` ï¼Œä»£è¡¨ä¸å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å› `invokers` é›†åˆï¼Œå³å¿½ç•¥è·¯ç”±è§„åˆ™
36:     return invokers;
37: }
```

- ç¬¬ 3 è‡³ 6 è¡Œï¼šè‹¥ `invokers` ä¸ºç©ºï¼Œç›´æ¥è¿”å›**ç©º** Invoker é›†åˆã€‚

- ç¬¬ 8 è‡³ 11 è¡Œï¼šè°ƒç”¨ `#matchWhen(url, invocation)` æ–¹æ³•ï¼Œä½¿ç”¨æœåŠ¡**æ¶ˆè´¹è€…** `url` åŒ¹é… `whenCondition` ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  boolean matchWhen(URL url, Invocation invocation) {
      return whenCondition == null || whenCondition.isEmpty() || matchCondition(whenCondition, url, null, invocation);
  }
  ```

  - å¦‚æœåŒ¹é…æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤ºå¯¹æ‰€æœ‰æ¶ˆè´¹æ–¹åº”ç”¨ï¼Œå¦‚ï¼š`=> host != 10.20.153.11` ã€‚
  - è‹¥**ä¸åŒ¹é…**ï¼Œåˆ™ç›´æ¥è¿”å›**å…¨** `invokers` é›†åˆï¼Œå› ä¸ºä¸éœ€è¦èµ° `whenThen` çš„åŒ¹é…ã€‚
  - `#matchCondition(...)` æ–¹æ³•çš„è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.1.5 matchConditionã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) ã€‚

- ç¬¬ 13 è‡³ 17 è¡Œï¼šè‹¥ `whenThen` ä¸ºç©ºï¼Œåˆ™è¿”å›**ç©º** Invoker é›†åˆã€‚

- ç¬¬ 18 è‡³ 23 è¡Œï¼š**å¾ªç¯**è°ƒç”¨ `#matchThen(url, invocation)` æ–¹æ³•ï¼Œä½¿ç”¨æœåŠ¡**æä¾›è€…è€…** `invokers` çš„ URL ï¼ŒåŒ¹é… `whenThen` é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private boolean matchThen(URL url, URL param) {
      return !(thenCondition == null || thenCondition.isEmpty()) && matchCondition(thenCondition, url, param, null);
  }
  ```

  - å¦‚æœè¿‡æ»¤æ¡ä»¶ä¸ºç©ºï¼Œè¡¨ç¤ºç¦æ­¢è®¿é—®ï¼Œå¦‚ï¼š`host = 10.20.153.10 =>` ã€‚
  - è‹¥**åŒ¹é…**ï¼Œæ·»åŠ åˆ° `result` ä¸­ã€‚

- ========== å¤„ç† `result` + `force` çš„**ä¸‰ç§**æƒ…å†µ ==========

- ç¬¬ 24 è‡³ 26 è¡Œï¼šè‹¥ `result` **éç©º**ï¼Œè¿”å›**å®ƒ**ã€‚

- ç¬¬ 27 è‡³ 31 è¡Œï¼šè‹¥ `result` **ä¸ºç©º**ï¼Œå¦‚æœ `force=true` ï¼Œä»£è¡¨å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›**ç©º** Invoker é›†åˆã€‚

- ç¬¬ 36 è¡Œï¼šè‹¥ `result` **ä¸ºç©º**ï¼Œå¦‚æœ `force=false` ï¼Œä»£è¡¨**ä¸**å¼ºåˆ¶æ‰§è¡Œï¼Œè¿”å›**å…¨** `invokers` é›†åˆï¼Œå³**å¿½ç•¥**è·¯ç”±è§„åˆ™ã€‚

ğŸ˜ˆ æƒ…å†µæ¯”è¾ƒå¤šï¼Œèƒ–å‹å¯ä»¥å›è¿‡å¤´åœ¨ç†ä¸€ç†ã€‚

####### 3.1.5 matchCondition

```
private boolean matchCondition(Map<String, MatchPair> condition, URL url, URL param, Invocation invocation) {
    Map<String, String> sample = url.toMap();
    boolean result = false; // æ˜¯å¦åŒ¹é…
    for (Map.Entry<String, MatchPair> matchPair : condition.entrySet()) {
        // è·å¾—æ¡ä»¶å±æ€§
        String key = matchPair.getKey();
        String sampleValue;
        // get real invoked method name from invocation
        if (invocation != null && (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) {
            sampleValue = invocation.getMethodName();
        } else {
            sampleValue = sample.get(key);
            if (sampleValue == null) {
                sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);
            }
        }
        // åŒ¹é…æ¡ä»¶å€¼
        if (sampleValue != null) {
            if (!matchPair.getValue().isMatch(sampleValue, param)) { // è¿”å›ä¸åŒ¹é…
                return false;
            } else {
                result = true;
            }
        } else {
            // not pass the condition
            if (!matchPair.getValue().matches.isEmpty()) { // æ— æ¡ä»¶å€¼ï¼Œä½†æ˜¯æœ‰åŒ¹é…æ¡ä»¶ `matches` ï¼Œåˆ™è¿”å›ä¸åŒ¹é…ã€‚
                return false;
            } else {
                result = true;
            }
        }
    }
    return result;
}
```

###### 3.1.5 compareTo

```
@Override
public int compareTo(Router o) {
    if (o == null || o.getClass() != ConditionRouter.class) {
        return 1;
    }
    ConditionRouter c = (ConditionRouter) o;
    return this.priority == c.priority ? url.toFullString().compareTo(c.url.toFullString()) : (this.priority > c.priority ? 1 : -1);
}
```

- ä¼˜å…ˆï¼ŒæŒ‰ç…§ `"priority"` **é™åº**ã€‚
- å…¶æ¬¡ï¼ŒæŒ‰ç…§ `"url"` **å‡åº**ã€‚

#### 3.2 ScriptRouter

`com.alibaba.dubbo.rpc.cluster.router.script.ScriptRouter` ï¼Œå®ç° Router æ¥å£ï¼ŒåŸºäº**è„šæœ¬**çš„ Router å®ç°ç±»ã€‚

> è„šæœ¬è·¯ç”±è§„åˆ™ [4](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html#fn_4) æ”¯æŒ JDK è„šæœ¬å¼•æ“çš„æ‰€æœ‰è„šæœ¬ï¼Œæ¯”å¦‚ï¼šjavascript, jruby, groovy ç­‰ï¼Œé€šè¿‡ `type=javascript` å‚æ•°è®¾ç½®è„šæœ¬ç±»å‹ï¼Œç¼ºçœä¸º javascriptã€‚

> ```
> > "script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("function route(invokers) { ... } (invokers)")
> >
> ```

> åŸºäºè„šæœ¬å¼•æ“çš„è·¯ç”±è§„åˆ™ï¼Œå¦‚ï¼š
>
> ```
> > function route(invokers) {
> >     var result = new java.util.ArrayList(invokers.size());
> >     for (i = 0; i < invokers.size(); i ++) {
> >         if ("10.20.153.10".equals(invokers.get(i).getUrl().getHost())) {
> >             result.add(invokers.get(i));
> >         }
> >     }
> >     return result;
> > } (invokers); // è¡¨ç¤ºç«‹å³æ‰§è¡Œæ–¹æ³•
> >
> ```

###### 3.2.1 æ„é€ æ–¹æ³•

```
/**
 * è„šæœ¬ç±»å‹ ä¸ ScriptEngine çš„æ˜ å°„ç¼“å­˜
 */
private static final Map<String, ScriptEngine> engines = new ConcurrentHashMap<String, ScriptEngine>();

/**
 * è·¯ç”±è§„åˆ™ URL
 */
private final ScriptEngine engine;
/**
 * è·¯ç”±è§„åˆ™çš„ä¼˜å…ˆçº§ï¼Œç”¨äºæ’åºï¼Œä¼˜å…ˆçº§è¶Šå¤§è¶Šé å‰æ‰§è¡Œï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º 0 ã€‚
 */
private final int priority;
/**
 * è·¯ç”±è§„åˆ™å†…å®¹
 */
private final String rule;
/**
 * è·¯ç”±è§„åˆ™ URL
 */
private final URL url;

public ScriptRouter(URL url) {
    this.url = url;
    String type = url.getParameter(Constants.TYPE_KEY);
    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
    String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
    // åˆå§‹åŒ– `engine`
    if (type == null || type.length() == 0) {
        type = Constants.DEFAULT_SCRIPT_TYPE_KEY;
    }
    if (rule == null || rule.length() == 0) {
        throw new IllegalStateException(new IllegalStateException("route rule can not be empty. rule:" + rule));
    }
    ScriptEngine engine = engines.get(type);
    if (engine == null) { // åœ¨ç¼“å­˜ä¸­ä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º ScriptEngine å¯¹è±¡
        engine = new ScriptEngineManager().getEngineByName(type);
        if (engine == null) {
            throw new IllegalStateException(new IllegalStateException("Unsupported route rule type: " + type + ", rule: " + rule));
        }
        engines.put(type, engine);
    }
    this.engine = engine;
    this.rule = rule;
}
```

###### 3.2.2 route

```
@Override
public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException {
    try {
        // æ‰§è¡Œè„šæœ¬
        List<Invoker<T>> invokersCopy = new ArrayList<Invoker<T>>(invokers);
        Compilable compilable = (Compilable) engine;
        Bindings bindings = engine.createBindings();
        bindings.put("invokers", invokersCopy);
        bindings.put("invocation", invocation);
        bindings.put("context", RpcContext.getContext());
        CompiledScript function = compilable.compile(rule); // ç¼–è¯‘
        Object obj = function.eval(bindings); // æ‰§è¡Œ
        // æ ¹æ®ç»“æœç±»å‹ï¼Œè½¬æ¢æˆ (List<Invoker<T>> ç±»å‹è¿”å›
        if (obj instanceof Invoker[]) {
            invokersCopy = Arrays.asList((Invoker<T>[]) obj);
        } else if (obj instanceof Object[]) {
            invokersCopy = new ArrayList<Invoker<T>>();
            for (Object inv : (Object[]) obj) {
                invokersCopy.add((Invoker<T>) inv);
            }
        } else {
            invokersCopy = (List<Invoker<T>>) obj;
        }
        return invokersCopy;
    } catch (ScriptException e) {
        // å‘ç”Ÿå¼‚å¸¸ï¼Œå¿½ç•¥è·¯ç”±è§„åˆ™ï¼Œè¿”å›å…¨ `invokers` é›†åˆ
        logger.error("route error , rule has been ignored. rule: " + rule + ", method:" + invocation.getMethodName() + ", url: " + RpcContext.getContext().getUrl(), e);
        return invokers;
    }
}
```

- ğŸ™‚ æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹è‡ªå·±çœ‹ä»£ç æ³¨é‡Šã€‚

###### 3.2.3 compareTo

```
@Override
public int compareTo(Router o) {
    if (o == null || o.getClass() != ScriptRouter.class) {
        return 1;
    }
    ScriptRouter c = (ScriptRouter) o;
    return this.priority == c.priority ? rule.compareTo(c.rule) : (this.priority > c.priority ? 1 : -1);
}
```

- ä¼˜å…ˆï¼ŒæŒ‰ç…§ `"priority"` **é™åº**ã€‚
- å…¶æ¬¡ï¼ŒæŒ‰ç…§ `"rule"` **å‡åº**ã€‚

#### 3.3 MockInvokersSelector

è¯¦ç»†è§£æï¼Œè§ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆå…«ï¼‰ä¹‹ Mock å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/?self) ã€‚

## 4. é›†æˆ Router æ¨¡å—

å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ‰**äºŒä¸ªç±»**ï¼Œè°ƒç”¨ `Router#route(List<Invoker<T>>, URL, Invocation)` æ–¹æ³•ï¼Œé›†æˆ Router æ¨¡å—ã€‚

[![é›†æˆ](http://static.iocoder.cn/images/Dubbo/2019_04_30/01.png)](http://static.iocoder.cn/images/Dubbo/2019_04_30/01.png)é›†æˆ

#### 4.1 AbstractDirectory

###### 4.1.1 setRouters

`#setRouters(List<Router> routers)` æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™ä»¬ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: protected void setRouters(List<Router> routers) {
 2:     // copy list // å¤åˆ¶ routers ï¼Œå› ä¸ºä¸‹é¢è¦ä¿®æ”¹
 3:     routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);
 4:     // append url router
 5:     // æ‹¼æ¥ `url` ä¸­ï¼Œé…ç½®çš„è·¯ç”±è§„åˆ™
 6:     String routerkey = url.getParameter(Constants.ROUTER_KEY);
 7:     if (routerkey != null && routerkey.length() > 0) {
 8:         RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerkey);
 9:         routers.add(routerFactory.getRouter(url));
10:     }
11:     // append mock invoker selector
12:     routers.add(new MockInvokersSelector());
13:     // æ’åº
14:     Collections.sort(routers);
15:     // èµ‹å€¼ç»™å±æ€§
16:     this.routers = routers;
17: }
```

- ç¬¬ 3 è¡Œï¼šå¤åˆ¶é‡æ–°åˆ›å»º `routers` æ•°ç»„ï¼Œå› ä¸ºä¸‹é¢ä¼šè¿›è¡Œä¿®æ”¹ã€‚

- ç¬¬ 5 è‡³ 10 è¡Œï¼šæ·»åŠ `url` ä¸­**é…ç½®çš„è·¯ç”±è§„åˆ™**åˆ° `routers` ä¸­ã€‚ä¾‹å¦‚ï¼š

  ```
  <dubbo:registry id="zk01" address="zookeeper://127.0.0.1:2181">
      <dubbo:parameter key="router" value="file" />
      <dubbo:parameter key="rule" value="/Users/yunai/xxx.js" />
  </dubbo:registry>
  ```

  - å—é™äº XML å¯¹å­—ç¬¦çš„é™åˆ¶ï¼Œ`"condition"` æˆ– `"script"` ç±»å‹çš„è·¯ç”±é…ç½®ä¼šæ¯”è¾ƒéš¾è®¾ç½®ã€‚æ‰€ä»¥ç¬”è€…è®¤ä¸ºï¼Œå¦‚æœæ˜¯ä½¿ç”¨ XML é…ç½®è·¯ç”±è§„åˆ™ï¼Œ`"file"` ç±»å‹æ˜¯æ¯”è¾ƒåˆé€‚çš„æ–¹å¼ã€‚å½“ç„¶ï¼Œå¦‚æœä½¿ç”¨ Java API åˆæˆ–è€…æ³¨è§£çš„æ–¹å¼ï¼Œåº”è¯¥ä¸å­˜åœ¨è¿™æ ·çš„é—®é¢˜ã€‚

- ç¬¬ 12 è¡Œï¼šæ·»åŠ  **MockInvokersSelector** åˆ° `routers` ä¸­ã€‚

- ç¬¬ 14 è¡Œï¼šæ’åº `routers` ã€‚

- ç¬¬ 16 è¡Œï¼š**èµ‹å€¼å±æ€§**ç»™ AbstractDirectory ã€‚

###### 4.1.2 list

```
 1: @Override
 2: public List<Invoker<T>> list(Invocation invocation) throws RpcException {
 3:     if (destroyed) {
 4:         throw new RpcException("Directory already destroyed .url: " + getUrl());
 5:     }
 6:     // è·å¾—æ‰€æœ‰ Invoker é›†åˆ
 7:     List<Invoker<T>> invokers = doList(invocation);
 8:     // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
 9:     List<Router> localRouters = this.routers; // local reference æœ¬åœ°å¼•ç”¨ï¼Œé¿å…å¹¶å‘é—®é¢˜
10:     if (localRouters != null && !localRouters.isEmpty()) {
11:         for (Router router : localRouters) {
12:             try {
13:                 if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {
14:                     invokers = router.route(invokers, getConsumerUrl(), invocation);
15:                 }
16:             } catch (Throwable t) {
17:                 logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
18:             }
19:         }
20:     }
21:     return invokers;
22: }
```

- ç¬¬ 8 è‡³ 20 è¡Œï¼š

  å¾ªç¯

  ï¼Œè°ƒç”¨

   

  ```
  Router#route(invokers, url, invocation)
  ```

   

  æ–¹æ³•ï¼Œä¸æ–­è·¯ç”±ï¼Œç­›é€‰

  åŒ¹é…çš„

   

  Invoker é›†åˆã€‚

  - ç¬¬ 13 è¡Œï¼šåˆ¤æ–­ `"runtime"` ä¸º **true** æ‰æ‰§è¡Œï¼šæ˜¯å¦åœ¨æ¯æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œè·¯ç”±è§„åˆ™ï¼Œ**å¦åˆ™åªåœ¨æä¾›è€…åœ°å€åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœ**ï¼Œè°ƒç”¨æ—¶ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è·¯ç”±ç»“æœã€‚å¦‚æœç”¨äº†å‚æ•°è·¯ç”±ï¼Œå¿…é¡»è®¾ä¸º `true`ï¼Œéœ€è¦æ³¨æ„è®¾ç½®ä¼šå½±å“è°ƒç”¨çš„æ€§èƒ½ï¼Œå¯ä¸å¡«ï¼Œç¼ºçœä¸º `flase`ã€‚

#### 4.2 RegistryDirectory

###### 4.2.1 notify

```
 1: @Override
 2: public synchronized void notify(List<URL> urls) {
 3:     // ã€çœç•¥æ— å…³ä»£ç ã€‘æ ¹æ® URL çš„åˆ†ç±»æˆ–åè®®ï¼Œåˆ†ç»„æˆä¸‰ä¸ªé›†åˆ ã€‚
 4:     List<URL> invokerUrls = new ArrayList<URL>(); // æœåŠ¡æä¾›è€… URL é›†åˆ
 5:     List<URL> routerUrls = new ArrayList<URL>();
 6:     List<URL> configuratorUrls = new ArrayList<URL>();
 7:     
 8:     //  ã€çœç•¥æ— å…³ä»£ç ã€‘å¤„ç†é…ç½®è§„åˆ™ URL é›†åˆ
 9:     // configurators
10: 
11:     // å¤„ç†è·¯ç”±è§„åˆ™ URL é›†åˆ
12:     if (!routerUrls.isEmpty()) {
13:         List<Router> routers = toRouters(routerUrls);
14:         if (routers != null) { // null - do nothing
15:             setRouters(routers);
16:         }
17:     }
18:     
19:     //  ã€çœç•¥æ— å…³ä»£ç ã€‘åˆå¹¶é…ç½®è§„åˆ™ï¼Œåˆ° `directoryUrl` ä¸­ï¼Œå½¢æˆ `overrideDirectoryUrl` å˜é‡ã€‚
20:     //  ã€çœç•¥æ— å…³ä»£ç ã€‘å¤„ç†æœåŠ¡æä¾›è€… URL é›†åˆ
21: }
```

- ç¬¬ 12 è¡Œï¼šè‹¥æ³¨å†Œä¸­å¿ƒé€šçŸ¥çš„ `routerUrls` éç©ºï¼Œè¿›è¡Œå¤„ç† `routerUrls` é›†åˆã€‚

- ç¬¬ 13 è¡Œï¼šè°ƒç”¨ `#toRouters(routerUrls)` æ–¹æ³•ï¼Œå°†è·¯ç”±è§„åˆ™ URL é›†åˆï¼Œ**è½¬æ¢**æˆå¯¹åº”çš„ Router é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private List<Router> toRouters(List<URL> urls) {
      List<Router> routers = new ArrayList<Router>();
      if (urls == null || urls.isEmpty()) {
          return routers;
      }
      for (URL url : urls) {
          // å¿½ç•¥ï¼Œè‹¥æ˜¯ "empty://" ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæ‰€æœ‰è·¯ç”±è§„åˆ™è¢«åˆ é™¤æ—¶ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€æ¡åè®®ä¸º "empty://" çš„è·¯ç”±è§„åˆ™ URL
          if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {
              continue;
          }
          // è·å¾— "router"
          String routerType = url.getParameter(Constants.ROUTER_KEY);
          if (routerType != null && routerType.length() > 0) {
              url = url.setProtocol(routerType);
          }
          try {
              // åˆ›å»º Router å¯¹è±¡
              Router router = routerFactory.getRouter(url);
              // æ·»åŠ åˆ°è¿”å›ç»“æœ
              if (!routers.contains(router)) {
                  routers.add(router);
              }
          } catch (Throwable t) {
              logger.error("convert router url to router error, url: " + url, t);
          }
      }
      return routers;
  }
  ```

  - ä»£ç æ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä¸‹æ³¨é‡Šç†è§£ã€‚

- ç¬¬ 14 è‡³ 16 è¡Œï¼š`routers` é›†åˆé **null**( å…è®¸é›†åˆå¤§å°ä¸º **0** )ï¼Œè°ƒç”¨ `#setRouters(routers)` æ–¹æ³•ï¼Œè®¾ç½®è·¯ç”±è§„åˆ™é›†åˆï¼Œå³ [ã€Œ4.1.1 setRoutersã€](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/#) ã€‚

###### 4.2.2 toMethodInvokers

```
 1: private Map<String, List<Invoker<T>>> toMethodInvokers(Map<String, Invoker<T>> invokersMap) {
 2:     // åˆ›å»ºæ–°çš„ `methodInvokerMap`
 3:     Map<String, List<Invoker<T>>> newMethodInvokerMap = new HashMap<String, List<Invoker<T>>>();
 4:     // åˆ›å»º Invoker é›†åˆ
 5:     List<Invoker<T>> invokersList = new ArrayList<Invoker<T>>();
 6:     //  ã€çœç•¥æ— å…³ä»£ç ã€‘æŒ‰æœåŠ¡æä¾›è€… URL æ‰€å£°æ˜çš„ methods åˆ†ç±»ï¼Œå…¼å®¹æ³¨å†Œä¸­å¿ƒæ‰§è¡Œè·¯ç”±è¿‡æ»¤æ‰çš„ methods
 7:     // è·¯ç”±å…¨ `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
 8:     List<Invoker<T>> newInvokersList = route(invokersList, null);
 9:     // æ·»åŠ  `newInvokersList` åˆ° `newMethodInvokerMap` ä¸­ï¼Œè¡¨ç¤ºè¯¥æœåŠ¡æä¾›è€…çš„å…¨é‡ Invoker é›†åˆ
10:     newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);
11:     // å¾ªç¯ï¼ŒåŸºäºæ¯ä¸ªæ–¹æ³•è·¯ç”±ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ
12:     if (serviceMethods != null && serviceMethods.length > 0) {
13:         for (String method : serviceMethods) {
14:             List<Invoker<T>> methodInvokers = newMethodInvokerMap.get(method);
15:             if (methodInvokers == null || methodInvokers.isEmpty()) {
16:                 methodInvokers = newInvokersList;
17:             }
18:             newMethodInvokerMap.put(method, route(methodInvokers, method));
19:         }
20:     }
21:     // ã€çœç•¥æ— å…³ä»£ç ã€‘å¾ªç¯æ’åºæ¯ä¸ªæ–¹æ³•çš„ Invoker é›†åˆï¼Œå¹¶è®¾ç½®ä¸ºä¸å¯å˜
22: }
```

- ç¬¬ 8 è¡Œï¼šè°ƒç”¨ `#route(invokers, method)` æ–¹æ³•ï¼Œè·¯ç”±**å…¨** `invokersList` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ**è¿›è¡Œç¼“å­˜**ï¼Œè¿™å°±æ˜¯ä¸Šæ–‡æåˆ°çš„â€œ*åªåœ¨æä¾›è€…åœ°å€åˆ—è¡¨å˜æ›´æ—¶é¢„å…ˆæ‰§è¡Œå¹¶ç¼“å­˜ç»“æœ*â€ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private List<Invoker<T>> route(List<Invoker<T>> invokers, String method) {
      // åˆ›å»º Invocation å¯¹è±¡
      Invocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
      // è·å¾— Router æ•°ç»„
      List<Router> routers = getRouters();
      // æ ¹æ®è·¯ç”±è§„åˆ™ï¼Œç­›é€‰ Invoker é›†åˆ
      if (routers != null) {
          for (Router router : routers) {
              if (router.getUrl() != null) {
                  invokers = router.route(invokers, getConsumerUrl(), invocation);
              }
          }
      }
      return invokers;
  }
  ```

  - ä¸»è¦æ˜¯è°ƒç”¨ `Router#route(...)` æ–¹æ³•ï¼Œè·¯ç”±ã€‚

- ç¬¬ 11 è‡³ 20 è¡Œï¼š**å¾ªç¯**ï¼Œè°ƒç”¨ `#route(invokers, method)` æ–¹æ³•ï¼Œè·¯ç”±**æ¯ä¸ªæ–¹æ³•**çš„ `methodInvokers` ï¼ŒåŒ¹é…åˆé€‚çš„ Invoker é›†åˆ**è¿›è¡Œç¼“å­˜**ã€‚

# 8ã€Mock å®ç°

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” é›†ç¾¤å®¹é”™ï¼ˆä¸ƒï¼‰ä¹‹ Router å®ç°ã€‹](http://svip.iocoder.cn/Dubbo/cluster-7-impl-router/?self) ä¸€æ–‡ï¼Œåˆ†äº« `dubbo-cluster` æ¨¡å—ï¼Œ `mock` åŒ…ï¼Œå®ç° Dubbo å¦‚ä¸‹åŠŸèƒ½ï¼š

- **æœ¬åœ°ä¼ªè£…**ï¼šé€šå¸¸ç”¨äºæœåŠ¡é™çº§ï¼Œæ¯”å¦‚æŸéªŒæƒæœåŠ¡ï¼Œå½“æœåŠ¡æä¾›æ–¹å…¨éƒ¨æŒ‚æ‰åï¼Œå®¢æˆ·ç«¯ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯é€šè¿‡ Mock æ•°æ®è¿”å›æˆæƒå¤±è´¥ã€‚
- **æœåŠ¡é™çº§**ï¼šå¯ä»¥é€šè¿‡æœåŠ¡é™çº§åŠŸèƒ½ï¼Œä¸´æ—¶å±è”½æŸä¸ªå‡ºé”™çš„éå…³é”®æœåŠ¡ï¼Œå¹¶å®šä¹‰é™çº§åçš„è¿”å›ç­–ç•¥ã€‚

> è€è‰¿è‰¿ï¼šå¦‚æœä¸ç†Ÿæ‚‰çš„èƒ–å‹ï¼Œæ¨èç»“åˆç€ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœ¬åœ°ä¼ªè£…ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) å’Œ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœåŠ¡é™çº§ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html) ä¸€èµ·å­¦ä¹ ã€‚

- **æ³¨æ„**ï¼Œ[ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœ¬åœ°ä¼ªè£…ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html) çš„æ–‡æ¡£æœ‰ç‚¹é—®é¢˜ï¼šSpring XML æ˜¯é€šè¿‡ `<dubbo:reference />` é…ç½®ï¼Œè€Œä¸æ˜¯ `<dubbo:service />` ã€‚

æœ¬æ–‡æ¶‰åŠç±»å¦‚ä¸‹å›¾ï¼š

[![Mock ç›¸å…³ç±»](http://static.iocoder.cn/images/Dubbo/2019_05_05/01.png)](http://static.iocoder.cn/images/Dubbo/2019_05_05/01.png)Mock ç›¸å…³ç±»

- åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼š
  - MockClusterWrapper + MockClusterInvoker + MockClusterSelector
  - MockProtocol + MockInvoker

## 2. MockClusterWrapper

`com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper` ï¼Œå®ç° Cluster æ¥å£ï¼ŒMock Cluster **Wrapper** å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class MockClusterWrapper implements Cluster {

    /**
     * çœŸæ­£çš„ Cluster å¯¹è±¡
     */
    private Cluster cluster;

    public MockClusterWrapper(Cluster cluster) {
        this.cluster = cluster;
    }

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new MockClusterInvoker<T>(directory, // <2>
                this.cluster.join(directory)); // <1>
    }

}
```

- `cluster` å­—æ®µï¼Œ**çœŸæ­£**çš„ Cluster å¯¹è±¡ã€‚å› ä¸º MockClusterWrapper æ˜¯ Dubbo SPI Wrapper ç±»ï¼Œ**æ‰€ä»¥å¯¹åº”çš„ Cluster å¯¹è±¡ï¼Œéƒ½ä¼šè¢«å®ƒæ‰€åŒ…è£…**ã€‚ä¸ç†è§£çš„èƒ–å‹ï¼Œå¯ä»¥çœ‹ä¸‹ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æ‹“å±•æœºåˆ¶ SPIã€‹](http://svip.iocoder.cn/Dubbo/spi/?self) çš„ [ã€Œ4.4.2 createExtensionã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) çš„ã€ç¬¬ 24 è‡³ 30 è¡Œã€‘ã€‚
- `<1>` å¤„ï¼šè°ƒç”¨ `Cluster#join(directory)` æ–¹æ³•ï¼Œåˆ›å»º**çœŸæ­£**çš„ Cluster Invoker å¯¹è±¡ã€‚
- `<2>` å¤„ï¼šåˆ›å»º MockClusterInvoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ3. MockClusterInvokerã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

## 3. MockClusterInvoker

`com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker` ï¼Œå®ç° Invoker æ¥å£ï¼Œ**MockClusterWrapper** å¯¹åº”çš„ Invoker å®ç°ç±»ã€‚

#### 3.1 æ„é€ æ–¹æ³•

```
private final Directory<T> directory;
/**
 * çœŸæ­£çš„ Invoker å¯¹è±¡
 */
private final Invoker<T> invoker;

public MockClusterInvoker(Directory<T> directory, Invoker<T> invoker) {
    this.directory = directory;
    this.invoker = invoker;
}
```

#### 3.2 invoke

```
 1: @Override
 2: public Result invoke(Invocation invocation) throws RpcException {
 3:     Result result;
 4:     // è·å¾— "mock" é…ç½®é¡¹ï¼Œæœ‰å¤šç§é…ç½®æ–¹å¼
 5:     String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
 6:     //ã€ç¬¬ä¸€ç§ã€‘æ—  mock
 7:     if (value.length() == 0 || value.equalsIgnoreCase("false")) {
 8:         // no mock
 9:         // è°ƒç”¨åŸ Invoker ï¼Œå‘èµ· RPC è°ƒç”¨
10:         result = this.invoker.invoke(invocation);
11:     //ã€ç¬¬äºŒç§ã€‘å¼ºåˆ¶æœåŠ¡é™çº§ http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html
12:     } else if (value.startsWith("force")) {
13:         if (logger.isWarnEnabled()) {
14:             logger.info("force-mock: " + invocation.getMethodName() + " force-mock enabled , url : " + directory.getUrl());
15:         }
16:         // force:direct mock
17:         // ç›´æ¥è°ƒç”¨ Mock Invoker ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘
18:         result = doMockInvoke(invocation, null);
19:     // ã€ç¬¬ä¸‰ç§ã€‘å¤±è´¥æœåŠ¡é™çº§ http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html
20:     } else {
21:         // fail-mock
22:         try {
23:             // è°ƒç”¨åŸ Invoker ï¼Œå‘èµ· RPC è°ƒç”¨
24:             result = this.invoker.invoke(invocation);
25:         } catch (RpcException e) {
26:             // ä¸šåŠ¡æ€§å¼‚å¸¸ï¼Œç›´æ¥æŠ›å‡º
27:             if (e.isBiz()) {
28:                 throw e;
29:             } else {
30:                 if (logger.isWarnEnabled()) {
31:                     logger.info("fail-mock: " + invocation.getMethodName() + " fail-mock enabled , url : " + directory.getUrl(), e);
32:                 }
33:                 // å¤±è´¥åï¼Œè°ƒç”¨ Mock Invoker ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘
34:                 result = doMockInvoke(invocation, e);
35:             }
36:         }
37:     }
38:     return result;
39: }
```

- ç¬¬ 5 è¡Œï¼šè·å¾— `"mock"` é…ç½®é¡¹ã€‚æ ¹æ®ä¸åŒçš„é…ç½®ï¼Œåˆ†æˆ**ä¸‰ç§**æƒ…å†µã€‚

- ========== ç¬¬ä¸€ç§ï¼š**æ—  Mock** ==========

- ç¬¬ 10 è¡Œï¼šåªè°ƒç”¨**çœŸæ­£çš„** `invoker` çš„ `#invoke(invocation)` æ–¹æ³•ï¼Œå‘èµ· RPC è°ƒç”¨ï¼Œ**å³ä¸è¿›è¡Œ Mock é€»è¾‘**ã€‚

- ========== ç¬¬äºŒç§ï¼š**å¼ºåˆ¶æœåŠ¡é™çº§** ==========

- ç¬¬ 12 è¡Œï¼š`"mock"` é…ç½®é¡¹ä»¥ `"force"` **å¼€å¤´**ï¼Œ**å¼ºåˆ¶**æœåŠ¡é™çº§ï¼Œå³ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœåŠ¡é™çº§ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html) ã€‚

- ç¬¬ 18 è¡Œï¼š**ç›´æ¥**è°ƒç”¨ `#doMockInvoke(invocation, null)` æ–¹æ³•ï¼Œè°ƒç”¨ **Mock Invoker** ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.3 doMockInvokeã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

- ========== ç¬¬ä¸‰ç§ï¼š**å¤±è´¥æœåŠ¡é™çº§** ==========

- ç¬¬ 24 è¡Œï¼š**ä¼˜å…ˆ**ï¼Œè°ƒç”¨**çœŸæ­£çš„** `invoker` çš„ `#invoke(invocation)` æ–¹æ³•ï¼Œå‘èµ· RPC è°ƒç”¨ï¼Œ**å³ä¸è¿›è¡Œ Mock é€»è¾‘**ã€‚

- ç¬¬ 25 è‡³ 36 è¡Œï¼šå¤„ç† RpcException å¼‚å¸¸ã€‚

  ä¹Ÿä»…ä»…å¤„ç†è¿™ç§ç±»å‹çš„å¼‚å¸¸

  ã€‚

  - ç¬¬ 26 è‡³ 28 è¡Œï¼šè‹¥å‘ç”Ÿ**ä¸šåŠ¡æ€§**å¼‚å¸¸ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ã€‚
  - ç¬¬ 29 è‡³ 35 è¡Œï¼š**å¤±è´¥å**ï¼Œè°ƒç”¨ `#doMockInvoke(invocation, null)` æ–¹æ³•ï¼Œè°ƒç”¨ **Mock Invoker** ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.3 doMockInvokeã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

ğŸ˜ˆ æ€»çš„æ¥è¯´ï¼ŒMockClusterInvoker çš„ `#invoke(Invocation)` æ–¹æ³•çš„è¿‡ç¨‹ï¼Œæ ¹æ®ä¸åŒçš„ `"mock"` é…ç½®ï¼Œâ€œç»„åˆâ€è°ƒç”¨**çœŸæ­£çš„**å’Œ **Mock** çš„ Invoker ã€‚

#### 3.3 doMockInvoke

```
 1: private Result doMockInvoke(Invocation invocation, RpcException e) {
 2:     Result result;
 3:     // ç¬¬ä¸€æ­¥ï¼Œè·å¾— Mock Invoker å¯¹è±¡
 4:     Invoker<T> mInvoker;
 5:     // è·¯ç”±åŒ¹é… Mock Invoker é›†åˆ
 6:     List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
 7:     // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ›å»º MockInvoker å¯¹è±¡
 8:     if (mockInvokers == null || mockInvokers.isEmpty()) {
 9:         mInvoker = (Invoker<T>) new MockInvoker(directory.getUrl());
10:     // å¦‚æœå­˜åœ¨ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
11:     } else {
12:         mInvoker = mockInvokers.get(0);
13:     }
14:     // ç¬¬äºŒæ­¥ï¼Œè°ƒç”¨ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘
15:     try {
16:         result = mInvoker.invoke(invocation);
17:     } catch (RpcException me) {
18:         if (me.isBiz()) {
19:             result = new RpcResult(me.getCause());
20:         } else {
21:             throw new RpcException(me.getCode(), getMockExceptionMessage(e, me), me.getCause());
22:         }
23:     } catch (Throwable me) {
24:         throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
25:     }
26:     return result;
27: }
```

- ç¬¬ 3 è‡³ 13 è¡Œï¼š

  ç¬¬ä¸€æ­¥

  ï¼Œè·å¾—

   

  MockInvoker

   

  å¯¹è±¡ã€‚

  - ç¬¬ 6 è¡Œï¼šè°ƒç”¨ `#selectMockInvoker(invocation)` æ–¹æ³•ï¼Œ**è·¯ç”±åŒ¹é…** Mock Invoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.4 selectMockInvokerã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚
  - ç¬¬ 7 è‡³ 9 è¡Œï¼šè‹¥**ä¸**å­˜åœ¨ï¼Œ**åˆ›å»º** MockInvoker å¯¹è±¡ã€‚
  - ç¬¬ 10 è‡³ 13 è¡Œï¼šè‹¥**å·²**ä¸èƒ½å†ï¼Œ**é€‰æ‹©**ç¬¬ä¸€ä¸ª Mock Invoker å¯¹è±¡ã€‚

- ç¬¬ 14 è‡³ 16 è¡Œï¼šè°ƒç”¨ `MockInvoker#invoke(invocation)` æ–¹æ³•ï¼Œæ‰§è¡Œæœ¬åœ° Mock é€»è¾‘ã€‚

- ç¬¬ 17 è‡³ 25 è¡Œï¼šå¤„ç†**å¼‚å¸¸**ã€‚

#### 3.4 selectMockInvoker

```
 1: private List<Invoker<T>> selectMockInvoker(Invocation invocation) {
 2:     List<Invoker<T>> invokers = null;
 3:     if (invocation instanceof RpcInvocation) {
 4:         // å­˜åœ¨éšå«å¥‘çº¦(è™½ç„¶åœ¨æ¥å£å£°æ˜ä¸­å¢åŠ æè¿°ï¼Œä½†æ‰©å±•æ€§ä¼šå­˜åœ¨é—®é¢˜.åŒæ—¶æ”¾åœ¨ attachment ä¸­çš„åšæ³•éœ€è¦æ”¹è¿›
 5:         ((RpcInvocation) invocation).setAttachment(Constants.INVOCATION_NEED_MOCK, Boolean.TRUE.toString());
 6:         // directory æ ¹æ® invocation ä¸­ attachment æ˜¯å¦æœ‰ Constants.INVOCATION_NEED_MOCKï¼Œæ¥åˆ¤æ–­è·å–çš„æ˜¯ normal invokers or mock invokers
 7:         try {
 8:             invokers = directory.list(invocation);
 9:         } catch (RpcException e) {
10:             if (logger.isInfoEnabled()) {
11:                 logger.info("Exception when try to invoke mock. Get mock invokers error for service:" + directory.getUrl().getServiceInterface() + ", method:" + invocation.getMethodName() + ", will contruct a new mock with 'new MockInvoker()'.", e);
12:             }
13:         }
14:     }
15:     return invokers;
16: }
```

- ç¬¬ 5 è¡Œï¼šè®¾ç½® RpcInvocation çš„ `"invocation.need.mock"` ä¸º **true** ã€‚
- ç¬¬ 8 è¡Œï¼šè°ƒç”¨ `Directory#list(invocation)` æ–¹æ³•ï¼Œè·å¾—**æ‰€æœ‰** Invoker é›†åˆã€‚å› ä¸ºã€ç¬¬ 5 è¡Œã€‘è®¾ç½®äº† `"invocation.need.mock"` ä¸º **true** ï¼Œæ‰€ä»¥å®é™…è·å¾—çš„æ˜¯ MockInvoker é›†åˆã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ3.4.1 MockInvokersSelectorã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

###### 3.4.1 MockInvokersSelector

`com.alibaba.dubbo.rpc.cluster.router.MockInvokersSelector` ï¼Œå®ç° Router æ¥å£ï¼ŒMockInvoker è·¯ç”±**é€‰æ‹©å™¨**å®ç°ç±»ã€‚

å› ä¸º AbstractDirectory çš„ `#setRouters(List<Router> routers)` æ–¹æ³•ä¸­ï¼Œéƒ½ä¼šæ·»åŠ  **MockInvokersSelector** ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š[![setRouters](http://static.iocoder.cn/images/Dubbo/2019_05_05/02.png)](http://static.iocoder.cn/images/Dubbo/2019_05_05/02.png)setRouters

- æ‰€ä»¥ï¼Œæ¯æ¬¡ `Directory#list(invocation)` çš„è¿‡ç¨‹ä¸­ï¼Œéƒ½ä¼šæ‰§è¡Œ MockInvokersSelector çš„è·¯ç”±é€»è¾‘ã€‚

------

`#route(List<Invoker<T>> invokers, URL url, Invocation invocation)` æ–¹æ³•ï¼Œæ ¹æ® `"invocation.need.mock"` è·¯ç”±åŒ¹é…**å¯¹åº”ç±»å‹**çš„ Invoker é›†åˆï¼š

- 1ã€è‹¥ä¸º **true** ï¼Œ**Mock**Invoker é›†åˆã€‚
- 2ã€è‹¥ä¸º **false** ï¼Œ**æ™®é€š** Invoker é›†åˆã€‚

ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public <T> List<Invoker<T>> route(final List<Invoker<T>> invokers, URL url, final Invocation invocation) throws RpcException {
 3:     // è·å¾—æ™®é€š Invoker é›†åˆ
 4:     if (invocation.getAttachments() == null) {
 5:         return getNormalInvokers(invokers);
 6:     } else {
 7:         // è·å¾— "invocation.need.mock" é…ç½®é¡¹
 8:         String value = invocation.getAttachments().get(Constants.INVOCATION_NEED_MOCK);
 9:         // è·å¾—æ™®é€š Invoker é›†åˆ
10:         if (value == null) {
11:             return getNormalInvokers(invokers);
12:         // è·å¾— MockInvoker é›†åˆ
13:         } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {
14:             return getMockedInvokers(invokers);
15:         }
16:     }
17:     // å…¶å®ƒï¼Œä¸åŒ¹é…ï¼Œç›´æ¥è¿”å› `invokers` é›†åˆ
18:     return invokers;
19: }
```

- åˆ†æˆ**ä¸‰ç§**æƒ…å†µï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªæ¥çœ‹ã€‚åœ¨çœ‹å…·ä½“æƒ…å†µä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ `#hasMockProviders(invokers)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰ MockInvoker ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private <T> boolean hasMockProviders(final List<Invoker<T>> invokers) {
      boolean hasMockProvider = false;
      for (Invoker<T> invoker : invokers) {
          if (invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) { // åè®®ä¸º "mock"
              hasMockProvider = true;
              break;
          }
      }
      return hasMockProvider;
  }
  ```

  - é€šè¿‡ `protocol = "mock"` æ¥åˆ¤æ–­ï¼Œæ˜¯å¦ä¸º **Mock**Invoker ã€‚æ‰€ä»¥åªè¦**ä¸ä¸º** MockInvoker ï¼Œå°±æ˜¯**æ™®é€š** Invoker ã€‚å…³äº `"mock"` åè®®ï¼Œæˆ‘ä»¬ç¨ååœ¨ [ã€Œ4. MockProtocolã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ä¸­ï¼Œè¯¦ç»†è§£æã€‚

- ã€ç¬¬**ä¸€**ç§ã€‘ç¬¬ 3 è‡³ 5 è¡Œ || ç¬¬ 9 è‡³ 11 è¡Œï¼šè‹¥**æœªè®¾ç½®** `"invocation.need.mock"` é…ç½®é¡¹ï¼Œè°ƒç”¨ `#getNormalInvokers(invokers)` æ–¹æ³•ï¼Œè·å¾—**æ™®é€š** Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
   1: private <T> List<Invoker<T>> getNormalInvokers(final List<Invoker<T>> invokers) {
   2:     // ä¸åŒ…å« MockInvoker çš„æƒ…å†µä¸‹ï¼Œç›´æ¥è¿”å› `invokers` é›†åˆ
   3:     if (!hasMockProviders(invokers)) {
   4:         return invokers;
   5:     } else {
   6:         // è‹¥åŒ…å« MockInvoker çš„æƒ…å†µä¸‹ï¼Œè¿‡æ»¤æ‰ MockInvoker ï¼Œåˆ›å»ºæ™®é€š Invoker é›†åˆ
   7:         List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(invokers.size());
   8:         for (Invoker<T> invoker : invokers) {
   9:             if (!invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) {
  10:                 sInvokers.add(invoker);
  11:             }
  12:         }
  13:         return sInvokers;
  14:     }
  15: }
  ```

  - ç¬¬ 2 è‡³ 4 è¡Œï¼šè°ƒç”¨ `#hasMockProviders(invokers)` æ–¹æ³•ï¼Œåˆ¤æ–­**ä¸åŒ…å«** MockInvoker çš„æƒ…å†µï¼Œç›´æ¥è¿”å› `invokers` é›†åˆã€‚
  - ç¬¬ 6 è‡³ 13 è¡Œï¼šè‹¥**åŒ…å«** MockInvoker çš„æƒ…å†µï¼Œ**è¿‡æ»¤**æ‰ MockInvoker ï¼Œåˆ›å»º**æ™®é€š** Invoker é›†åˆã€‚

- ã€ç¬¬**äºŒ**ç§ã€‘ç¬¬ 12 è‡³ 15 è¡Œï¼šè‹¥è®¾ç½® `"invocation.need.mock"` é…ç½®é¡¹ä¸º **true** ï¼Œè°ƒç”¨ `#getMockedInvokers(invokers)` æ–¹æ³•ï¼Œè·å¾— **Mock**Invoker é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  private <T> List<Invoker<T>> getMockedInvokers(final List<Invoker<T>> invokers) {
      // ä¸åŒ…å« MockInvoker çš„æƒ…å†µä¸‹ï¼Œç›´æ¥è¿”å› null
      if (!hasMockProviders(invokers)) {
          return null;
      }
      // è¿‡æ»¤æ‰æ™®é€š kInvoker ï¼Œåˆ›å»º MockInvoker é›†åˆ
      List<Invoker<T>> sInvokers = new ArrayList<Invoker<T>>(1); // ä¸€èˆ¬æƒ…å†µå°±ä¸€ä¸ªï¼Œæ‰€ä»¥è®¾ç½®äº†é»˜è®¤æ•°ç»„å¤§å°ä¸º 1 ã€‚
      for (Invoker<T> invoker : invokers) {
          if (invoker.getUrl().getProtocol().equals(Constants.MOCK_PROTOCOL)) {
              sInvokers.add(invoker);
          }
      }
      return sInvokers;
  }
  ```

  - å’Œ `#getNormalInvokers(invokers)` æ–¹æ³•ï¼Œ**ç›¸å**ã€‚æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä»£ç æ³¨é‡Šã€‚

- ã€ç¬¬**ä¸‰**ç§ã€‘ç¬¬ 18 è¡Œï¼šå…¶å®ƒï¼Œ**ä¸åŒ¹é…**ï¼Œç›´æ¥è¿”å› `invokers` é›†åˆã€‚ç†è®ºä¸Šï¼Œåº”è¯¥è°ƒç”¨å’Œã€ç¬¬**ä¸€**ç§ã€‘ä¸€æ ·ï¼Œè°ƒç”¨ `#getNormalInvokers(invokers)` æ–¹æ³•ã€‚ä¸è¿‡æ²¡å…³ç³»ï¼ŒğŸ˜ˆ ä»ç›®å‰ä»£ç æ¥çœ‹ï¼Œè¿™å—æ˜¯èµ°ä¸åˆ°çš„ã€‚

## 4. MockProtocol

`com.alibaba.dubbo.rpc.support.MockProtocol` ï¼Œå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼Œç”¨äºåœ¨æœåŠ¡**æ¶ˆè´¹è€…**ï¼Œé€šè¿‡ç±»å‹ä¸º `"mock"` çš„ URL ï¼Œå¼•ç”¨åˆ›å»º MockInvoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public final class MockProtocol extends AbstractProtocol {

    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        throw new UnsupportedOperationException();
    }

    @Override
    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        return new MockInvoker<T>(url);
    }

    @Override
    public int getDefaultPort() {
        return 0;
    }

}
```

- `#export(Invoker)` **å®ç°**æ–¹æ³•ï¼Œä¸å…è®¸è°ƒç”¨ï¼Œç›´æ¥æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

- `#refer(Class<T> type, Url)` **å®ç°**æ–¹æ³•ï¼Œå¼•ç”¨åˆ›å»º **MockInvoker** å¯¹è±¡ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `dubbo-admin` **è¿ç»´å¹³å°**æˆ–è€…ç›´æ¥å‘ Zookeeper å†™å…¥**é™æ€** URL ï¼Œä¾‹å¦‚ï¼š

  ```
  // å®é™…å†™å…¥çš„ URL
  /dubbo/com.alibaba.dubbo.demo.DemoService/providers/mock%3A%2F%2F10.20.153.11%2Fcom.alibaba.dubbo.demo.DemoService%3Fdynamic%3Dtrue%26application%3Dfoo
  
  // decode URL
  /dubbo/com.alibaba.dubbo.demo.DemoService/providers/mock://10.20.153.11/com.alibaba.dubbo.demo.DemoService?dynamic=true&application=foo
  ```

  - ä¸ºä»€ä¹ˆè¦æ˜¯**é™æ€** URL å‘¢ï¼Ÿå› ä¸ºéé™æ€ URL ï¼Œå¯èƒ½è¢«æ³¨å†Œä¸­å¿ƒåˆ é™¤ã€‚

ğŸ˜ˆ å½“ç„¶ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ3.3 doMockInvokeã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ä¸­ä¹Ÿçœ‹åˆ°ï¼Œå³ä½¿ä¸**æ‰‹åŠ¨**æ·»åŠ  `"mock"` URL ï¼Œåœ¨ã€ç¬¬ 9 è¡Œã€‘ä»£ç ä¸­ä¹Ÿä¼š**è‡ªåŠ¨**åˆ›å»º MockInvoker å¯¹è±¡ã€‚

## 5. MockInvoker

`com.alibaba.dubbo.rpc.support.MockInvoker` ï¼Œå®ç° Invoker æ¥å£ï¼Œ**Mock** Invoker å®ç°ç±»ã€‚

#### 5.1 æ„é€ æ–¹æ³•

```
/**
 * ProxyFactory$Adaptive å¯¹è±¡
 */
private final static ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();

/**
 * mock ä¸ Invoker å¯¹è±¡çš„æ˜ å°„ç¼“å­˜
 *
 * @see #getInvoker(String)
 */
private final static Map<String, Invoker<?>> mocks = new ConcurrentHashMap<String, Invoker<?>>();
/**
 * mock ä¸ Throwable å¯¹è±¡çš„æ˜ å°„ç¼“å­˜
 *
 * @see #getThrowable(String)
 */
private final static Map<String, Throwable> throwables = new ConcurrentHashMap<String, Throwable>();

/**
 * URL å¯¹è±¡
 */
private final URL url;

public MockInvoker(URL url) {
    this.url = url;
}
```

#### 5.2 invoke

`#invoke(Invocation)` **å®ç°**æ–¹æ³•ï¼Œæ‰§è¡Œ Mock é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public Result invoke(Invocation invocation) throws RpcException {
 3:     if (invocation instanceof RpcInvocation) {
 4:         ((RpcInvocation) invocation).setInvoker(this);
 5:     }
 6:     // è·å¾— `"mock"` é…ç½®é¡¹ï¼Œæ–¹æ³•çº§ > ç±»çº§
 7:     String mock = getUrl().getParameter(invocation.getMethodName() + "." + Constants.MOCK_KEY);
 8:     if (StringUtils.isBlank(mock)) {
 9:         mock = getUrl().getParameter(Constants.MOCK_KEY);
10:     }
11:     if (StringUtils.isBlank(mock)) { // ä¸å…è®¸ä¸ºç©º
12:         throw new RpcException(new IllegalAccessException("mock can not be null. url :" + url));
13:     }
14:     // æ ‡å‡†åŒ– `"mock"` é…ç½®é¡¹
15:     mock = normalizedMock(URL.decode(mock));
16:     // ç­‰äº "return " ï¼Œè¿”å›å€¼ä¸ºç©ºçš„ RpcResult å¯¹è±¡
17:     if (Constants.RETURN_PREFIX.trim().equalsIgnoreCase(mock.trim())) {
18:         RpcResult result = new RpcResult();
19:         result.setValue(null);
20:         return result;
21:     // ä»¥ "return " å¼€å¤´ï¼Œè¿”å›å¯¹åº”å€¼çš„ RpcResult å¯¹è±¡
22:     } else if (mock.startsWith(Constants.RETURN_PREFIX)) {
23:         mock = mock.substring(Constants.RETURN_PREFIX.length()).trim();
24:         mock = mock.replace('`', '"');
25:         try {
26:             // è§£æè¿”å›ç±»å‹
27:             Type[] returnTypes = RpcUtils.getReturnTypes(invocation);
28:             // è§£æè¿”å›å€¼
29:             Object value = parseMockValue(mock, returnTypes);
30:             // åˆ›å»ºå¯¹åº”å€¼çš„ RpcResult å¯¹è±¡ï¼Œå¹¶è¿”å›
31:             return new RpcResult(value);
32:         } catch (Exception ew) {
33:             throw new RpcException("mock return invoke error. method :" + invocation.getMethodName() + ", mock:" + mock + ", url: " + url, ew);
34:         }
35:     // ä»¥ "throw" å¼€å¤´ï¼ŒæŠ›å‡º RpcException å¼‚å¸¸
36:     } else if (mock.startsWith(Constants.THROW_PREFIX)) {
37:         mock = mock.substring(Constants.THROW_PREFIX.length()).trim();
38:         mock = mock.replace('`', '"');
39:         if (StringUtils.isBlank(mock)) { // ç¦æ­¢ä¸ºç©º
40:             throw new RpcException(" mocked exception for Service degradation. ");
41:         } else { // user customized class
42:             // åˆ›å»ºè‡ªå®šä¹‰å¼‚å¸¸
43:             Throwable t = getThrowable(mock);
44:             // æŠ›å‡ºä¸šåŠ¡ç±»å‹çš„ RpcException å¼‚å¸¸
45:             throw new RpcException(RpcException.BIZ_EXCEPTION, t);
46:         }
47:     // è‡ªå®šä¹‰ Mock ç±»ï¼Œæ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘
48:     } else {
49:         try {
50:             // åˆ›å»º Invoker å¯¹è±¡
51:             Invoker<T> invoker = getInvoker(mock);
52:             // æ‰§è¡Œ Invoker å¯¹è±¡çš„è°ƒç”¨é€»è¾‘
53:             return invoker.invoke(invocation);
54:         } catch (Throwable t) {
55:             throw new RpcException("Failed to create mock implemention class " + mock, t);
56:         }
57:     }
58: }
```

- ç¬¬ 6 è‡³ 13 è¡Œï¼šè·å¾— `"mock"` é…ç½®é¡¹ï¼Œä¼˜å…ˆä»**æ–¹æ³•çº§**çš„å‚æ•°ï¼Œå†ä»**ç±»çº§**çš„å‚æ•°ã€‚

- ç¬¬ 15 è¡Œï¼šè°ƒç”¨ `#normalizedMock(mock)` æ–¹æ³•ï¼Œæ ‡å‡†åŒ– `"mock"` é…ç½®é¡¹ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.3 normalizedMockã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

- ä¸‹é¢æ ¹æ® `mock` ï¼Œåˆ†æˆ**ä¸‰ç§**æƒ…å†µã€‚

- ã€ç¬¬ **1.1** ç§ã€‘ç¬¬ 16 è‡³ 20 è¡Œï¼šç­‰äº `"return "` ï¼Œè¿”å›å€¼ä¸º**ç©º** çš„ RpcResult å¯¹è±¡ã€‚

- ã€ç¬¬

   

  1.2

   

  ç§ã€‘ç¬¬ 21 è‡³ 34 è¡Œï¼šä»¥

   

  ```
  "return"
  ```

   

  å¼€å¤´ï¼Œè¿”å›

  å¯¹åº”å€¼

   

  çš„ RpcResult å¯¹è±¡ã€‚

  - ç¬¬29 è¡Œï¼šè°ƒç”¨ `#parseMockValue(mock, returnTypes)` æ–¹æ³•ï¼Œè§£æ**è¿”å›å€¼**ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.4 parseMockValueã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

- ã€ç¬¬

   

  2

   

  ç§ã€‘ç¬¬ 35 è‡³ 46 è¡Œï¼šä»¥

   

  ```
  "throw"
  ```

   

  å¼€å¤´ï¼ŒæŠ›å‡º

  å¯¹åº”çš„

   

  RpcException å¼‚å¸¸ã€‚

  - ç¬¬ 43 è¡Œï¼šè°ƒç”¨ `#getThrowable(mock)` å¯¹è±¡ï¼Œåˆ›å»º**è‡ªå®šä¹‰**å¼‚å¸¸ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.5 getThrowableã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚

- ã€ç¬¬

   

  3

   

  ç§ã€‘ç¬¬ 47 è‡³ 57 è¡Œï¼š

  è‡ªå®šä¹‰

   

  Mock ç±»ï¼Œæ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘ã€‚

  - ç¬¬ 51 è¡Œï¼šè°ƒç”¨ `#getInvoker(mock)` æ–¹æ³•ï¼Œè·å¾— Invoker å¯¹è±¡ã€‚è¯¦ç»†è§£æï¼Œè§ [ã€Œ5.6 getInvokerã€](http://svip.iocoder.cn/Dubbo/cluster-8-impl-mock/#) ã€‚
  - ç¬¬ 53 è¡Œï¼šè°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼Œæ‰§è¡Œ**è‡ªå®šä¹‰** Mock é€»è¾‘ã€‚

#### 5.3 normalizedMock

```
 1: private String normalizedMock(String mock) {
 2:     // è‹¥ä¸ºç©ºï¼Œç›´æ¥è¿”å›
 3:     if (mock == null || mock.trim().length() == 0) {
 4:         return mock;
 5:     // è‹¥æœä¸º "true" "default" "fail" "force" å››ç§å­—ç¬¦ä¸²ï¼Œä¿®æ”¹ä¸ºå¯¹åº”æ¥å£ + "Mock" ç±»
 6:     } else if (ConfigUtils.isDefault(mock) || "fail".equalsIgnoreCase(mock.trim()) || "force".equalsIgnoreCase(mock.trim())) {
 7:         mock = url.getServiceInterface() + "Mock";
 8:     }
 9:     // è‹¥ä»¥ "fail:" å¼€å¤´ï¼Œå»æ‰è¯¥å¼€å¤´
10:     if (mock.startsWith(Constants.FAIL_PREFIX)) {
11:         mock = mock.substring(Constants.FAIL_PREFIX.length()).trim();
12:     // è‹¥ä»¥ "force:" å¼€å¤´ï¼Œå»æ‰è¯¥å¼€å¤´
13:     } else if (mock.startsWith(Constants.FORCE_PREFIX)) {
14:         mock = mock.substring(Constants.FORCE_PREFIX.length()).trim();
15:     }
16:     return mock;
17: }
```

- ã€ç¬¬**ä¸€**ç§ã€‘ç¬¬ 2 è‡³ 4 è¡Œï¼šè‹¥ä¸º**ç©º**ï¼Œç›´æ¥è¿”å›ã€‚
- ã€ç¬¬**äºŒ**ç§ã€‘ç¬¬ 5 è‡³ 8 è¡Œï¼šè‹¥ä¸º **`true` `default` `fail` `force`** ï¼Œä¿®æ”¹ä¸ºå¯¹åº”æ¥å£ + `"Mock"` ã€‚
- ã€ç¬¬**ä¸‰**ç§ã€‘ç¬¬ 9 è‡³ 15 è¡Œï¼šè‹¥ä»¥ `"fail:"` æˆ– `"force:"` **å¼€å¤´** ï¼Œå»æ‰**å¼€å¤´**ã€‚è¯¥å¼€å¤´ï¼Œä»…ç”¨äº MockClusterInvoker è¡¨ç¤º**å¼ºåˆ¶** Mock è¿˜æ˜¯**å¤±è´¥** Mock ã€‚

#### 5.4 parseMockValue

```
public static Object parseMockValue(String mock) {
    return parseMockValue(mock, null);
}

public static Object parseMockValue(String mock, Type[] returnTypes) {
    // è§£æå€¼ï¼ˆä¸è€ƒè™‘è¿”å›ç±»å‹ï¼‰
    Object value;
    if ("empty".equals(mock)) { // æœªèµ‹å€¼çš„å¯¹è±¡ï¼Œå³ new XXX() å¯¹è±¡
        value = ReflectUtils.getEmptyObject(returnTypes != null && returnTypes.length > 0 ? (Class<?>) returnTypes[0] : null);
    } else if ("null".equals(mock)) { // null
        value = null;
    } else if ("true".equals(mock)) { // true
        value = true;
    } else if ("false".equals(mock)) { // false
        value = false;
    } else if (mock.length() >= 2 && (mock.startsWith("\"") && mock.endsWith("\"")
            || mock.startsWith("\'") && mock.endsWith("\'"))) { // ä½¿ç”¨ '' æˆ– "" çš„å­—ç¬¦ä¸²ï¼Œæˆªå–æ‰å¤´å°¾
        value = mock.subSequence(1, mock.length() - 1);
    } else if (returnTypes != null && returnTypes.length > 0 && returnTypes[0] == String.class) { // å­—ç¬¦ä¸²
        value = mock;
    } else if (StringUtils.isNumeric(mock)) { // æ•°å­—
        value = JSON.parse(mock);
    } else if (mock.startsWith("{")) { // Map
        value = JSON.parseObject(mock, Map.class);
    } else if (mock.startsWith("[")) { // List
        value = JSON.parseObject(mock, List.class);
    } else {
        value = mock;
    }
    // è½¬æ¢æˆå¯¹åº”çš„è¿”å›ç±»å‹
    if (returnTypes != null && returnTypes.length > 0) {
        value = PojoUtils.realize(value, (Class<?>) returnTypes[0], returnTypes.length > 1 ? returnTypes[1] /* æ³›å‹ */: null);
    }
    return value;
}
```

- è§£æ**å€¼**ï¼Œå¹¶**è½¬æ¢**æˆå¯¹åº”çš„è¿”å›**ç±»å‹**ã€‚

#### 5.5 getThrowable

```
private Throwable getThrowable(String throwStr) {
    // ä»ç¼“å­˜ä¸­ï¼Œè·å¾— Throwable å¯¹è±¡
    Throwable throwable = throwables.get(throwStr);
    if (throwable != null) {
        return throwable;
    }
    // ä¸å­˜åœ¨ï¼Œåˆ›å»º Throwable å¯¹è±¡
    Throwable t;
    try {
        // è·å¾—å¼‚å¸¸ç±»
        Class<?> bizException = ReflectUtils.forName(throwStr);
        // è·å¾—æ„é€ æ–¹æ³•
        Constructor<?> constructor = ReflectUtils.findConstructor(bizException, String.class);
        // åˆ›å»º Throwable å¯¹è±¡
        t = (Throwable) constructor.newInstance(new Object[]{" mocked exception for Service degradation. "});
        // æ·»åŠ åˆ°ç¼“å­˜ä¸­
        if (throwables.size() < 1000) {
            throwables.put(throwStr, t);
        }
    } catch (Exception e) {
        throw new RpcException("mock throw error :" + throwStr + " argument error.", e);
    }
    return t;
}
```

- ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä»£ç æ³¨é‡Šã€‚

#### 5.6 getInvoker

```
private Invoker<T> getInvoker(String mockService) {
    // ä»ç¼“å­˜ä¸­ï¼Œè·å¾— Invoker å¯¹è±¡
    Invoker<T> invoker = (Invoker<T>) mocks.get(mockService);
    if (invoker != null) {
        return invoker;
    }
    // ä¸å­˜åœ¨ï¼Œåˆ›å»º Invoker å¯¹è±¡
    // 1. è·å¾—æ¥å£ç±»
    Class<T> serviceType = (Class<T>) ReflectUtils.forName(url.getServiceInterface());
    // 2. è‹¥ä¸º `true` `default` ï¼Œä¿®æ”¹ä¿®æ”¹ä¸ºå¯¹åº”æ¥å£ + "Mock" ç±»ã€‚è¿™ç§æƒ…å†µå‡ºç°åœ¨åŸå§‹ `mock = fail:true` æˆ– `mock = force:true` ç­‰æƒ…å†µ
    if (ConfigUtils.isDefault(mockService)) {
        mockService = serviceType.getName() + "Mock";
    }
    // 3. è·å¾— Mock ç±»
    Class<?> mockClass = ReflectUtils.forName(mockService);
    // 4. æ ¡éªŒ Mock ç±»ï¼Œå®ç°äº†æ¥å£ç±»
    if (!serviceType.isAssignableFrom(mockClass)) {
        throw new IllegalArgumentException("The mock implemention class " + mockClass.getName() + " not implement interface " + serviceType.getName());
    }
    try {
        // 5. åˆ›å»º Mock å¯¹è±¡
        T mockObject = (T) mockClass.newInstance();
        // 6. åˆ›å»º Mock å¯¹åº”ï¼Œå¯¹åº”çš„ Invoker å¯¹è±¡
        invoker = proxyFactory.getInvoker(mockObject, serviceType, url);
        // 7. æ·»åŠ åˆ°ç¼“å­˜
        if (mocks.size() < 10000) {
            mocks.put(mockService, invoker);
        }
        return invoker;
    } catch (InstantiationException e) {
        throw new IllegalStateException("No such empty constructor \"public " + mockClass.getSimpleName() + "()\" in mock implemention class " + mockClass.getName(), e);
    } catch (IllegalAccessException e) {
        throw new IllegalStateException(e);
    }
}
```

- ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä»£ç æ³¨é‡Šã€‚

## 6. AbstractInterfaceConfig

`#checkStubAndMock(Class<?> interfaceClass)` æ–¹æ³•ï¼Œæ ¡éªŒ Stub å’Œ **Mock ç›¸å…³çš„é…ç½®**ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
protected void checkStubAndMock(Class<?> interfaceClass) {
    // ã€çœç•¥ä»£ç ã€‘`local` é…ç½®é¡¹çš„æ ¡éªŒï¼Œå’Œ `stub` ä¸€æ ·ã€‚
    // ã€çœç•¥ä»£ç ã€‘`stub` é…ç½®é¡¹çš„æ ¡éªŒ

    // mock é…ç½®æ ¡éªŒ
    if (ConfigUtils.isNotEmpty(mock)) {
        if (mock.startsWith(Constants.RETURN_PREFIX)) { // å¤„ç† "return " å¼€å¤´çš„æƒ…å†µ
            String value = mock.substring(Constants.RETURN_PREFIX.length());
            // æ ¡éªŒ Mock å€¼ï¼Œé…ç½®æ­£ç¡®
            try {
                MockInvoker.parseMockValue(value);
            } catch (Exception e) {
                throw new IllegalStateException("Illegal mock json value in <dubbo:service ... mock=\"" + mock + "\" />");
            }
        } else {
            // è·å¾— Mock ç±»
            Class<?> mockClass = ConfigUtils.isDefault(mock) ? ReflectUtils.forName(interfaceClass.getName() + "Mock") : ReflectUtils.forName(mock);
            // æ ¡éªŒæ˜¯å¦å®ç°æ¥å£ç±»
            if (!interfaceClass.isAssignableFrom(mockClass)) {
                throw new IllegalStateException("The mock implementation class " + mockClass.getName() + " not implement interface " + interfaceClass.getName());
            }
            // æ ¡éªŒæ˜¯å¦æœ‰é»˜è®¤æ„é€ æ–¹æ³•
            try {
                mockClass.getConstructor();
            } catch (NoSuchMethodException e) {
                throw new IllegalStateException("No such empty constructor \"public " + mockClass.getSimpleName() + "()\" in mock implementation class " + mockClass.getName());
            }
        }
    }
}
```

- ä»£ç æ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹çœ‹ä»£ç æ³¨é‡Šã€‚

- ä» Mock é…ç½®æ ¡éªŒçš„é€»è¾‘æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œä¸å…è®¸é…ç½®

   

  ```
  "force:"
  ```

   

  å’Œ

   

  ```
  "fail:"
  ```

   

  ä¸ºå¼€å¤´ã€‚ğŸ˜ˆ æ‰€ä»¥ï¼Œ

  ä¸èƒ½é€šè¿‡

   

  Java API æˆ–è€… XML ï¼Œåˆæˆ–è€…æ³¨è§£æ¥é…ç½® Mock è§„åˆ™ï¼Œåªèƒ½é€šè¿‡

  é…ç½®è§„åˆ™

  æ¥å¼€å¯

  æœåŠ¡é™çº§

  ã€‚å…·ä½“çš„é…ç½®æ–¹å¼ï¼Œå‚è§

   

  ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” æœåŠ¡é™çº§ã€‹

  ã€‚

  - åŒæ ·ï¼Œä¹Ÿä¸å…è®¸é…ç½® `"throws "` å¼€å¤´ã€‚