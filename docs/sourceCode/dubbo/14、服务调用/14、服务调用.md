# æœ¬åœ°è°ƒç”¨

## 1. æ¦‚è¿°

ä»è¿™ç¯‡æ–‡ç« å¼€å§‹ï¼Œæˆ‘ä»¬å¼€å§‹åˆ†äº«**æœåŠ¡è°ƒç”¨**çš„å®ç°ã€‚åœ¨å‰é¢ï¼Œè‰¿è‰¿å·²ç»å†™äº†æœåŠ¡ï¼š

- æœ¬åœ°æš´éœ²ã€è¿œç¨‹æš´éœ²
- æœ¬åœ°å¼•ç”¨ã€è¿œç¨‹å¼•ç”¨

é‚£ä¹ˆåœ¨æœåŠ¡è°ƒç”¨ï¼Œå¿…ç„¶ä¹Ÿæ˜¯åˆ†ï¼š

- æœ¬åœ°è°ƒç”¨
- è¿œç¨‹è°ƒç”¨

æœ¬æ–‡åˆ†äº«**æœ¬åœ°è°ƒç”¨**ï¼Œåœ¨ `dubbo-rpc-injvm` æ¨¡å—å®ç°ã€‚

ç›¸æ¯”è¿œç¨‹è°ƒç”¨ï¼Œå®ç°ä¸Šä¼šç®€å•å¾ˆå¤šï¼šå› ä¸ºè°ƒç”¨çš„æœåŠ¡ï¼Œå°±åœ¨æœ¬åœ°è¿›ç¨‹å†…ï¼Œä¸”ä¸å­˜åœ¨å¤šä¸ªï¼Œæ‰€ä»¥ä¸éœ€è¦**é›†ç¾¤å®¹é”™**å’Œ**ç½‘ç»œé€šä¿¡**ç›¸å…³çš„åŠŸèƒ½ã€‚

## 2. è°ƒè¯•ç¯å¢ƒ

> å‹æƒ…æç¤ºï¼šç¬”è€…å»ºè®®èƒ–å‹å…ˆå°è¯•è‡ªå·±æ­å»ºæœ¬åœ°è°ƒç”¨çš„è°ƒè¯•ç¯å¢ƒï¼Œå¦‚æœç¢°åˆ°é—®é¢˜åœ¨çœ‹æœ¬å°èŠ‚ã€‚

åŸºäº `dubbo-demo-consumer` æ”¹é€ ï¼š

1ã€å°† `dubbo-demo-provider` æ¨¡å—çš„ `com.alibaba.dubbo.demo.provider.DemoServiceImpl` ç±»ï¼Œå¤åˆ¶åˆ° `dubbo-demo-consumer` æ¨¡å—çš„ `com.alibaba.dubbo.demo.consumer` åŒ…ä¸‹ã€‚

2ã€åœ¨ `resources/META-INF/spring` ç›®å½•ä¸‹ï¼Œæ–°å»º `dubbo-demo-injvm.xml` æ–‡ä»¶ï¼Œå†…å®¹å¦‚ä¸‹ï¼š

```
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

    <dubbo:application name="demo-injvm"/>

    <dubbo:registry address="N/A"/>

    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" protocol="injvm" scope="local" />

    <bean id="demoServiceImpl" class="com.alibaba.dubbo.demo.consumer.DemoServiceImpl"/>
    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoServiceImpl" protocol="injvm" scope="local" />

</beans>
```

3ã€ä¿®æ”¹ `com.alibaba.dubbo.demo.consumer.Consumer` ç±»ï¼ŒåŠ è½½çš„ Spring é…ç½®æ–‡ä»¶ä¸º `dubbo-demo-injvm.xml` ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-injvm.xml"});
```

4ã€å¯åŠ¨ Consumer ï¼Œå³å¯å¼€å§‹è°ƒè¯•ã€‚

------

[`dubbo-demo-consumer`](https://github.com/YunaiV/dubbo/tree/f14e4e4fffaede31cbece589e0f543ec6669b2ae/dubbo-demo/dubbo-demo-consumer) ï¼Œæ˜¯ç¬”è€…æ”¹å®Œï¼Œå¯è¿è¡Œçš„ä¸€ä¸ªå¿«ç…§ç‰ˆæœ¬ã€‚

## 3. é¡ºåºå›¾

- æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡çš„é¡ºåºå›¾ï¼š![æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡çš„é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2018_10_01/01.png)
- æä¾›è€…æä¾›æœåŠ¡çš„é¡ºåºå›¾ï¼š![æä¾›è€…æä¾›æœåŠ¡çš„é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2018_10_01/02.png)

ğŸ™‚ æµç¨‹ä¸Šè¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œç¬”è€…å°±ä¸å“”å“”äº†ã€‚å¦‚æœèƒ–å‹ä¸å¤ªç†è§£ï¼Œå¯ä»¥å›çœ‹ä¹‹å‰çš„æ–‡ç« ï¼Œå†å¤šå¤šè°ƒè¯•ç†è§£ï¼Œæˆ–è€…çŸ¥è¯†æ˜Ÿçƒå‘å¸–ä¸€èµ·è®¨è®ºã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹æ¯ä¸ªæ­¥éª¤çš„å®ç°ä»£ç ã€‚

## 4. æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡

#### 4.1 Proxy

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [1] [2] [3]

è§ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” åŠ¨æ€ä»£ç†ï¼ˆä¸€ï¼‰ä¹‹ Javassistã€‹](http://svip.iocoder.cn/Dubbo/proxy-javassist/?self) æ–‡ç« ã€‚

#### 4.2 ProtocolFilterWrapper

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [5]

ProtocolFilterWrapper çš„å¸¦æœ‰è¿‡æ»¤é“¾çš„ Invoker ï¼Œæ•´ä¸ªè°ƒç”¨è¿‡ç¨‹å’Œ J2EE FilterChain æ˜¯ä¸€è‡´çš„ï¼Œå…·ä½“æ¯ä¸ª Dubbo Filter çš„å®ç°ï¼Œæˆ‘ä»¬å¦å¼€æ–‡ç« ã€‚

```
for (int i = filters.size() - 1; i >= 0; i--) {
    final Filter filter = filters.get(i);
    final Invoker<T> next = last;
    last = new Invoker<T>() {

        public Class<T> getInterface() {
            return invoker.getInterface();
        }

        public URL getUrl() {
            return invoker.getUrl();
        }

        public boolean isAvailable() {
            return invoker.isAvailable();
        }

        public Result invoke(Invocation invocation) throws RpcException {
            return filter.invoke(next, invocation);
        }

        public void destroy() {
            invoker.destroy();
        }

        @Override
        public String toString() {
            return invoker.toString();
        }
    };
}
```

`#invoke(invocation)` æ–¹æ³•ä¸­ï¼Œè°ƒç”¨ `Filter#(invoker, invocation)` æ–¹æ³•ï¼Œä¸æ–­æ‰§è¡Œè¿‡æ»¤é€»è¾‘ã€‚è€Œåœ¨ Filter ä¸­ï¼Œåˆä¸æ–­è°ƒç”¨ `Invoker#invoker(invocation)` æ–¹æ³•ï¼Œæœ€ç»ˆæœ€åä¸€ä¸ª Filter ï¼Œä¼šè°ƒç”¨ `InjvmInvoker#invoke(invocation)` æ–¹æ³•ï¼Œç»§ç»­æ‰§è¡Œé€»è¾‘ã€‚

> å‹æƒ…æç¤ºï¼ŒInjvmInvoker åªæ˜¯æ­¤å¤„çš„ä¾‹å­ï¼Œä¸åŒçš„åè®®ï¼Œä¼šè°ƒç”¨ä¸åŒçš„ Invoker å®ç°ç±»ï¼Œä¾‹å¦‚ Dubbo åè®®ï¼Œè°ƒç”¨çš„æ˜¯ DubboInvoker ã€‚

å¦å¤–ï¼ŒFilter è°ƒç”¨ Invoker çš„ç¤ºä¾‹å¦‚ä¸‹ï¼š

```
public class DemoFilter implements Filter {

    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        return invoker.invoke(invocation); // è°ƒç”¨
    }
}
```

#### 4.3 ListenerInvokerWrapper

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [6]

ListenerInvokerWrapper ç±»ï¼Œä¸»è¦ç›®çš„æ˜¯ä¸ºäº† InvokerListener çš„è§¦å‘ï¼Œç›®å‰è¯¥ç›‘å¬å™¨åªæœ‰ `#referred(invoker)` `#destroyed(invoker)` ä¸¤ä¸ªæ¥å£æ–¹æ³•ï¼Œå¹¶æœªå¯¹ `#invoke(invocation)` çš„è¿‡ç¨‹ï¼Œå®ç°ç›‘å¬ã€‚å› æ­¤ï¼ŒListenerInvokerWrapper çš„ `#invoke(invocation)` çš„å®ç°åŸºæœ¬ç­‰äºé›¶ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
@Override
public Result invoke(Invocation invocation) throws RpcException {
    return invoker.invoke(invocation);
}
```

#### 4.4 AbstractInvoker

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [7]

AbstractInvoker ï¼Œåœ¨ `#invoke(invocation)` æ–¹æ³•ä¸­ï¼Œå®ç°äº†**å…¬ç”¨é€»è¾‘**ï¼ŒåŒæ—¶**æŠ½è±¡**äº† `#doInvoke(invocation)` æ–¹æ³•ï¼Œå­ç±»å®ç°è‡ªå®šä¹‰é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: public Result invoke(Invocation inv) throws RpcException {
 2:     if (destroyed.get()) {
 3:         throw new RpcException("Rpc invoker for service " + this + " on consumer " + NetUtils.getLocalHost()
 4:                 + " use dubbo version " + Version.getVersion()
 5:                 + " is DESTROYED, can not be invoked any more!");
 6:     }
 7:     RpcInvocation invocation = (RpcInvocation) inv;
 8:     // è®¾ç½® `invoker` å±æ€§
 9:     invocation.setInvoker(this);
10:     // æ·»åŠ å…¬ç”¨çš„éšå¼ä¼ å‚ï¼Œä¾‹å¦‚ï¼Œ`path` `interface` ç­‰ç­‰ï¼Œè¯¦è§ RpcInvocation ç±»ã€‚
11:     if (attachment != null && attachment.size() > 0) {
12:         invocation.addAttachmentsIfAbsent(attachment);
13:     }
14:     // æ·»åŠ è‡ªå®šä¹‰çš„éšå£«ä¼ å‚
15:     Map<String, String> context = RpcContext.getContext().getAttachments();
16:     if (context != null) {
17:         invocation.addAttachmentsIfAbsent(context);
18:     }
19:     // è®¾ç½® `async=true` ï¼Œè‹¥ä¸ºå¼‚æ­¥æ–¹æ³•
20:     if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {
21:         invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
22:     }
23:     RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
24:
25:     // æ‰§è¡Œè°ƒç”¨
26:     try {
27:         return doInvoke(invocation);
28:     // TODO ã€8023 biz exceptionã€‘
29:     } catch (InvocationTargetException e) { // biz exception
30:         Throwable te = e.getTargetException();
31:         if (te == null) {
32:             return new RpcResult(e);
33:         } else {
34:             if (te instanceof RpcException) {
35:                 ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);
36:             }
37:             return new RpcResult(te);
38:         }
39:     } catch (RpcException e) {
40:         if (e.isBiz()) {
41:             return new RpcResult(e);
42:         } else {
43:             throw e;
44:         }
45:     } catch (Throwable e) {
46:         return new RpcResult(e);
47:     }
48: }
```

- ç¬¬ 7 è‡³ 23 è¡Œï¼šè®¾ç½® `invocation` çš„å±æ€§ã€‚

  - ç¬¬ 9 è¡Œï¼šè®¾ç½® `invoker` å±æ€§ä¸ºè‡ªå·±ã€‚åœ¨ä¸Šé¢ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ° Invoker æ˜¯å±‚å±‚åµŒå¥—ï¼Œåªè¦åˆ°äº†è¿™é‡Œæ‰æ˜¯çœŸæ­£çš„ Invoker å¯¹è±¡ã€‚

  - ç¬¬ 10 è‡³ 13 è¡Œï¼šæ·»åŠ **å…¬ç”¨çš„**çš„éšå¼ä¼ å‚ã€‚ä¾‹å¦‚ï¼Œ`path` `interface` ç­‰ç­‰ã€‚æ‰€æœ‰è§ [RpcInvocation](https://github.com/apache/incubator-dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java#L50-L76) æ„é€ æ–¹æ³•ã€‚ä» `Invocation#addAttachmentsIfAbsent(context)` æ–¹æ³•ï¼Œä¸å­˜åœ¨æ‰æ·»åŠ ï¼Œå› æ­¤ä¸šåŠ¡ä¸Šéšå¼ä¼ å‚çš„ KEY ä¸èƒ½å†²çªåˆ°è¿™å‡ ä¸ªã€‚

  - ç¬¬ 14 è‡³ 18 è¡Œï¼šæ·»åŠ **è‡ªå®šä¹‰çš„**éšå¼ä¼ å‚ï¼Œä» `RpcContext.attachments` ä¸­ã€‚ä½¿ç”¨ RpcContext éšå¼ä¼ å‚éœ€è¦æ³¨æ„ï¼š

    > æ³¨æ„ï¼šRpcContext æ˜¯ä¸€ä¸ªä¸´æ—¶çŠ¶æ€è®°å½•å™¨ï¼Œå½“æ¥æ”¶åˆ° RPC è¯·æ±‚ï¼Œæˆ–å‘èµ· RPC è¯·æ±‚æ—¶ï¼ŒRpcContext çš„çŠ¶æ€éƒ½ä¼šå˜åŒ–ã€‚
    > æ¯”å¦‚ï¼šA è°ƒ Bï¼ŒB å†è°ƒ Cï¼Œåˆ™ B æœºå™¨ä¸Šï¼Œåœ¨ B è°ƒ C ä¹‹å‰ï¼ŒRpcContext è®°å½•çš„æ˜¯ A è°ƒ B çš„ä¿¡æ¯ï¼Œåœ¨ B è°ƒ C ä¹‹åï¼ŒRpcContext è®°å½•çš„æ˜¯ B è°ƒ C çš„ä¿¡æ¯ã€‚

  - ç¬¬ 19 è‡³ 23 è¡Œï¼šå¼‚æ­¥æ–¹æ³•ï¼Œç›¸å…³çš„å¤„ç†ï¼Œåé¢æ–‡ç« åˆ†äº«ã€‚

- ç¬¬ 27 è¡Œï¼šè°ƒç”¨ `#doInvoke(invocation)` **æŠ½è±¡**æ–¹æ³•ï¼Œå®ç°ä¸åŒåè®®è‡ªå®šä¹‰çš„è°ƒç”¨å®ç°ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected abstract Result doInvoke(Invocation invocation) throws Throwable;
  ```

- ç¬¬ 28 è‡³ 47 è¡Œï¼š// TODO ã€8023 biz exceptionã€‘

çœ‹å®Œè¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸€æ¬¡ Dubbo RPC ï¼Œæ¶‰åŠåˆ°æŠ½è±¡æ¨¡å‹å¦‚ä¸‹å›¾ï¼š

![RPC](http://static.iocoder.cn/images/Dubbo/2018_10_01/03.png)

#### 4.5 InjvmInvoker

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [8]

`#doInvoke(invocation)` å®ç°æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
/**
 * Exporter é›†åˆ
 *
 * key: æœåŠ¡é”®
 *
 * è¯¥å€¼å®é™…å°±æ˜¯ {@link com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}
 */
private final Map<String, Exporter<?>> exporterMap;

  1: @Override
  2: public Result doInvoke(Invocation invocation) throws Throwable {
  3:     // è·å¾— Exporter å¯¹è±¡
  4:     Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());
  5:     if (exporter == null) {
  6:         throw new RpcException("Service [" + key + "] not found.");
  7:     }
  8:     // è®¾ç½®æœåŠ¡æä¾›è€…åœ°å€ä¸ºæœ¬åœ°
  9:     RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, 0);
 10:     // è°ƒç”¨
 11:     return exporter.getInvoker().invoke(invocation);
 12: }
```

- ç¬¬ 3 è‡³ 7 è¡Œï¼šè°ƒç”¨

   

  ```
  InjvmProtocol#getExporter(exporterMap, url)
  ```

   

  æ–¹æ³•ï¼Œè·å¾—å¯¹åº”çš„ Exporter å¯¹è±¡ã€‚åœ¨

   

  ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡æš´éœ²ï¼ˆä¸€ï¼‰ä¹‹æœ¬åœ°æš´éœ²ï¼ˆInjvmï¼‰ã€‹

   

  ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼Œ

  ```
  exporterMap
  ```

   

  å±æ€§ï¼Œå°±æ˜¯ä» InjvmProtocol çš„

   

  ```
  exporterMap
  ```

   

  å±æ€§ã€‚

  - åœ¨è¿œç¨‹è°ƒç”¨ä¸­ï¼Œé€‰æ‹©æœåŠ¡æä¾›è€…çš„é€»è¾‘ä¼šæ›´åŠ å¤æ‚ï¼Œåç»­æ–‡ç« è§ã€‚

- ç¬¬ 9 è¡Œï¼šè®¾ç½®æœåŠ¡æä¾›è€…åœ°å€ä¸ºæœ¬åœ°ã€‚

- ç¬¬ 11 è¡Œï¼šè·å¾—åˆ° Exporter å¯¹è±¡ï¼Œé‡Œé¢å°±æœ‰**æœåŠ¡æä¾›è€…çš„ Invoker å¯¹è±¡**ã€‚è°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼Œè°ƒç”¨æœåŠ¡ã€‚

## 5. æä¾›è€…æä¾›æœåŠ¡

#### 5.1 InjvmInvoker

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [1] [2]

åœ¨ [ã€Œ4.5 InjvmInvokerã€](http://svip.iocoder.cn/Dubbo/rpc-injvm/#) å·²ç»åˆ†äº«ã€‚

#### 5.2 ProtocolFilterWrapper

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [3] [4]

åœ¨ [ã€Œ4.2 ProtocolFilterWrapperã€](http://svip.iocoder.cn/Dubbo/rpc-injvm/#) åŸºæœ¬ä¸€è‡´ï¼Œå·®å¼‚ç‚¹åœ¨æœåŠ¡æ¶ˆè´¹è€…å’Œæä¾›è€…çš„è¿‡æ»¤å™¨æ˜¯**ä¸åŒ**çš„ã€‚

#### 5.3 DelegateProviderMetaDataInvoker

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [5]

DelegateProviderMetaDataInvoker ï¼Œå¸¦æœ‰æœåŠ¡æä¾›è€…é…ç½® ServiceConfig çš„ Invoker å¯¹è±¡ã€‚ä»ç›®å‰ä»£ç ä¸Šæ¥çœ‹ï¼ŒServiceConfig æš‚æ—¶æ²¡ç”¨åˆ°ã€‚

`#invoke(invocation)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
/**
 * Invoker å¯¹è±¡
 */
protected final Invoker<T> invoker;
/**
 * æœåŠ¡æä¾›è€…é…ç½®
 */
private ServiceConfig metadata;

@Override
public Result invoke(Invocation invocation) throws RpcException {
    return invoker.invoke(invocation);
}
```

#### 5.4 Wrapper

> æç¤ºï¼šå¯¹åº”å›¾ä¸­ [6] [7] [8] [9]

è§ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” åŠ¨æ€ä»£ç†ï¼ˆä¸€ï¼‰ä¹‹ Javassistã€‹](http://svip.iocoder.cn/Dubbo/proxy-javassist/?self) æ–‡ç« ã€‚

# è¿œç¨‹è°ƒç”¨-1:é€šä¿¡å®ç°

## 1. æ¦‚è¿°

ä»æœ¬æ–‡å¼€å§‹ï¼Œæˆ‘ä»¬å¼€å§‹åˆ†äº« `dubbo://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**å››ä¸ªéƒ¨åˆ†**ï¼š

1. é€šä¿¡å®ç°
2. åŒæ­¥è°ƒç”¨
3. å¼‚æ­¥è°ƒç”¨
4. å‚æ•°å›è°ƒ

æœ¬æ–‡åˆ†äº« **é€šä¿¡å®ç°** éƒ¨åˆ†ã€‚

ğŸ˜ˆ [ã€Šç²¾å°½ Dubbo æºç è§£æ â€”â€” NIO æœåŠ¡å™¨ã€‹](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/#) ç³»åˆ—ï¼Œæ˜¯æœ¬æ–‡çš„**å‰ç½®æ–‡ç« **ï¼Œæ‰€ä»¥èƒ–å‹éœ€è¦å…ˆè¯»å®Œè¿™ä¸ªç³»åˆ—ã€‚å“ˆå“ˆå“ˆï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä»¥å‡‘åˆçœ‹çœ‹å…ˆã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾å¦‚ä¸‹ï¼š

[![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_04/01_01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_04/01_01.png)ç±»å›¾

## 2. Server

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹æš´éœ²ï¼ˆDubboï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-export-dubbo/?self) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨çš„ Server å®ç°ç±»æ˜¯ **HeaderExchangeServer** ã€‚

## 3. Client

åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡å¼•ç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹å¼•ç”¨ï¼ˆDubboï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨çš„ Client å®ç°ç±»æ˜¯ **ReferenceCountExchangeClient** å’Œ **LazyConnectExchangeClient** ã€‚

## 4. ExchangeHandler

åœ¨ DubboProtocol ä¸­ï¼Œå®ç°äº† ExchangeHandler ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {

    @Override
    public Object reply(ExchangeChannel channel, Object message) throws RemotingException {
        // ... çœç•¥å…·ä½“å®ç°
    }

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        // ... çœç•¥å…·ä½“å®ç°
    }

    @Override
    public void connected(Channel channel) throws RemotingException {
        this.invoke(channel, Constants.ON_CONNECT_KEY);
    }

    @Override
    public void disconnected(Channel channel) throws RemotingException {
        // ... çœç•¥å…·ä½“å®ç°
    }

    private void invoke(Channel channel, String methodKey) {
        // ... çœç•¥å…·ä½“å®ç°
    }

};
```

è¿™ä¸ªå¤„ç†å™¨ï¼Œè´Ÿè´£å°†è¯·æ±‚ï¼Œ**è½¬å‘åˆ°å¯¹åº”çš„ Invoker å¯¹è±¡**ï¼Œæ‰§è¡Œé€»è¾‘ï¼Œè¿”å›ç»“æœã€‚
å½“ç„¶ï¼Œæœ¬æ–‡ä¸ç»†åˆ†äº«ï¼Œæ”¾åœ¨ **åŒæ­¥è°ƒç”¨** ä¸€æ–‡è¯¦ç»†è§£æã€‚

## 5. Codec

åœ¨ [ExchangeCodec](https://github.com/apache/incubator-dubbo/blob/master/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java) ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°å¯¹ Request å’Œ Response çš„**é€šç”¨**è§£æã€‚ä½†æ˜¯å®ƒæ˜¯**ä¸æ»¡è¶³**åœ¨ `dubbo://` åè®®ä¸­ï¼Œå¯¹ [RpcInvocation](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) å’Œ [RpcResult](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) ä½œä¸º **å†…å®¹ä½“( Body )** çš„ç¼–è§£ç çš„éœ€è¦çš„ã€‚

å¦å¤–ï¼Œåœ¨ `dubbo://` åè®®ä¸­ï¼Œæ”¯æŒ [å‚æ•°å›è°ƒ](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) çš„ç‰¹æ€§ï¼Œä¹Ÿæ˜¯éœ€è¦åœ¨ç¼–è§£ç åšä¸€äº›**ç‰¹æ®Šé€»è¾‘**ã€‚

ä¸‹é¢ï¼Œè®©æˆ‘ä»¬æ¥ä¸€èµ·ç…ç…ä»£ç å®ç°å§ã€‚

#### 5.1 DubboCountCodec

[`com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ï¼Œå®ç° Codec2 æ¥å£ï¼Œæ”¯æŒ**å¤šæ¶ˆæ¯**çš„ç¼–è§£ç å™¨ã€‚

###### 5.1.1 æ„é€ æ–¹æ³•

```
/**
 * ç¼–è§£ç å™¨
 */
private DubboCodec codec = new DubboCodec();
```

- åœ¨ Dubbo Client å’Œ Server åˆ›å»ºçš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬çœ‹åˆ°è®¾ç½®äº†ç¼–è§£ç å™¨ä¸º `"dubbo"` ï¼Œä»è€Œé€šè¿‡ Dubbo SPI æœºåˆ¶ï¼ŒåŠ è½½åˆ° DubboCountCodec ã€‚ç›¸å…³å†…å®¹å¦‚ä¸‹ï¼š

  ```
  // DubboProtocol#createServer(...)
  url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
  
  // DubboProtocol#initClient(...)
  url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
  
  // META-INF/dubbo/internal/com.alibaba.dubbo.remoting.Codec2
  dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec
  ```

- å®é™…ç¼–è§£ç çš„é€»è¾‘ï¼Œä½¿ç”¨ DubboCodec ï¼Œå³ `codec` å±æ€§ã€‚

###### 5.1.2 ç¼–ç 

```
@Override
public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {
    codec.encode(channel, buffer, msg);
}
```

###### 5.1.3 è§£ç 

```
 1: @Override
 2: public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {
 3:     // è®°å½•å½“å‰è¯»ä½ç½®
 4:     int save = buffer.readerIndex();
 5:     // åˆ›å»º MultiMessage å¯¹è±¡
 6:     MultiMessage result = MultiMessage.create();
 7:     do {
 8:         // è§£ç 
 9:         Object obj = codec.decode(channel, buffer);
10:         // è¾“å…¥ä¸å¤Ÿï¼Œé‡ç½®è¯»è¿›åº¦
11:         if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {
12:             buffer.readerIndex(save);
13:             break;
14:         // è§£æåˆ°æ¶ˆæ¯
15:         } else {
16:             // æ·»åŠ ç»“æœæ¶ˆæ¯
17:             result.addMessage(obj);
18:             // è®°å½•æ¶ˆæ¯é•¿åº¦åˆ°éšå¼å‚æ•°é›†åˆï¼Œç”¨äº MonitorFilter ç›‘æ§
19:             logMessageLength(obj, buffer.readerIndex() - save);
20:             // è®°å½•å½“å‰è¯»ä½ç½®
21:             save = buffer.readerIndex();
22:         }
23:     } while (true);
24:     // éœ€è¦æ›´å¤šçš„è¾“å…¥
25:     if (result.isEmpty()) {
26:         return Codec2.DecodeResult.NEED_MORE_INPUT;
27:     }
28:     // è¿”å›è§£æåˆ°çš„æ¶ˆæ¯
29:     if (result.size() == 1) {
30:         return result.get(0);
31:     }
32:     return result;
33: }
```

- åŒ…å«ä¸¤å—é€»è¾‘ï¼š1ï¼‰å¤šæ¶ˆæ¯è§£æçš„æ”¯æŒã€‚2ï¼‰è®°å½•æ¯æ¡æ¶ˆæ¯çš„é•¿åº¦ï¼Œç”¨äº MonitorFilter ç›‘æ§ã€‚

- ç¬¬ 4 è¡Œï¼šè®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºä¸‹é¢è®¡ç®—æ¯æ¡æ¶ˆæ¯çš„é•¿åº¦ã€‚

- ç¬¬ 6 è¡Œï¼šåˆ›å»º MultiMessage å¯¹è±¡ã€‚MultiMessageHandler æ”¯æŒå¯¹å®ƒçš„å¤„ç†åˆ†å‘ã€‚

- ç¬¬ 7 è‡³ 23 è¡Œï¼š**å¾ªç¯**è§£ææ¶ˆæ¯ï¼Œç›´åˆ°ç»“æŸã€‚

- ç¬¬ 9 è¡Œï¼šè°ƒç”¨ `DubboCodec#decode(channel, buffer)` æ–¹æ³•ï¼Œè§£ç ã€‚

- ç¬¬ 11 è‡³ 13 è¡Œï¼šå­—èŠ‚æ•°ç»„ä¸å¤Ÿï¼Œé‡ç½®è¯»è¿›åº¦ï¼Œç»“æŸè§£æã€‚

- ç¬¬ 15 è‡³ 22 è¡Œï¼šè§£æåˆ°æ¶ˆæ¯ï¼Œæ·»åŠ åˆ° `result` ã€‚

  - ç¬¬ 19 è¡Œï¼šè°ƒç”¨ `#logMessageLength(obj, length)` æ–¹æ³•ï¼Œè®°å½•æ¶ˆæ¯é•¿åº¦åˆ°**éšå¼å‚æ•°é›†åˆ**ï¼Œç”¨äº MonitorFilter ç›‘æ§ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    private void logMessageLength(Object result, int bytes) {
        if (bytes <= 0) {
            return;
        }
        if (result instanceof Request) {
            try {
                ((RpcInvocation) ((Request) result).getData()).setAttachment(Constants.INPUT_KEY, String.valueOf(bytes)); // è¯·æ±‚
            } catch (Throwable e) {
                /* ignore */
            }
        } else if (result instanceof Response) {
            try {
                ((RpcResult) ((Response) result).getResult()).setAttachment(Constants.OUTPUT_KEY, String.valueOf(bytes)); // å“åº”
            } catch (Throwable e) {
                /* ignore */
            }
        }
    }
    ```

    - x

  - ç¬¬ 21 è¡Œï¼šè®°å½•å½“å‰è¯»ä½ç½®ï¼Œç”¨äºè®¡ç®—**ä¸‹ä¸€æ¡**æ¶ˆæ¯çš„é•¿åº¦ã€‚

- ç¬¬ 24 è‡³ 27 è¡Œï¼šéœ€è¦æ›´å¤šçš„è¾“å…¥ã€‚

- ç¬¬ 28 è‡³ 32 è¡Œï¼šè¿”å›ç»“æœã€‚

#### 5.2 DubboCodec

[`com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ï¼Œå®ç° Codec2 æ¥å£ï¼Œç»§æ‰¿ ExchangeCodec ç±»ï¼Œ**Dubbo ç¼–è§£ç å™¨**å®ç°ç±»ã€‚

###### 5.2.1 æ„é€ æ–¹æ³•

```
/**
 * åè®®å
 */
public static final String NAME = "dubbo";
/**
 * åè®®ç‰ˆæœ¬
 */
public static final String DUBBO_VERSION = Version.getVersion(DubboCodec.class, Version.getVersion());

/**
 * å“åº” - å¼‚å¸¸
 */
public static final byte RESPONSE_WITH_EXCEPTION = 0;
/**
 * å“åº” - æ­£å¸¸ï¼ˆç©ºè¿”å›ï¼‰
 */
public static final byte RESPONSE_VALUE = 1;
/**
 * å“åº” - æ­£å¸¸ï¼ˆæœ‰è¿”å›ï¼‰
 */
public static final byte RESPONSE_NULL_VALUE = 2;

/**
 * æ–¹æ³•å‚æ•° - ç©ºï¼ˆå‚æ•°ï¼‰
 */
public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
/**
 * æ–¹æ³•å‚æ•° - ç©ºï¼ˆç±»å‹ï¼‰
 */
public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];
```

###### 5.2.2 ç¼–ç å†…å®¹ä½“

####### 5.2.2.1 è¯·æ±‚

```
 1: @Override
 2: protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException {
 3:     RpcInvocation inv = (RpcInvocation) data;
 4: 
 5:     // å†™å…¥ `dubbo` `path` `version`
 6:     out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));
 7:     out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
 8:     out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));
 9: 
10:     // å†™å…¥æ–¹æ³•ã€æ–¹æ³•ç­¾åã€æ–¹æ³•å‚æ•°é›†åˆ
11:     out.writeUTF(inv.getMethodName());
12:     out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
13:     Object[] args = inv.getArguments();
14:     if (args != null) {
15:         for (int i = 0; i < args.length; i++) {
16:             out.writeObject(CallbackServiceCodec.encodeInvocationArgument(channel, inv, i));
17:         }
18:     }
19: 
20:     // å†™å…¥éšå¼ä¼ å‚é›†åˆ
21:     out.writeObject(inv.getAttachments());
22: }
```

- ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚
- ç¼–ç  RpcInvocation å¯¹è±¡ï¼Œå†™å…¥éœ€è¦ç¼–ç çš„å­—æ®µã€‚
- å¯¹åº”çš„è§£ç ï¼Œåœ¨ DecodeableRpcInvocation ä¸­ã€‚
- ç¬¬ 16 è¡Œï¼šè°ƒç”¨ `CallbackServiceCodec#encodeInvocationArgument(...)` æ–¹æ³•ï¼Œç¼–ç å‚æ•°ã€‚ä¸»è¦ç”¨äº [å‚æ•°å›è°ƒ](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) åŠŸèƒ½ï¼Œåé¢çš„æ–‡ç« ï¼Œè¯¦ç»†è§£æã€‚

####### 5.2.2.2 å“åº”

```
 1: @Override
 2: protected void encodeResponseData(Channel channel, ObjectOutput out, Object data) throws IOException {
 3:     Result result = (Result) data;
 4: 
 5:     Throwable th = result.getException();
 6:     // æ­£å¸¸
 7:     if (th == null) {
 8:         Object ret = result.getValue();
 9:         // ç©ºè¿”å›
10:         if (ret == null) {
11:             out.writeByte(RESPONSE_NULL_VALUE);
12:         // æœ‰è¿”å›
13:         } else {
14:             out.writeByte(RESPONSE_VALUE);
15:             out.writeObject(ret);
16:         }
17:     // å¼‚å¸¸
18:     } else {
19:         out.writeByte(RESPONSE_WITH_EXCEPTION);
20:         out.writeObject(th);
21:     }
22: }
```

- ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚
- ç¼–ç  Result å¯¹è±¡ï¼Œå†™å…¥éœ€è¦ç¼–ç çš„å­—æ®µã€‚
- å¯¹åº”çš„è§£ç ï¼Œåœ¨ DecodeableRpcResult ä¸­ã€‚

###### 5.2.3 è§£ç å†…å®¹ä½“

```
 1: @Override
 2: protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
 3:     byte flag = header[2];
 4:     // è·å¾— Serialization å¯¹è±¡
 5:     byte proto = (byte) (flag & SERIALIZATION_MASK);
 6:     Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
 7:     // è·å¾—è¯·æ±‚||å“åº”ç¼–å·
 8:     // get request id.
 9:     long id = Bytes.bytes2long(header, 4);
10:     // è§£æå“åº”
11:     if ((flag & FLAG_REQUEST) == 0) {
12:         // decode response.
13:         Response res = new Response(id);
14:         // ... çœç•¥ä»£ç 
15:         return res;
16:     // è§£æè¯·æ±‚
17:     } else {
18:         // decode request.
19:         Request req = new Request(id);
20:         // ... çœç•¥ä»£ç 
21:         return req;
22:     }
23: }
```

- ç¬¬ 4 è‡³ 6 è¡Œï¼šè°ƒç”¨ `CodeSupport#getSerialization(url, proto)` æ–¹æ³•ï¼Œè·å¾— Serialization å¯¹è±¡ï¼Œç”¨äºä¸‹é¢ååºåˆ—åŒ–å†…å®¹ä½“çš„æ¯ä¸ªå­—æ®µã€‚
- ç¬¬ 9 è¡Œï¼šè·å¾—è¯·æ±‚æˆ–å“åº”çš„ç¼–å·ã€‚
- ç¬¬ 10 è‡³ 15 è¡Œï¼šè§£æå“åº”( Response )ã€‚
- ç¬¬ 16 è‡³ 22 è¡Œï¼šè§£æè¯·æ±‚( Request )ã€‚

####### 5.2.3.1 è¯·æ±‚

```
 1: // decode response.
 2: Response res = new Response(id);
 3: // è‹¥æ˜¯å¿ƒè·³äº‹ä»¶ï¼Œè¿›è¡Œè®¾ç½®
 4: if ((flag & FLAG_EVENT) != 0) {
 5:     res.setEvent(Response.HEARTBEAT_EVENT);
 6: }
 7: // è®¾ç½®çŠ¶æ€
 8: // get status.
 9: byte status = header[3];
10: res.setStatus(status);
11: // æ­£å¸¸å“åº”çŠ¶æ€
12: if (status == Response.OK) {
13:     try {
14:         Object data;
15:         // è§£ç å¿ƒè·³äº‹ä»¶
16:         if (res.isHeartbeat()) {
17:             data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
18:         // è§£ç å…¶å®ƒäº‹ä»¶
19:         } else if (res.isEvent()) {
20:             data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
21:         // è§£ç æ™®é€šå“åº”
22:         } else {
23:             DecodeableRpcResult result;
24:             // åœ¨é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ï¼Œè§£ç 
25:             if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
26:                 result = new DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto);
27:                 result.decode();
28:             // åœ¨ Dubbo ThreadPool çº¿ç¨‹ï¼Œè§£ç ï¼Œä½¿ç”¨ DecodeHandler
29:             } else {
30:                 result = new DecodeableRpcResult(channel, res, new UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto);
31:             }
32:             data = result;
33:         }
34:         // è®¾ç½®ç»“æœ
35:         res.setResult(data);
36:     } catch (Throwable t) {
37:         if (log.isWarnEnabled()) {
38:             log.warn("Decode response failed: " + t.getMessage(), t);
39:         }
40:         res.setStatus(Response.CLIENT_ERROR);
41:         res.setErrorMessage(StringUtils.toString(t));
42:     }
43: // å¼‚å¸¸å“åº”çŠ¶æ€
44: } else {
45:     res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
46: }
47: return res;
```

- ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚æˆ‘ä»¬é‡ç‚¹è®²ä¸‹å¯èƒ½**æ¯”è¾ƒç»•**çš„åœ°æ–¹ã€‚

- ç¬¬ 21 è‡³ 33 è¡Œï¼šè§£ç æ™®é€šå“åº”ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä»£ç åˆ†æˆã€ç¬¬ 25 è‡³ 27 è¡Œã€‘ã€ç¬¬ 28 è‡³ 31 è¡Œã€‘

  ä¸¤æ®µ

  ã€‚

  - ç›¸åŒç‚¹ï¼Œä½¿ç”¨ **DecodeableRpcResult** è§£ç ã€‚å‰è€…ï¼Œæ¯”è¾ƒå¥½ç†è§£ï¼Œã€ç¬¬ 27 è¡Œã€‘å·²ç»è°ƒç”¨ï¼›åè€…ï¼Œåœ¨ DecodeHandler ä¸­ï¼Œæ‰æœ€ç»ˆè°ƒç”¨ `DecodeableRpcResult#decode()` æ–¹æ³•ã€‚
  - å·®å¼‚ç‚¹ï¼Œä½¿ç”¨**å“ªä¸ªçº¿ç¨‹**è§£ç ã€‚å‰è€…ï¼Œè¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£ï¼Œå½“å‰çº¿ç¨‹ï¼Œå³é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ã€‚åè€…ï¼ŒDubbo ThreadPool çº¿ç¨‹ä¸­ã€‚
  - `decode.in.io` é…ç½®é¡¹ï¼Œç›®å‰åœ¨ Dubbo æ–‡æ¡£ä¸­ï¼Œå¹¶æœªè¯´æ˜ï¼Œåº”è¯¥æ˜¯**æ€§èƒ½è°ƒä¼˜**ï¼Œå…·ä½“ç¬”è€…è¿˜æ²¡æµ‹è¯•è¿‡ã€‚å˜¿å˜¿ã€‚

####### 5.2.3.2 å“åº”

```
 1: // decode request.
 2: Request req = new Request(id);
 3: req.setVersion("2.0.0");
 4: // æ˜¯å¦éœ€è¦å“åº”
 5: req.setTwoWay((flag & FLAG_TWOWAY) != 0);
 6: // è‹¥æ˜¯å¿ƒè·³äº‹ä»¶ï¼Œè¿›è¡Œè®¾ç½®
 7: if ((flag & FLAG_EVENT) != 0) {
 8:     req.setEvent(Request.HEARTBEAT_EVENT);
 9: }
10: try {
11:     Object data;
12:     // è§£ç å¿ƒè·³äº‹ä»¶
13:     if (req.isHeartbeat()) {
14:         data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
15:     // è§£ç å…¶å®ƒäº‹ä»¶
16:     } else if (req.isEvent()) {
17:         data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
18:     // è§£ç æ™®é€šè¯·æ±‚
19:     } else {
20:         // åœ¨é€šä¿¡æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒNettyï¼‰çš„ IO çº¿ç¨‹ï¼Œè§£ç 
21:         DecodeableRpcInvocation inv;
22:         if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
23:             inv = new DecodeableRpcInvocation(channel, req, is, proto);
24:             inv.decode();
25:         // åœ¨ Dubbo ThreadPool çº¿ç¨‹ï¼Œè§£ç ï¼Œä½¿ç”¨ DecodeHandler
26:         } else {
27:             inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(readMessageData(is)), proto);
28:         }
29:         data = inv;
30:     }
31:     req.setData(data);
32: } catch (Throwable t) {
33:     if (log.isWarnEnabled()) {
34:         log.warn("Decode request failed: " + t.getMessage(), t);
35:     }
36:     // bad request
37:     req.setBroken(true);
38:     req.setData(t);
39: }
40: return req;
```

- å’Œ [ã€Œ5.2.3.1 è¯·æ±‚ã€](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/#) **ç±»ä¼¼**ï¼Œå·®å¼‚ç‚¹åœ¨ä½¿ç”¨ **DecodeableRpcInvocation** ã€‚
- ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

#### 5.3 DecodeableRpcInvocation

[`com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java) ï¼Œå®ç° Codec å’Œ Decodeable æ¥å£ï¼Œç»§æ‰¿ RpcInvocation ç±»ï¼Œ**å¯è§£ç **çš„ RpcInvocation å®ç°ç±»ã€‚

å½“æœåŠ¡æ¶ˆè´¹è€…ï¼Œè°ƒç”¨æœåŠ¡æä¾›è€…ï¼Œå‰è€…ç¼–ç çš„ RpcInvocation å¯¹è±¡ï¼Œåè€…è§£ç æˆ DecodeableRpcInvocation å¯¹è±¡ã€‚

ä»ç›®å‰çš„ä»£ç å®ç°æ¥çœ‹ï¼ŒCodec æ¥å£ï¼Œå¯ä¸å®ç°ã€‚

###### 5.3.1 æ„é€ æ–¹æ³•

```
/**
 * é€šé“
 */
private Channel channel;
/**
 * Serialization ç±»å‹ç¼–å·
 */
private byte serializationType;
/**
 * è¾“å…¥æµ
 */
private InputStream inputStream;
/**
 * è¯·æ±‚
 */
private Request request;
/**
 * æ˜¯å¦å·²ç»è§£ç å®Œæˆ
 */
private volatile boolean hasDecoded;
```

###### 5.3.2 è§£ç 

```
@Override
public void decode() {
    if (!hasDecoded && channel != null && inputStream != null) {
        try {
            decode(channel, inputStream);
        } catch (Throwable e) {
            if (log.isWarnEnabled()) {
                log.warn("Decode rpc invocation failed: " + e.getMessage(), e);
            }
            request.setBroken(true);
            request.setData(e);
        } finally {
            hasDecoded = true;
        }
    }
}

@Override
public Object decode(Channel channel, InputStream input) throws IOException {
    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);

    // è§£ç  `dubbo` `path` `version`
    setAttachment(Constants.DUBBO_VERSION_KEY, in.readUTF());
    setAttachment(Constants.PATH_KEY, in.readUTF());
    setAttachment(Constants.VERSION_KEY, in.readUTF());

    // è§£ç æ–¹æ³•ã€æ–¹æ³•ç­¾åã€æ–¹æ³•å‚æ•°é›†åˆ
    setMethodName(in.readUTF());
    try {
        Object[] args;
        Class<?>[] pts;
        String desc = in.readUTF();
        if (desc.length() == 0) {
            pts = DubboCodec.EMPTY_CLASS_ARRAY;
            args = DubboCodec.EMPTY_OBJECT_ARRAY;
        } else {
            pts = ReflectUtils.desc2classArray(desc);
            args = new Object[pts.length];
            for (int i = 0; i < args.length; i++) {
                try {
                    args[i] = in.readObject(pts[i]);
                } catch (Exception e) {
                    if (log.isWarnEnabled()) {
                        log.warn("Decode argument failed: " + e.getMessage(), e);
                    }
                }
            }
        }
        setParameterTypes(pts);

        // è§£ç éšå¼ä¼ å‚é›†åˆ
        Map<String, String> map = (Map<String, String>) in.readObject(Map.class);
        if (map != null && map.size() > 0) {
            Map<String, String> attachment = getAttachments();
            if (attachment == null) {
                attachment = new HashMap<String, String>();
            }
            attachment.putAll(map);
            setAttachments(attachment);
        }

        // è¿›ä¸€æ­¥è§£ç æ–¹æ³•å‚æ•°ï¼Œä¸»è¦ä¸ºäº†å‚æ•°è¿”å›
        // decode argument ,may be callback
        for (int i = 0; i < args.length; i++) {
            args[i] = CallbackServiceCodec.decodeInvocationArgument(channel, this, pts, i, args[i]);
        }
        setArguments(args);
    } catch (ClassNotFoundException e) {
        throw new IOException(StringUtils.toString("Read invocation data failed.", e));
    } finally {
        if (in instanceof Cleanable) {
            ((Cleanable) in).cleanup();
        }
    }
    return this;
}
```

- ğŸ™‚ èƒ–å‹çœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

#### 5.4 DecodeableRpcResult

> å’Œ DecodeableRpcInvocation ä¸€è‡´ã€‚

[`com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java) ï¼Œå®ç° Codec å’Œ Decodeable æ¥å£ï¼Œç»§æ‰¿ RpcResult ç±»ï¼Œ**å¯è§£ç **çš„ RpcResult å®ç°ç±»ã€‚

å½“æœåŠ¡æä¾›è€…è€…ï¼Œè¿”å›æœåŠ¡æ¶ˆè´¹è€…è°ƒç”¨ç»“æœï¼Œå‰è€…ç¼–ç çš„ RpcResult å¯¹è±¡ï¼Œåè€…è§£ç æˆ DecodeableRpcResult å¯¹è±¡ã€‚

ä»ç›®å‰çš„ä»£ç å®ç°æ¥çœ‹ï¼ŒCodec æ¥å£ï¼Œå¯ä¸å®ç°ã€‚

###### 5.4.1 æ„é€ æ–¹æ³•

```
/**
 * é€šé“
 */
private Channel channel;
/**
 * Serialization ç±»å‹ç¼–å·
 */
private byte serializationType;
/**
 * è¾“å…¥æµ
 */
private InputStream inputStream;
/**
 * è¯·æ±‚
 */
private Response response;
/**
 * Invocation å¯¹è±¡
 */
private Invocation invocation;
/**
 * æ˜¯å¦å·²ç»è§£ç å®Œæˆ
 */
private volatile boolean hasDecoded;
```

###### 5.4.2 è§£ç 

```
@Override
public void decode() {
    if (!hasDecoded && channel != null && inputStream != null) {
        try {
            decode(channel, inputStream);
        } catch (Throwable e) {
            if (log.isWarnEnabled()) {
                log.warn("Decode rpc result failed: " + e.getMessage(), e);
            }
            response.setStatus(Response.CLIENT_ERROR);
            response.setErrorMessage(StringUtils.toString(e));
        } finally {
            hasDecoded = true;
        }
    }
}

@Override
public Object decode(Channel channel, InputStream input) throws IOException {
    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);

    // è¯»å–æ ‡è®°ä½
    byte flag = in.readByte();
    switch (flag) {
        case DubboCodec.RESPONSE_NULL_VALUE: // æ— è¿”å›å€¼
            break;
        case DubboCodec.RESPONSE_VALUE: // æœ‰è¿”å›å€¼
            try {
                Type[] returnType = RpcUtils.getReturnTypes(invocation);
                setValue(returnType == null || returnType.length == 0 ? in.readObject() :
                        (returnType.length == 1 ? in.readObject((Class<?>) returnType[0])
                                // è¿”å›ç»“æœ:Type[]{method.getReturnType(), method.getGenericReturnType()}
                                : in.readObject((Class<?>) returnType[0], returnType[1])));
            } catch (ClassNotFoundException e) {
                throw new IOException(StringUtils.toString("Read response data failed.", e));
            }
            break;
        case DubboCodec.RESPONSE_WITH_EXCEPTION: // å¼‚å¸¸
            try {
                Object obj = in.readObject();
                if (!(obj instanceof Throwable)) {
                    throw new IOException("Response data error, expect Throwable, but get " + obj);
                }
                setException((Throwable) obj);
            } catch (ClassNotFoundException e) {
                throw new IOException(StringUtils.toString("Read response data failed.", e));
            }
            break;
        default:
            throw new IOException("Unknown result flag, expect '0' '1' '2', get " + flag);
    }
    if (in instanceof Cleanable) {
        ((Cleanable) in).cleanup();
    }
    return this;
}
```

# è¿œç¨‹è°ƒç”¨-2:åŒæ­¥è°ƒç”¨

## 1. æ¦‚è¿°

æœ¬æ–‡åˆ†äº« `dubbo://` åè®®çš„è¿œç¨‹è°ƒç”¨çš„**ç¬¬äºŒéƒ¨åˆ†ï¼šåŒæ­¥è°ƒç”¨**ã€‚

åœ¨ `dubbo://` åè®®çš„è°ƒç”¨ï¼Œä¸€å…±åˆ†æˆä¸‰ç§ï¼š

1. sync åŒæ­¥è°ƒç”¨
2. async å¼‚æ­¥è°ƒç”¨
3. oneway å•å‘è°ƒç”¨

å‰ä¸¤ç§æ¯”è¾ƒå¥½ç†è§£ï¼Œéƒ½æ˜¯åŸºäº Request Response æ¨¡å‹ï¼Œå·®å¼‚ç‚¹åœ¨å¼‚æ­¥è°ƒç”¨ï¼ŒæœåŠ¡æ¶ˆè´¹è€…**ä¸é˜»å¡**ç­‰å¾…ç»“æœï¼Œè€Œæ˜¯é€šè¿‡**å›è°ƒ**çš„æ–¹å¼ï¼Œå¤„ç†æœåŠ¡æä¾›è€…è¿”å›çš„ç»“æœã€‚
æœ€åä¸€ç§ï¼ŒåŸºäº Message æ¨¡å‹ï¼Œå‘èµ·è°ƒç”¨ï¼Œè€Œä¸å…³æ³¨ç­‰å¾…å’Œå…³æ³¨æ‰§è¡Œç»“æœã€‚
å› æ­¤ï¼Œä»æ€§èƒ½ä¸Šï¼šoneway > async > sync ã€‚

> å‹æƒ…æç¤ºï¼šæœ¬æ–‡ä¼šåˆ†äº« sync å’Œ oneway ä¸¤ç§æ–¹å¼ã€‚

## 2. é¡ºåºå›¾

- æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡çš„é¡ºåºå›¾ï¼š[![é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg)é¡ºåºå›¾

  - æ­¤å›¾æ˜¯åœ¨

     

    ```
    injvm://
    ```

     

    åè®®çš„é¡ºåºå›¾çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼š

    - å°† InjvmInvoker æ›¿æ¢æˆ DubboInvoker ã€‚
    - åœ¨ `#doInvoker()` æ–¹æ³•ä¸­ï¼ŒDubboInvoker ä¼šè°ƒç”¨ Client ï¼Œå‘æœåŠ¡æä¾›è€…å‘èµ·è¯·æ±‚ã€‚

  - å¯èƒ½ä¼šæœ‰èƒ–å‹é—®ï¼Œ

    é›†ç¾¤å®¹é”™

    å‘¢ï¼Ÿåœ¨ InvokerInvocationHandler ä¹‹åï¼ŒProtocolFilterWrapper$Invoker ä¹‹å‰ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

    ![é›†ç¾¤å®¹é”™](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_02.png)

    é›†ç¾¤å®¹é”™

    - ğŸ™‚ æˆ‘ä»¬åé¢ä¸“é—¨å†™å‡ ç¯‡æ–‡ç« ï¼Œä¸“é—¨åˆ†äº«é›†ç¾¤å®¹é”™ï¼Œæ‰€ä»¥æœ¬æ–‡ç•¥è¿‡ã€‚

- æä¾›è€…æä¾›æœåŠ¡çš„é¡ºåºå›¾ï¼š[![é¡ºåºå›¾](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg)é¡ºåºå›¾

  - æ­¤å›¾æ˜¯åœ¨

     

    ```
    injvm://
    ```

     

    åè®®çš„é¡ºåºå›¾çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼š

    - InjvmInvoker æ›¿æ¢æˆ ExchangeServer ã€‚ä¾‹å¦‚åœ¨ Netty4 ä¸­ï¼ŒIO Worker è§£æè¯·æ±‚ï¼Œè½¬å‘ç»™ ExchangeHandler å¤„ç†ã€‚
    - InjvmProtocol æ›¿æ¢æˆ DubboProtocol ã€‚åœ¨è¯¥ç±»ä¸­ï¼Œå®ç°äº†è‡ªå®šä¹‰çš„ ExchangeHandler å¤„ç†è¯·æ±‚ã€‚**æ³¨æ„**ï¼Œåœ¨ **Dubbo ThreadPool** ä¸­å¤„ç†è¯·æ±‚ï¼Œå‚è§ [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” çº¿ç¨‹æ¨¡å‹ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html) æ–‡æ¡£ã€‚

## 3. æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡

è°ƒç”¨ `DubboInvoker#invoke(Invocation)` æ–¹æ³•ï¼Œè°ƒç”¨æœåŠ¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
/**
 * ä½¿ç”¨çš„ {@link #clients} çš„ä½ç½®
 */
private final AtomicPositiveInteger index = new AtomicPositiveInteger();

  1: @Override
  2: protected Result doInvoke(final Invocation invocation) {
  3:     RpcInvocation inv = (RpcInvocation) invocation;
  4:     // è·å¾—æ–¹æ³•å
  5:     final String methodName = RpcUtils.getMethodName(invocation);
  6:     // è·å¾— `path`( æœåŠ¡å )ï¼Œ`version`
  7:     inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
  8:     inv.setAttachment(Constants.VERSION_KEY, version);
  9: 
 10:     // è·å¾— ExchangeClient å¯¹è±¡
 11:     ExchangeClient currentClient;
 12:     if (clients.length == 1) {
 13:         currentClient = clients[0];
 14:     } else {
 15:         currentClient = clients[index.getAndIncrement() % clients.length];
 16:     }
 17:     // è¿œç¨‹è°ƒç”¨
 18:     try {
 19:         // è·å¾—æ˜¯å¦å¼‚æ­¥è°ƒç”¨
 20:         boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);
 21:         // è·å¾—æ˜¯å¦å•å‘è°ƒç”¨
 22:         boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
 23:         // è·å¾—è¶…æ—¶æ—¶é—´
 24:         int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
 25:         // å•å‘è°ƒç”¨
 26:         if (isOneway) {
 27:             boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
 28:             currentClient.send(inv, isSent);
 29:             RpcContext.getContext().setFuture(null);
 30:             return new RpcResult();
 31:         // å¼‚æ­¥è°ƒç”¨
 32:         } else if (isAsync) {
 33:             ResponseFuture future = currentClient.request(inv, timeout);
 34:             RpcContext.getContext().setFuture(new FutureAdapter<Object>(future));
 35:             return new RpcResult();
 36:         // åŒæ­¥è°ƒç”¨
 37:         } else {
 38:             RpcContext.getContext().setFuture(null);
 39:             return (Result) currentClient.request(inv, timeout).get();
 40:         }
 41:     } catch (TimeoutException e) {
 42:         throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
 43:     } catch (RemotingException e) {
 44:         throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
 45:     }
 46: }
```

- ç¬¬ 5 è¡Œï¼šè°ƒç”¨ `RpcUtils#getMethodName()` æ–¹æ³•ï¼Œè·å¾—æ–¹æ³•åã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  public static String getMethodName(Invocation invocation) {
      // æ³›åŒ–è°ƒç”¨ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ–¹æ³•å
      if (Constants.$INVOKE.equals(invocation.getMethodName())
              && invocation.getArguments() != null
              && invocation.getArguments().length > 0
              && invocation.getArguments()[0] instanceof String) {
          return (String) invocation.getArguments()[0];
      }
      // æ™®é€šè°ƒç”¨ï¼Œç›´æ¥è·å¾—
      return invocation.getMethodName();
  }
  ```

- ç¬¬ 6 è‡³ 8 è¡Œï¼šè·å¾— `path`( æœåŠ¡å )ã€`version` ã€‚

- ç¬¬ 10 è‡³ 16 è¡Œï¼š**é¡ºåº**ï¼Œè·å¾— ExchangeClient å¯¹è±¡ã€‚

- ç¬¬ 20 è¡Œï¼šè°ƒç”¨ `RpcUtils#isAsync(url, invocation)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  public static boolean isAsync(URL url, Invocation inv) {
      return Boolean.TRUE.toString().equals(inv.getAttachment(Constants.ASYNC_KEY)) // RpcContext#asyncCall(Callable) æ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®
              || url.getMethodParameter(getMethodName(inv), Constants.ASYNC_KEY, false);
  }
  ```

  - è·å¾—æ˜¯å¦å¼‚æ­¥ã€‚æœåŠ¡å¼•ç”¨æˆ–æ–¹æ³•ï¼Œä»»ä¸€é…ç½® `async = true` ï¼Œå³ä¸ºå¼‚æ­¥ã€‚

- ç¬¬ 22 è¡Œï¼šè°ƒç”¨ `RpcUtils#isOneway(url, invocation)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  public static boolean isOneway(URL url, Invocation inv) {
      return Boolean.FALSE.toString().equals(inv.getAttachment(Constants.RETURN_KEY)) // RpcContext#asyncCall(Runnable) æ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®
              || !url.getMethodParameter(getMethodName(inv), Constants.RETURN_KEY, true);
  }
  ```

  - è·å¾—æ˜¯å¦å•å‘ã€‚æ–¹æ³•é…ç½® `return = true` ï¼Œå³ä¸ºå•å‘ã€‚

- ç¬¬ 24 è¡Œï¼šè°ƒç”¨ `URL#getMethodParameter(method, key, defaultValue)` æ–¹æ³•ï¼Œè·å¾—è¿œç¨‹è°ƒç”¨è¶…æ—¶æ—¶é—´ï¼Œå•ä½ï¼šæ¯«ç§’ã€‚

- ç¬¬ 25 è‡³ 30 è¡Œï¼šoneway å•å‘è°ƒç”¨ã€‚

  - ç¬¬ 28 è¡Œï¼š**æ³¨æ„**ï¼Œè°ƒç”¨çš„æ˜¯ `ExchangeClient#send(invocation, sent)` æ–¹æ³•ï¼Œå‘é€**æ¶ˆæ¯**ï¼Œè€Œä¸æ˜¯**è¯·æ±‚**ã€‚
  - ç¬¬ 29 è¡Œï¼šè®¾ç½® `RpcContext.future = null` ï¼Œæ— éœ€ FutureFilter ï¼Œå¼‚æ­¥å›è°ƒã€‚
  - ç¬¬ 30 è¡Œï¼šåˆ›å»º RpcResult å¯¹è±¡ï¼Œ**ç©ºè¿”å›**ã€‚

- ç¬¬ 31 è‡³ 35 è¡Œï¼šasync å¼‚æ­¥è°ƒç”¨ã€‚

  - ç¬¬ 33 è¡Œï¼šè°ƒç”¨ `ExchangeClient#request(invocation, timeout)` æ–¹æ³•ï¼Œå‘é€**è¯·æ±‚**ã€‚
  - ç¬¬ 34 è¡Œï¼šè°ƒç”¨ `RpcContext#setFuture(future)` æ–¹æ³•ï¼Œåœ¨ FutureFitler ä¸­ï¼Œå¼‚æ­¥å›è°ƒã€‚
  - ç¬¬ 35 è¡Œï¼šåˆ›å»º RpcResult å¯¹è±¡ï¼Œ**ç©ºè¿”å›**ã€‚

- ç¬¬ 36 è‡³ 40 è¡Œï¼šsync åŒæ­¥è°ƒç”¨ã€‚

  - ç¬¬ 38 è¡Œï¼šè®¾ç½® `RpcContext.future = null` ï¼Œæ— éœ€ FutureFilter ï¼Œå¼‚æ­¥å›è°ƒã€‚
  - ç¬¬ 39 è¡Œï¼šè°ƒç”¨ `ExchangeClient#request(invocation, timeout)` æ–¹æ³•ï¼Œå‘é€**è¯·æ±‚**ã€‚
  - ç¬¬ 39 è¡Œï¼šè°ƒç”¨ `ResponseFuture#get()` æ–¹æ³•ï¼Œ**é˜»å¡**ç­‰å¾…ï¼Œè¿”å›ç»“æœã€‚

## 4. æä¾›è€…æä¾›æœåŠ¡

åœ¨ DubboProtocol ç±»ä¸­ï¼Œå®ç°äº†è‡ªå·±çš„ ExchangeHandler å¯¹è±¡ï¼Œå¤„ç†è¯·æ±‚ã€æ¶ˆæ¯ã€è¿æ¥ã€æ–­å¼€è¿æ¥ç­‰äº‹ä»¶ã€‚å¯¹äºæœåŠ¡æ¶ˆè´¹è€…çš„è¿œç¨‹è°ƒç”¨ï¼Œé€šè¿‡ `#reply(ExchangeChannel channel, Object message)` å’Œ `#reply(Channel channel, Object message)` æ–¹æ³•æ¥å¤„ç†ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š[![ExchangeHandler](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_04.png)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_04.png)ExchangeHandler

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹æ¯ä¸ªæ–¹æ³•çš„å®ç°ä»£ç ã€‚

#### 4.1 reply

```
 1: @Override
 2: public Object reply(ExchangeChannel channel, Object message) throws RemotingException {
 3:     if (message instanceof Invocation) {
 4:         Invocation inv = (Invocation) message;
 5:         // è·å¾—è¯·æ±‚å¯¹åº”çš„ Invoker å¯¹è±¡
 6:         Invoker<?> invoker = getInvoker(channel, inv);
 7:         // å¦‚æœæ˜¯callback éœ€è¦å¤„ç†é«˜ç‰ˆæœ¬è°ƒç”¨ä½ç‰ˆæœ¬çš„é—®é¢˜
 8:         // need to consider backward-compatibility if it's a callback
 9:         if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
10:             String methodsStr = invoker.getUrl().getParameters().get("methods");
11:             boolean hasMethod = false;
12:             if (methodsStr == null || !methodsStr.contains(",")) {
13:                 hasMethod = inv.getMethodName().equals(methodsStr);
14:             } else {
15:                 String[] methods = methodsStr.split(",");
16:                 for (String method : methods) {
17:                     if (inv.getMethodName().equals(method)) {
18:                         hasMethod = true;
19:                         break;
20:                     }
21:                 }
22:             }
23:             if (!hasMethod) {
24:                 logger.warn(new IllegalStateException("The methodName " + inv.getMethodName() + " not found in callback service interface ,invoke will be ignored. please update the api interface. url is:" + invoker.getUrl()) + " ,invocation is :" + inv);
25:                 return null;
26:             }
27:         }
28:         // è®¾ç½®è°ƒç”¨æ–¹çš„åœ°å€
29:         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
30:         // æ‰§è¡Œè°ƒç”¨
31:         return invoker.invoke(inv);
32:     }
33:     throw new RemotingException(channel, message.getClass().getName() + ": " + message
34:             + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress());
35: }
```

- ç”¨äºå¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨çš„è¯·æ±‚ã€‚

- ç¬¬ 6 è¡Œï¼šè°ƒç”¨ `#getInvoker(channel, invocation)` æ–¹æ³•ï¼Œè·å¾—è¯·æ±‚å¯¹åº”çš„ Invoker å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  /**
   * Exporter é›†åˆ
   *
   * key: æœåŠ¡é”® {@link #serviceKey(URL)} æˆ– {@link URL#getServiceKey()} ã€‚
   *      ä¸åŒåè®®ä¼šä¸åŒ
   */
  protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM çˆ¶ç±» AbstractProtocol.java
  
    1: Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException {
    2:     boolean isCallBackServiceInvoke;
    3:     boolean isStubServiceInvoke;
    4:     int port = channel.getLocalAddress().getPort();
    5:     String path = inv.getAttachments().get(Constants.PATH_KEY);
    6:     // TODO ã€8033 å‚æ•°å›è°ƒã€‘
    7:     // if it's callback service on client side
    8:     isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));
    9:     if (isStubServiceInvoke) {
   10:         port = channel.getRemoteAddress().getPort();
   11:     }
   12:     // å¦‚æœæ˜¯å‚æ•°å›è°ƒï¼Œè·å¾—çœŸæ­£çš„æœåŠ¡å `path` ã€‚
   13:     // callback
   14:     isCallBackServiceInvoke = isClientSide(channel) && !isStubServiceInvoke;
   15:     if (isCallBackServiceInvoke) {
   16:         path = inv.getAttachments().get(Constants.PATH_KEY) + "." + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);
   17:         inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());
   18:     }
   19:     // è·å¾—æœåŠ¡å»º
   20:     String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));
   21:     // è·å¾— Exporter å¯¹è±¡
   22:     DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);
   23:     // è·å¾— Invoker å¯¹è±¡
   24:     if (exporter == null) {
   25:         throw new RemotingException(channel, "Not found exported service: " + serviceKey + " in " + exporterMap.keySet() + ", may be version or group mismatch " + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress() + ", message:" + inv);
   26:     }
   27:     return exporter.getInvoker();
   28: }
  ```

  - ç¬¬ 6 è‡³ 11 è¡Œï¼šTODO ã€8033 å‚æ•°å›è°ƒã€‘

  - ç¬¬ 12 è‡³ 18 è¡Œï¼šå¦‚æœæ˜¯å‚æ•°å›è°ƒï¼Œè·å¾—çœŸæ­£çš„æœåŠ¡å `path` ã€‚åœ¨**å‚æ•°å›è°ƒ**ä¸€æ–‡ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†è§£æã€‚

  - ç¬¬ 20 è¡Œï¼šè°ƒç”¨ `#serviceKey(port, path, version)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡é”®ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) {
        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);
    }
    ```

  - ç¬¬ 22 è¡Œï¼šä» `exporterMap` é›†åˆä¸­ï¼Œè·å¾— Exporter å¯¹è±¡ã€‚

  - ç¬¬ 23 è‡³ 27 è¡Œï¼šè·å¾— Invoker å¯¹è±¡ã€‚

- ç¬¬ 8 è‡³ 27 è¡Œï¼šå¦‚æœæ˜¯**å‚æ•°å›è°ƒ**ï¼Œæ ¡éªŒæœåŠ¡æ¶ˆè´¹è€…å®é™…å­˜åœ¨å¯¹åº”çš„å›è°ƒæ–¹æ³•ï¼Œé€šè¿‡æ–¹æ³•ååˆ¤æ–­ã€‚

- ç¬¬ 29 è¡Œï¼šè®¾ç½®è°ƒç”¨æ–¹çš„åœ°å€ã€‚

- ç¬¬ 31 è¡Œï¼šè°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼Œæ‰§è¡Œè°ƒç”¨ï¼Œå¹¶è¿”å›ç»“æœã€‚åç»­çš„é€»è¾‘ï¼Œå’Œ `injvm://` åè®®æ˜¯ä¸€è‡´çš„ã€‚

#### 4.2 received

```
@Override
public void received(Channel channel, Object message) throws RemotingException {
    if (message instanceof Invocation) {
        this.reply((ExchangeChannel) channel, message);
    } else {
        super.received(channel, message);
    }
}
```

- ç”¨äºå¤„ç†æœåŠ¡æ¶ˆè´¹è€…çš„**å•æ¬¡è°ƒç”¨**çš„æ¶ˆæ¯ï¼Œé€šè¿‡åˆ¤æ–­æ¶ˆæ¯ç±»å‹æ˜¯ä¸æ˜¯ Invocation ã€‚

#### 4.3 connected && disconnected

> æœ¬å°èŠ‚å’Œ Dubbo RPC æ— å…³ç³»ï¼Œåªæ˜¯ä¸ºäº†å®Œæ•´åˆ†äº« DubboProtocol ExchangeHandler çš„å®Œæ•´ä»£ç å®ç°ã€‚

åœ¨æœåŠ¡æä¾›è€…ä¸Šï¼Œæœ‰ `"onconnect"` å’Œ `"ondisconnect"` é…ç½®é¡¹ï¼Œåœ¨æœåŠ¡æä¾›è€…è¿æ¥æˆ–æ–­å¼€è¿æ¥æ—¶ï¼Œè°ƒç”¨ Service å¯¹åº”çš„æ–¹æ³•ã€‚ç›®å‰è¿™ä¸ªé…ç½®é¡¹ï¼Œåœ¨ Dubbo æ–‡æ¡£é‡Œï¼Œæš‚æœªæåŠã€‚å½“ç„¶ï¼Œè¿™ä¸ªåœ¨å®é™…åœºæ™¯ä¸‹ï¼ŒåŸºæœ¬æ²¡ç”¨è¿‡ã€‚

```
@Override
public void connected(Channel channel) {
    this.invoke(channel, Constants.ON_CONNECT_KEY);
}

@Override
public void disconnected(Channel channel) throws RemotingException {
    if (logger.isInfoEnabled()) {
        logger.info("disconected from " + channel.getRemoteAddress() + ",url:" + channel.getUrl());
    }
    this.invoke(channel, Constants.ON_DISCONNECT_KEY);
}
```

- è°ƒç”¨ `#invoke(channel, methodKey)` æ–¹æ³•ï¼Œæ‰§è¡Œå¯¹åº”çš„æ–¹æ³•ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  /**
   * è°ƒç”¨æ–¹æ³•
   *
   * @param channel é€šé“
   * @param methodKey æ–¹æ³•å
   */
  private void invoke(Channel channel, String methodKey) {
      // åˆ›å»º Invocation å¯¹è±¡
      Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
      // è°ƒç”¨ received æ–¹æ³•ï¼Œæ‰§è¡Œå¯¹åº”çš„æ–¹æ³•
      if (invocation != null) {
          try {
              this.received(channel, invocation);
          } catch (Throwable t) {
              logger.warn("Failed to invoke event method " + invocation.getMethodName() + "(), cause: " + t.getMessage(), t);
          }
      }
  }
  
  private Invocation createInvocation(Channel channel, URL url, String methodKey) {
      String method = url.getParameter(methodKey);
      if (method == null || method.length() == 0) {
          return null;
      }
      RpcInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
      invocation.setAttachment(Constants.PATH_KEY, url.getPath());
      invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));
      invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));
      invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));
      if (url.getParameter(Constants.STUB_EVENT_KEY, false)) {
          invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());
      }
      return invocation;
  }
  ```

# è¿œç¨‹è°ƒç”¨-3:å¼‚æ­¥è°ƒç”¨

## 1. æ¦‚è¿°

æœ¬æ–‡åˆ†äº« `dubbo://` åè®®çš„è¿œç¨‹è°ƒç”¨çš„**ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¼‚æ­¥è°ƒç”¨**ã€‚

å¯¹åº” [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” äº‹ä»¶é€šçŸ¥ã€‹](http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html) æ–‡æ¡£ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> åœ¨è°ƒç”¨ä¹‹å‰ã€è°ƒç”¨ä¹‹åã€å‡ºç°å¼‚å¸¸æ—¶ï¼Œä¼šè§¦å‘ `oninvoke`ã€`onreturn`ã€`onthrow` ä¸‰ä¸ªäº‹ä»¶ï¼Œå¯ä»¥é…ç½®å½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œé€šçŸ¥å“ªä¸ªç±»çš„å“ªä¸ªæ–¹æ³•ã€‚

çœ‹å®Œå®šä¹‰ï¼Œæ˜¯ä¸æ˜¯æœ‰ç‚¹ç–‘æƒ‘ï¼Œå’Œæœ¬æ–‡çš„æ ‡é¢˜ä»¿ä½›æœ‰äº›å‡ºå…¥ï¼Ÿç›¸ä¿¡è‡ªå·±ï¼Œä½ æ˜¯å¯¹çš„ï¼Œæ ‡é¢˜æ˜¯ä¸ä¸¥è°¨çš„ï¼Œâ€œé”™è¯¯â€ç‚¹å¦‚ä¸‹ï¼š

- `oninvoke` é…ç½®é¡¹ï¼Œè®¾ç½®æœåŠ¡æ¶ˆè´¹è€…**è°ƒç”¨**æœåŠ¡æä¾›è€…**ä¹‹å‰**ï¼Œæ‰§è¡Œå‰ç½®æ–¹æ³•ï¼Œç±»ä¼¼ AOP çš„ `#beforeMethod(...)` æ–¹æ³•ã€‚
- `onreturn` å’Œ `onthrow` é…ç½®é¡¹ï¼Œè®¾ç½®æœåŠ¡æ¶ˆè´¹è€…**è°ƒç”¨**æœåŠ¡æä¾›è€…**ä¹‹å**ï¼Œæ‰§è¡Œåç½®æ–¹æ³•ï¼Œç±»ä¼¼ AOP çš„ `#afterMethod(...)` æ–¹æ³•ã€‚æœ‰ä¸€ç‚¹æˆ‘ä»¬éœ€è¦æ³¨æ„ï¼Œä¸€å¼€å§‹ç¬”è€…ç†è§£é”™äº†ï¼Œå¹¶éåªæœ‰ `async = true` ï¼Œå¼‚æ­¥è°ƒç”¨æ‰æ”¯æŒå›è°ƒï¼ŒåŒæ­¥è°ƒç”¨å’Œå•å‘è°ƒç”¨ä¹Ÿæ”¯æŒå›è°ƒã€‚

å…·ä½“çš„è°ƒç”¨ï¼Œåœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡è°ƒç”¨ï¼ˆäºŒï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆDubboï¼‰ã€2ã€‘åŒæ­¥è°ƒç”¨ã€‹ã€Œ3. æ¶ˆè´¹è€…è°ƒç”¨æœåŠ¡ã€](http://svip.iocoder.cn/Dubbo/rpc-dubbo-2-sync/?self) ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°è°ƒç”¨çš„ä»£ç ã€‚å¦‚æœèƒ–å‹æ²¡çœ‹è¿‡ï¼Œå»ºè®®å…ˆå»çœ‹çœ‹ã€‚

## 2. FutureAdapter

[`com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter`](http://svip.iocoder.cn/Dubbo/rpc-dubbo-3-async/todo) ï¼Œå®ç° Future æ¥å£ï¼Œé€‚é… ResponseFuture ã€‚é€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œå¯¹ä¸Šå±‚è°ƒç”¨æ–¹ï¼Œ**é€æ˜**åŒ– ResponseFuture çš„å­˜åœ¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class FutureAdapter<V> implements Future<V> {

    private final ResponseFuture future;

    public FutureAdapter(ResponseFuture future) {
        this.future = future;
    }

    public ResponseFuture getFuture() {
        return future;
    }

    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return future.isDone();
    }

    @Override
    @SuppressWarnings("unchecked")
    public V get() throws InterruptedException, ExecutionException {
        try {
            return (V) (((Result) future.get()).recreate());
        } catch (RemotingException e) {
            throw new ExecutionException(e.getMessage(), e);
        } catch (Throwable e) {
            throw new RpcException(e);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        int timeoutInMillis = (int) unit.convert(timeout, TimeUnit.MILLISECONDS);
        try {
            return (V) (((Result) future.get(timeoutInMillis)).recreate());
        } catch (com.alibaba.dubbo.remoting.TimeoutException e) {
            throw new TimeoutException(StringUtils.toString(e));
        } catch (RemotingException e) {
            throw new ExecutionException(e.getMessage(), e);
        } catch (Throwable e) {
            throw new RpcException(e);
        }
    }

}
```

## 3. FutureFilter

[`com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java) ï¼Œå®ç° Filter æ¥å£ï¼Œäº‹ä»¶é€šçŸ¥è¿‡æ»¤å™¨ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Activate(group = Constants.CONSUMER)
 2: public class FutureFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(final Invoker<?> invoker, final Invocation invocation) throws RpcException {
 6:         // è·å¾—æ˜¯å¦å¼‚æ­¥è°ƒç”¨
 7:         final boolean isAsync = RpcUtils.isAsync(invoker.getUrl(), invocation);
 8: 
 9:         // è§¦å‘å‰ç½®æ–¹æ³•
10:         fireInvokeCallback(invoker, invocation);
11:         // need to configure if there's return value before the invocation in order to help invoker to judge if it's
12:         // necessary to return future.
13:         // è°ƒç”¨æ–¹æ³•
14:         Result result = invoker.invoke(invocation);
15: 
16:         // è§¦å‘å›è°ƒæ–¹æ³•
17:         if (isAsync) { // å¼‚æ­¥å›è°ƒ
18:             asyncCallback(invoker, invocation);
19:         } else { // åŒæ­¥å›è°ƒ
20:             syncCallback(invoker, invocation, result);
21:         }
22:         return result;
23:     }
24:     
25:     // ... çœç•¥éƒ¨åˆ†æ–¹æ³•
26: }
```

- `@Activate(group = Constants.CONSUMER)` æ³¨è§£ï¼ŒåŸºäº Dubbo SPI Activate æœºåˆ¶ï¼Œåªæœ‰**æœåŠ¡æ¶ˆè´¹è€…**æ‰ç”Ÿæ•ˆè¯¥è¿‡æ»¤å™¨ã€‚
- ç¬¬ 7 è¡Œï¼šè°ƒç”¨ `RpcUtils#isAsync(url, invocation)` æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨ã€‚
- ç¬¬ 10 è¡Œï¼šè°ƒç”¨ `#fireInvokeCallback(invoker, invocation)` æ–¹æ³•ï¼Œè§¦å‘å‰ç½®æ–¹æ³•ã€‚
- ç¬¬ 14 è¡Œï¼šè°ƒç”¨ `invoker#invoke(invocation)` æ–¹æ³•ï¼Œè°ƒç”¨**æœåŠ¡æä¾›è€…**ï¼Œå³ Dubbo RPC ã€‚
- ç¬¬ 16 è‡³ 21 è¡Œï¼šè§¦å‘å›è°ƒæ–¹æ³•ã€‚
  - ç¬¬ 17 è‡³ 18 è¡Œï¼šè‹¥**æ˜¯**å¼‚æ­¥è°ƒç”¨ï¼Œè°ƒç”¨ `#asyncCallback(invoker, invocation)` æ–¹æ³•ï¼Œæ‰§è¡Œå¼‚æ­¥å›è°ƒã€‚
  - ç¬¬ 19 è‡³ 21 è¡Œï¼šè‹¥**é**å¼‚æ­¥è°ƒç”¨ï¼Œè°ƒç”¨ `#syncCallback(invoker, invocation)` æ–¹æ³•ï¼Œæ‰§è¡ŒåŒæ­¥å›è°ƒã€‚
- ç¬¬ 22 è¡Œï¼šè¿”å›ç»“æœã€‚å¦‚æœæ˜¯å¼‚æ­¥è°ƒç”¨æˆ–å•å‘è°ƒç”¨ï¼Œæ‰€ä»¥è¿”å›ç»“æœæ˜¯**ç©º**çš„ã€‚

#### 3.1 fireInvokeCallback

```
 1: /**
 2:  * è§¦å‘å‰ç½®æ–¹æ³•
 3:  *
 4:  * @param invoker Invoker å¯¹è±¡
 5:  * @param invocation Invocation å¯¹è±¡
 6:  */
 7: private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invocation) {
 8:     // è·å¾—å‰ç½®æ–¹æ³•å’Œå¯¹è±¡
 9:     final Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY));
10:     final Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY));
11:     if (onInvokeMethod == null && onInvokeInst == null) {
12:         return;
13:     }
14:     if (onInvokeMethod == null || onInvokeInst == null) {
15:         throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onreturn callback config , but no such " + (onInvokeMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
16:     }
17:     if (!onInvokeMethod.isAccessible()) {
18:         onInvokeMethod.setAccessible(true);
19:     }
20: 
21:     // è°ƒç”¨å‰ç½®æ–¹æ³•
22:     Object[] params = invocation.getArguments();
23:     try {
24:         onInvokeMethod.invoke(onInvokeInst, params);
25:     } catch (InvocationTargetException e) {
26:         fireThrowCallback(invoker, invocation, e.getTargetException());
27:     } catch (Throwable e) {
28:         fireThrowCallback(invoker, invocation, e);
29:     }
30: }
```

- ç¬¬ 8 è‡³ 19 è¡Œï¼šè·å¾—å‰ç½®æ–¹æ³•å’Œå¯¹è±¡ã€‚StaticContext åœ¨ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” API é…ç½®ï¼ˆä¸‰ï¼‰ä¹‹æœåŠ¡æ¶ˆè´¹è€…ã€‹](http://svip.iocoder.cn/Dubbo/configuration-api-3/?self) ä¸­ï¼Œå·²ç»è¯¦ç»†è§£æã€‚
- ç¬¬ 21 è‡³ 29 è¡Œï¼š**åå°„**è°ƒç”¨å‰ç½®æ–¹æ³•ã€‚

#### 3.2 syncCallback

```
/**
 * åŒæ­¥å›è°ƒ
 *
 * @param invoker Invoker å¯¹è±¡
 * @param invocation Invocation å¯¹è±¡
 * @param result RPC ç»“æœ
 */
private void syncCallback(final Invoker<?> invoker, final Invocation invocation, final Result result) {
    if (result.hasException()) { // å¼‚å¸¸ï¼Œè§¦å‘å¼‚å¸¸å›è°ƒ
        fireThrowCallback(invoker, invocation, result.getException());
    } else { // æ­£å¸¸ï¼Œè§¦å‘æ­£å¸¸å›è°ƒ
        fireReturnCallback(invoker, invocation, result.getValue());
    }
}
```

- `#fireThrowCallback(invoker, invocation, exception)` æ–¹æ³•ï¼Œè§¦å‘å¼‚å¸¸å›è°ƒæ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  private void fireReturnCallback(final Invoker<?> invoker, final Invocation invocation, final Object result) {
      // è·å¾— `onreturn` æ–¹æ³•å’Œå¯¹è±¡
      final Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY));
      final Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY));
      //not set onreturn callback
      if (onReturnMethod == null && onReturnInst == null) {
          return;
      }
      if (onReturnMethod == null || onReturnInst == null) {
          throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onreturn callback config , but no such " + (onReturnMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
      }
      if (!onReturnMethod.isAccessible()) {
          onReturnMethod.setAccessible(true);
      }
  
      // å‚æ•°æ•°ç»„
      Object[] args = invocation.getArguments();
      Object[] params;
      Class<?>[] rParaTypes = onReturnMethod.getParameterTypes();
      if (rParaTypes.length > 1) {
          if (rParaTypes.length == 2 && rParaTypes[1].isAssignableFrom(Object[].class)) {
              params = new Object[2];
              params[0] = result;
              params[1] = args;
          } else {
              params = new Object[args.length + 1];
              params[0] = result;
              System.arraycopy(args, 0, params, 1, args.length);
          }
      } else {
          params = new Object[]{result};
      }
  
      // è°ƒç”¨æ–¹æ³•
      try {
          onReturnMethod.invoke(onReturnInst, params);
      } catch (InvocationTargetException e) {
          fireThrowCallback(invoker, invocation, e.getTargetException());
      } catch (Throwable e) {
          fireThrowCallback(invoker, invocation, e);
      }
  }
  ```

- `#fireReturnCallback(invoker, invocation, result)` æ–¹æ³•ï¼Œè§¦å‘æ­£å¸¸å›è°ƒæ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  private void fireThrowCallback(final Invoker<?> invoker, final Invocation invocation, final Throwable exception) {
      // è·å¾— `onthrow` æ–¹æ³•å’Œå¯¹è±¡
      final Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY));
      final Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY));
      // onthrow callback not configured
      if (onthrowMethod == null && onthrowInst == null) {
          return;
      }
      if (onthrowMethod == null || onthrowInst == null) {
          throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onthrow callback config , but no such " + (onthrowMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
      }
      if (!onthrowMethod.isAccessible()) {
          onthrowMethod.setAccessible(true);
      }
  
      Class<?>[] rParaTypes = onthrowMethod.getParameterTypes();
      if (rParaTypes[0].isAssignableFrom(exception.getClass())) { // ç¬¦åˆå¼‚å¸¸
          try {
              // å‚æ•°æ•°ç»„
              Object[] args = invocation.getArguments();
              Object[] params;
              if (rParaTypes.length > 1) {
                  if (rParaTypes.length == 2 && rParaTypes[1].isAssignableFrom(Object[].class)) {
                      params = new Object[2];
                      params[0] = exception;
                      params[1] = args;
                  } else {
                      params = new Object[args.length + 1];
                      params[0] = exception;
                      System.arraycopy(args, 0, params, 1, args.length);
                  }
              } else {
                  params = new Object[]{exception};
              }
  
              // è°ƒç”¨æ–¹æ³•
              onthrowMethod.invoke(onthrowInst, params);
          } catch (Throwable e) {
              logger.error(invocation.getMethodName() + ".call back method invoke error . callback method :" + onthrowMethod + ", url:" + invoker.getUrl(), e);
          }
      } else { // ä¸ç¬¦åˆå¼‚å¸¸ï¼Œæ‰“å°é”™è¯¯æ—¥å¿—
          logger.error(invocation.getMethodName() + ".call back method invoke error . callback method :" + onthrowMethod + ", url:" + invoker.getUrl(), exception);
      }
  }
  ```

#### 3.3 asyncCallback

```
/**
 * å¼‚æ­¥å›è°ƒ
 *
 * @param invoker Invoker å¯¹è±¡
 * @param invocation Invocation å¯¹è±¡
 */
private void asyncCallback(final Invoker<?> invoker, final Invocation invocation) {
    // è·å¾— Future å¯¹è±¡
    Future<?> f = RpcContext.getContext().getFuture();
    if (f instanceof FutureAdapter) {
        ResponseFuture future = ((FutureAdapter<?>) f).getFuture();
        // è§¦å‘å›è°ƒ
        future.setCallback(new ResponseCallback() {

            /**
             * è§¦å‘æ­£å¸¸å›è°ƒæ–¹æ³•
             *
             * @param rpcResult RPC ç»“æœ
             */
            public void done(Object rpcResult) {
                if (rpcResult == null) {
                    logger.error(new IllegalStateException("invalid result value : null, expected " + Result.class.getName()));
                    return;
                }
                // must be rpcResult
                if (!(rpcResult instanceof Result)) {
                    logger.error(new IllegalStateException("invalid result type :" + rpcResult.getClass() + ", expected " + Result.class.getName()));
                    return;
                }
                Result result = (Result) rpcResult;
                if (result.hasException()) { // è§¦å‘æ­£å¸¸å›è°ƒæ–¹æ³•
                    fireThrowCallback(invoker, invocation, result.getException());
                } else { // è§¦å‘å¼‚å¸¸å›è°ƒæ–¹æ³•
                    fireReturnCallback(invoker, invocation, result.getValue());
                }
            }

            /**
             * è§¦å‘å¼‚å¸¸å›è°ƒæ–¹æ³•
             *
             * @param exception å¼‚å¸¸
             */
            public void caught(Throwable exception) {
                fireThrowCallback(invoker, invocation, exception);
            }
        });
    }
}
```

# è¿œç¨‹è°ƒç”¨-HTTP

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `http://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

- æœåŠ¡æš´éœ²
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-http` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” http://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/http.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> åŸºäº HTTP è¡¨å•çš„è¿œç¨‹è°ƒç”¨åè®®ï¼Œé‡‡ç”¨ Spring çš„ **HttpInvoker** å®ç°

**æ³¨æ„**ï¼Œä»å®šä¹‰ä¸Šæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œä¸æ˜¯æˆ‘ä»¬å¸¸è§„ç†è§£çš„ HTTP è°ƒç”¨ï¼Œè€Œæ˜¯ **Spring çš„ HttpInvoker** ã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾ï¼ˆçº¢åœˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š

[![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_10/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_10/01.png)ç±»å›¾

## 2. AbstractProxyProtocol

[`com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractProxyProtocol.java) ï¼Œå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼Œ**Proxy** åè®®æŠ½è±¡ç±»ã€‚ä¸º HttpProtocol ã€RestProtocol ç­‰å­ç±»ï¼Œæä¾›å…¬ç”¨çš„æœåŠ¡æš´éœ²ã€æœåŠ¡å¼•ç”¨çš„**å…¬ç”¨æ–¹æ³•**ï¼ŒåŒæ—¶å®šä¹‰äº†å¦‚ä¸‹**æŠ½è±¡æ–¹æ³•**ï¼Œç”¨äºä¸åŒå­ç±»åè®®å®ç°ç±»çš„**è‡ªå®šä¹‰**çš„é€»è¾‘ï¼š

```
/**
 * æ‰§è¡Œæš´éœ²ï¼Œå¹¶è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
 *
 * @param impl æœåŠ¡ Proxy å¯¹è±¡
 * @param type æœåŠ¡æ¥å£
 * @param url URL
 * @param <T> æœåŠ¡æ¥å£
 * @return æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
 * @throws RpcException å½“å‘ç”Ÿå¼‚å¸¸
 */
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;

/**
 * æ‰§è¡Œå¼•ç”¨ï¼Œå¹¶è¿”å›è°ƒç”¨è¿œç¨‹æœåŠ¡çš„ Service å¯¹è±¡
 *
 * @param type æœåŠ¡æ¥å£
 * @param url URL
 * @param <T> æœåŠ¡æ¥å£
 * @return è°ƒç”¨è¿œç¨‹æœåŠ¡çš„ Service å¯¹è±¡
 * @throws RpcException å½“å‘ç”Ÿå¼‚å¸¸
 */
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
```

#### 2.1 æ„é€ æ–¹æ³•

```
/**
 * éœ€è¦æŠ›å‡ºçš„å¼‚å¸¸ç±»é›†åˆï¼Œè¯¦è§ {@link #reder(Class, URL)} æ–¹æ³•ã€‚
 */
private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();
/**
 * ProxyFactory å¯¹è±¡
 */
private ProxyFactory proxyFactory;

public AbstractProxyProtocol() {
}

public AbstractProxyProtocol(Class<?>... exceptions) {
    for (Class<?> exception : exceptions) {
        addRpcException(exception);
    }
}

public void addRpcException(Class<?> exception) {
    this.rpcExceptions.add(exception);
}
```

- `rpcExceptions` å±æ€§ï¼Œä¸åŒåè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¼šæŠ›å‡ºçš„å¼‚å¸¸æ˜¯ä¸åŒçš„ã€‚åœ¨ `#refer(Class, URL)` æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å¯¹è¿™ä¸ªå±æ€§çš„ä½¿ç”¨ï¼Œç†è§£ä¼šæ›´æ¸…æ™°ä¸€äº›ã€‚

#### 2.2 export

```
/**
 * Exporter é›†åˆ
 *
 * key: æœåŠ¡é”® {@link #serviceKey(URL)} æˆ– {@link URL#getServiceKey()} ã€‚
 *      ä¸åŒåè®®ä¼šä¸åŒ
 */
protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM AbstractProtocol.java

  1: @Override
  2: @SuppressWarnings("unchecked")
  3: public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
  4:     // è·å¾—æœåŠ¡é”®
  5:     final String uri = serviceKey(invoker.getUrl());
  6:     // è·å¾— Exporter å¯¹è±¡ã€‚è‹¥å·²ç»æš´éœ²ï¼Œç›´æ¥è¿”å›ã€‚
  7:     Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
  8:     if (exporter != null) {
  9:         return exporter;
 10:     }
 11:     // æ‰§è¡Œæš´éœ²æœåŠ¡
 12:     final Runnable runnable = doExport(proxyFactory.getProxy(invoker), invoker.getInterface(), invoker.getUrl());
 13:     // åˆ›å»º Exporter å¯¹è±¡
 14:     exporter = new AbstractExporter<T>(invoker) {
 15: 
 16:         @Override
 17:         public void unexport() {
 18:             // å–æ¶ˆæš´éœ²
 19:             super.unexport();
 20:             exporterMap.remove(uri);
 21:             // æ‰§è¡Œå–æ¶ˆæš´éœ²çš„å›è°ƒ
 22:             if (runnable != null) {
 23:                 try {
 24:                     runnable.run();
 25:                 } catch (Throwable t) {
 26:                     logger.warn(t.getMessage(), t);
 27:                 }
 28:             }
 29:         }
 30: 
 31:     };
 32:     // æ·»åŠ åˆ° Exporter é›†åˆ
 33:     exporterMap.put(uri, exporter);
 34:     return exporter;
 35: }
```

- ç¬¬ 5 è¡Œï¼šè°ƒç”¨ `#serviceKey(url)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡é”®ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected static String serviceKey(URL url) {
      return ProtocolUtils.serviceKey(url);
  }
  ```

- ç¬¬ 6 è‡³ 10 è¡Œï¼šä» `exporterMap` ä¸­ï¼Œè·å¾— Exporter å¯¹è±¡ã€‚è‹¥å·²ç»æš´éœ²ï¼Œç›´æ¥è¿”å›ã€‚

- ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `ProxyFactory#getProxy(invoker)` æ–¹æ³•ï¼Œè·å¾— Service Proxy å¯¹è±¡ã€‚

- ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `#doExport(impl, type, url)` **æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œ**å­ç±»å®ç°**çš„æš´éœ²æœåŠ¡ã€‚

- ç¬¬ 14 è‡³ 31 è¡Œï¼šåˆ›å»º Exporter å¯¹è±¡ã€‚åŸºäº AbstractExporter æŠ½è±¡ç±»å®ç°ï¼Œè¦†å†™

   

  ```
  #unexport()
  ```

   

  æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  - ç¬¬ 18 è‡³ 20 è¡Œï¼šå–æ¶ˆæš´éœ²ã€‚
  - ç¬¬ 22 è‡³ 28 è¡Œï¼šè°ƒç”¨ `Runnable#run()` æ–¹æ³•ï¼Œæ‰§è¡Œå–æ¶ˆæš´éœ²çš„å›è°ƒæ–¹æ³•ã€‚

- ç¬¬ 33 è¡Œï¼šæ·»åŠ åˆ° Exporter é›†åˆã€‚

#### 2.3 refer

```
/**
 * Invoker é›†åˆ
 */
//TODO SOFEREFENCE
protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>(); // FROM AbstractProtocol.java

  1: @Override
  2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
  3:     // æ‰§è¡Œå¼•ç”¨æœåŠ¡
  4:     final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);
  5:     // åˆ›å»º Invoker å¯¹è±¡
  6:     Invoker<T> invoker = new AbstractInvoker<T>(type, url) {
  7: 
  8:         @Override
  9:         protected Result doInvoke(Invocation invocation) throws Throwable {
 10:             try {
 11:                 // è°ƒç”¨
 12:                 Result result = target.invoke(invocation);
 13:                 // è‹¥è¿”å›ç»“æœå¸¦æœ‰å¼‚å¸¸ï¼Œå¹¶ä¸”éœ€è¦æŠ›å‡ºï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
 14:                 Throwable e = result.getException();
 15:                 if (e != null) {
 16:                     for (Class<?> rpcException : rpcExceptions) {
 17:                         if (rpcException.isAssignableFrom(e.getClass())) {
 18:                             throw getRpcException(type, url, invocation, e);
 19:                         }
 20:                     }
 21:                 }
 22:                 return result;
 23:             } catch (RpcException e) {
 24:                 // è‹¥æ˜¯æœªçŸ¥å¼‚å¸¸ï¼Œè·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç 
 25:                 if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {
 26:                     e.setCode(getErrorCode(e.getCause()));
 27:                 }
 28:                 throw e;
 29:             } catch (Throwable e) {
 30:                 // æŠ›å‡º RpcException å¼‚å¸¸
 31:                 throw getRpcException(type, url, invocation, e);
 32:             }
 33:         }
 34: 
 35:     };
 36:     // æ·»åŠ åˆ° Invoker é›†åˆã€‚
 37:     invokers.add(invoker);
 38:     return invoker;
 39: }
```

- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#doRefer(type, url)` **æŠ½è±¡**æ–¹æ³•ï¼Œæ‰§è¡Œ**å­ç±»å®ç°**çš„å¼•ç”¨æœåŠ¡ã€‚

- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `ProxyFactory#getInvoker(proxy, type, url)` æ–¹æ³•ï¼Œè·å¾— Invoker å¯¹è±¡ã€‚

- ç¬¬ 6 è‡³ 35 è¡Œï¼šåˆ›å»º Invoker å¯¹è±¡ã€‚åŸºäº AbstractExporter æŠ½è±¡ç±»å®ç°ï¼Œè¦†å†™ `#doInvoke(invocation)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  - ç¬¬ 12 è¡Œï¼šè°ƒç”¨ `Invoker#invoke(invocation)` æ–¹æ³•ï¼Œæ‰§è¡Œ RPC è°ƒç”¨ã€‚

  - ç¬¬ 13 è‡³ 21 è¡Œï¼šè‹¥è¿”å›ç»“æœå¸¦æœ‰å¼‚å¸¸ï¼Œå¹¶ä¸”éœ€è¦æŠ›å‡º( å¼‚å¸¸åœ¨ `rpcExceptions` ä¸­)ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚

  - ç¬¬ 22 è¡Œï¼šè¿”å›è°ƒç”¨ç»“æœã€‚

  - ç¬¬ 23 è‡³ 28 è¡Œï¼šè‹¥æ•æ‰åˆ° RpcException å¼‚å¸¸ï¼Œè°ƒç”¨ `#getErrorCode(Throwable)` æ–¹æ³•ï¼Œè·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    /**
     * è·å¾—å¼‚å¸¸å¯¹åº”çš„é”™è¯¯ç 
     *
     * @param e å¼‚å¸¸
     * @return é”™è¯¯ç 
     */
    protected int getErrorCode(Throwable e) {
        return RpcException.UNKNOWN_EXCEPTION;
    }
    ```

    - å­ç±»åè®®å®ç°ç±»ï¼Œä¸€èˆ¬ä¼šè¦†å†™è¿™ä¸ªæ–¹æ³•ï¼Œå®ç°è‡ªå·±å¼‚å¸¸çš„ç¿»è¯‘ã€‚

  - ç¬¬ 29 è‡³ 32 è¡Œï¼šè‹¥æ•æ‰åˆ° Throwable å¼‚å¸¸ï¼Œè°ƒç”¨ `#getRpcException(type, url, invocation, e)` æ–¹æ³•ï¼ŒåŒ…è£…æˆ RpcException å¼‚å¸¸ï¼Œä»£ç å¦‚ä¸‹ï¼š

    ```
    protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e) {
        RpcException re = new RpcException("Failed to invoke remote service: " + type + ", method: "
                + invocation.getMethodName() + ", cause: " + e.getMessage(), e);
        re.setCode(getErrorCode(e));
        return re;
    }
    ```

- ç¬¬ 37 è¡Œï¼šæ·»åŠ åˆ° Invoker é›†åˆã€‚

## 3. HttpProtocol

[`com.alibaba.dubbo.rpc.protocol.http.HttpProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-http/src/main/java/com/alibaba/dubbo/rpc/protocol/http/HttpProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ`dubbo://` åè®®å®ç°ç±»ã€‚

#### 3.1 æ„é€ æ–¹æ³•

```
/**
 * é»˜è®¤æœåŠ¡å™¨ç«¯å£
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http æœåŠ¡å™¨é›†åˆ
 *
 * keyï¼šip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter é›†åˆ
 *
 * keyï¼špath æœåŠ¡å
 */
private final Map<String, HttpInvokerServiceExporter> skeletonMap = new ConcurrentHashMap<String, HttpInvokerServiceExporter>();
/**
 * HttpBinder$Adaptive å¯¹è±¡
 */
private HttpBinder httpBinder;

public HttpProtocol() {
    super(RemoteAccessException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` å±æ€§ï¼ŒHttpServer é›†åˆã€‚é”®ä¸º `ip:port` ï¼Œé€šè¿‡ `#getAddr(url)` æ–¹æ³•ï¼Œè®¡ç®—ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` å±æ€§ï¼ŒSpring HttpInvokerServiceExporter é›†åˆã€‚è¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸º `HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter` ã€‚

- `httpBinder` å±æ€§ï¼ŒHttpBinder$Adaptive å¯¹è±¡ï¼Œé€šè¿‡ `#setHttpBinder(httpBinder)` æ–¹æ³•ï¼ŒDubbo SPI è°ƒç”¨è®¾ç½®ã€‚

- `rpcExceptions = RemoteAccessException.class` ã€‚

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {
 3:     // è·å¾—æœåŠ¡å™¨åœ°å€
 4:     String addr = getAddr(url);
 5:     // è·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»ºã€‚
 6:     HttpServer server = serverMap.get(addr);
 7:     if (server == null) {
 8:         server = httpBinder.bind(url, new InternalHandler()); // InternalHandler
 9:         serverMap.put(addr, server);
10:     }
11:     // åˆ›å»º HttpInvokerServiceExporter å¯¹è±¡
12:     final HttpInvokerServiceExporter httpServiceExporter = new HttpInvokerServiceExporter();
13:     httpServiceExporter.setServiceInterface(type);
14:     httpServiceExporter.setService(impl);
15:     try {
16:         httpServiceExporter.afterPropertiesSet();
17:     } catch (Exception e) {
18:         throw new RpcException(e.getMessage(), e);
19:     }
20:     // æ·»åŠ åˆ° skeletonMap ä¸­
21:     final String path = url.getAbsolutePath();
22:     skeletonMap.put(path, httpServiceExporter);
23:     // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
24:     return new Runnable() {
25:         public void run() {
26:             skeletonMap.remove(path);
27:         }
28:     };
29: }
```

- åŸºäº `dubbo-remoting-http` é¡¹ç›®ï¼Œä½œä¸º**é€šä¿¡æœåŠ¡å™¨**ã€‚
- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#getAddr(url)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡å™¨åœ°å€ã€‚
- ç¬¬ 5 è‡³ 10 è¡Œï¼šä» `serverMap` ä¸­ï¼Œè·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè°ƒç”¨ `HttpBinder#bind(url, handler)` æ–¹æ³•ï¼Œåˆ›å»º HttpServer å¯¹è±¡ã€‚æ­¤å¤„ä½¿ç”¨çš„ InternalHandler ï¼Œä¸‹æ–‡è¯¦ç»†è§£æã€‚
- ç¬¬ 11 è‡³ 19 è¡Œï¼šåˆ›å»º HttpInvokerServiceExporter å¯¹è±¡ã€‚
- ç¬¬ 20 è‡³ 22 è¡Œï¼šæ·»åŠ åˆ° `skeletonMap` é›†åˆä¸­ã€‚
- ç¬¬ 23 è‡³ 28 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable å¯¹è±¡ã€‚

###### 3.2.1 InternalHandler

```
private class InternalHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        String uri = request.getRequestURI();
        // è·å¾— HttpInvokerServiceExporter å¯¹è±¡
        HttpInvokerServiceExporter skeleton = skeletonMap.get(uri);
        // å¿…é¡»æ˜¯ POST è¯·æ±‚
        if (!request.getMethod().equalsIgnoreCase("POST")) {
            response.setStatus(500);
        // æ‰§è¡Œè°ƒç”¨
        } else {
            RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
            try {
                skeleton.handleRequest(request, response);
            } catch (Throwable e) {
                throw new ServletException(e);
            }
        }
    }

}
```

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // åˆ›å»º HttpInvokerProxyFactoryBean å¯¹è±¡
 5:     final HttpInvokerProxyFactoryBean httpProxyFactoryBean = new HttpInvokerProxyFactoryBean();
 6:     httpProxyFactoryBean.setServiceUrl(url.toIdentityString());
 7:     httpProxyFactoryBean.setServiceInterface(serviceType);
 8:     // åˆ›å»ºæ‰§è¡Œå™¨ SimpleHttpInvokerRequestExecutor å¯¹è±¡
 9:     String client = url.getParameter(Constants.CLIENT_KEY);
10:     if (client == null || client.length() == 0 || "simple".equals(client)) {
11:         SimpleHttpInvokerRequestExecutor httpInvokerRequestExecutor = new SimpleHttpInvokerRequestExecutor() {
12:             protected void prepareConnection(HttpURLConnection con,
13:                                              int contentLength) throws IOException {
14:                 super.prepareConnection(con, contentLength);
15:                 con.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
16:                 con.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
17:             }
18:         };
19:         httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
20:     // åˆ›å»ºæ‰§è¡Œå™¨ HttpComponentsHttpInvokerRequestExecutor å¯¹è±¡
21:     } else if ("commons".equals(client)) {
22:         HttpComponentsHttpInvokerRequestExecutor httpInvokerRequestExecutor = new HttpComponentsHttpInvokerRequestExecutor();
23:         httpInvokerRequestExecutor.setReadTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
24:         httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
25:     } else {
26:         throw new IllegalStateException("Unsupported http protocol client " + client + ", only supported: simple, commons");
27:     }
28:     httpProxyFactoryBean.afterPropertiesSet();
29:     // è¿”å› HttpInvokerProxyFactoryBean å¯¹è±¡
30:     return (T) httpProxyFactoryBean.getObject();
31: }
```

- åŸºäº HttpClient ï¼Œä½œä¸º**é€šä¿¡å®¢æˆ·ç«¯**ã€‚

- ç¬¬ 4 è‡³ 7 è¡Œï¼šåˆ›å»º HttpInvokerProxyFactoryBean å¯¹è±¡ã€‚

- ç¬¬ 9 è‡³ 27 è¡Œï¼šè·å¾—

   

  ```
  client
  ```

   

  é…ç½®é¡¹ï¼Œæ ¹æ®è¯¥é…ç½®é¡¹ï¼Œåˆ›å»ºå¯¹åº”çš„æ‰§è¡Œå™¨ã€‚

  - `"simple"`ï¼šç¬¬ 10 è‡³ 19 è¡Œï¼šåˆ›å»ºæ‰§è¡Œå™¨ SimpleHttpInvokerRequestExecutor å¯¹è±¡ã€‚
  - `"commons"`ï¼šç¬¬ 20 è‡³ 24 è¡Œï¼šåˆ›å»ºæ‰§è¡Œå™¨ HttpComponentsHttpInvokerRequestExecutor å¯¹è±¡ã€‚
  - ä¸¤è€…çš„å·®å¼‚ç‚¹åœ¨äºä½¿ç”¨çš„ HttpClient ä¸åŒï¼Œå‰è€…ä½¿ç”¨ JDK HttpClient ï¼Œåè€…ä½¿ç”¨ Apache HttpClient ã€‚

- ç¬¬ 30 è¡Œï¼šè¿”å› HttpInvokerProxyFactoryBean å¯¹è±¡ã€‚

- ğŸ™‚ å…·ä½“ RPC è°ƒç”¨çš„å®ç°ï¼Œåœ¨çˆ¶ç±» `#refer()` æ–¹æ³•é‡Œã€‚

###### 3.3.1 getErrorCode

```
@Override
@SuppressWarnings("Duplicates")
protected int getErrorCode(Throwable e) {
    if (e instanceof RemoteAccessException) {
        e = e.getCause();
    }
    if (e != null) {
        Class<?> cls = e.getClass();
        if (SocketTimeoutException.class.equals(cls)) {
            return RpcException.TIMEOUT_EXCEPTION;
        } else if (IOException.class.isAssignableFrom(cls)) {
            return RpcException.NETWORK_EXCEPTION;
        } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {
            return RpcException.SERIALIZATION_EXCEPTION;
        }
    }
    return super.getErrorCode(e);
}
```

- å°†å¼‚å¸¸ï¼Œç¿»è¯‘æˆ Dubbo å¼‚å¸¸ç ã€‚

# è¿œç¨‹è°ƒç”¨-Hessian

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `hessian://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

- æœåŠ¡æš´éœ²
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-hessian` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” hessian://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/hessian.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> Hessian åè®®ç”¨äºé›†æˆ Hessian çš„æœåŠ¡ï¼ŒHessian åº•å±‚é‡‡ç”¨ Http é€šè®¯ï¼Œé‡‡ç”¨ Servlet æš´éœ²æœåŠ¡ï¼ŒDubbo ç¼ºçœå†…åµŒ Jetty ä½œä¸ºæœåŠ¡å™¨å®ç°ã€‚

> Dubbo çš„ Hessian åè®®å¯ä»¥å’ŒåŸç”Ÿ Hessian æœåŠ¡äº’æ“ä½œï¼Œå³ï¼š
>
> - æä¾›è€…ç”¨ Dubbo çš„ Hessian åè®®æš´éœ²æœåŠ¡ï¼Œæ¶ˆè´¹è€…ç›´æ¥ç”¨æ ‡å‡† Hessian æ¥å£è°ƒç”¨
> - æˆ–è€…æä¾›æ–¹ç”¨æ ‡å‡† Hessian æš´éœ²æœåŠ¡ï¼Œæ¶ˆè´¹æ–¹ç”¨ Dubbo çš„ Hessian åè®®è°ƒç”¨ã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾ï¼ˆçº¢åœˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š

[![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_13/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_13/01.png)ç±»å›¾

> æ—ç™½å›ï¼šæ•´ä½“å®ç°å’Œ `dubbo-rpc-http` ä¸€è‡´ï¼Œæ‰€ä»¥å†…å®¹ä¸Šå’Œ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡è°ƒç”¨ï¼ˆä¸‰ï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆHTTPï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/rpc-http/?self) å·®ä¸å¤šã€‚

## 2. HttpClientConnection

`com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnection` ï¼Œå®ç° HessianConnection æ¥å£ï¼ŒHttpClient è¿æ¥å™¨å®ç°ç±»ã€‚

```
public class HttpClientConnection implements HessianConnection {

    /**
     * Apache HttpClient
     */
    private final HttpClient httpClient;

    private final ByteArrayOutputStream output;

    private final HttpPost request;

    private volatile HttpResponse response;

    public HttpClientConnection(HttpClient httpClient, URL url) {
        this.httpClient = httpClient;
        this.output = new ByteArrayOutputStream();
        this.request = new HttpPost(url.toString());
    }

    @Override
    public void addHeader(String key, String value) {
        request.addHeader(new BasicHeader(key, value));
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        return output;
    }

    @Override
    public void sendRequest() throws IOException {
        request.setEntity(new ByteArrayEntity(output.toByteArray()));
        this.response = httpClient.execute(request);
    }

    @Override
    public int getStatusCode() {
        return response == null || response.getStatusLine() == null ? 0 : response.getStatusLine().getStatusCode();
    }

    @Override
    public String getStatusMessage() {
        return response == null || response.getStatusLine() == null ? null : response.getStatusLine().getReasonPhrase();
    }

    @Override
    public String getContentEncoding() {
        return (response == null || response.getEntity() == null || response.getEntity().getContentEncoding() == null) ? null : response.getEntity().getContentEncoding().getValue();
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return response == null || response.getEntity() == null ? null : response.getEntity().getContent();
    }

    @Override
    public void close() throws IOException {
        HttpPost request = this.request;
        if (request != null) {
            request.abort();
        }
    }

    @Override
    public void destroy() throws IOException {
    }

}
```

- åŸºäº **Apache HttpClient** å°è£…ã€‚

#### 2.1 HttpClientConnectionFactory

`com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory` ï¼Œå®ç° HessianConnectionFactory æ¥å£ï¼Œåˆ›å»º HttpClientConnection çš„å·¥å‚ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class HttpClientConnectionFactory implements HessianConnectionFactory {

    /**
     * Apache HttpClient
     */
    private final HttpClient httpClient = new DefaultHttpClient();

    @Override
    public void setHessianProxyFactory(HessianProxyFactory factory) {
        HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), (int) factory.getConnectTimeout());
        HttpConnectionParams.setSoTimeout(httpClient.getParams(), (int) factory.getReadTimeout());
    }

    @Override
    public HessianConnection open(URL url) {
        return new HttpClientConnection(httpClient, url); // HttpClientConnection
    }

}
```

## 3. HessianProtocol

[`com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-hessian/src/main/java/com/alibaba/dubbo/rpc/protocol/hessian/HessianProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ`hessian://` åè®®å®ç°ç±»ã€‚

#### 3.1 æ„é€ æ–¹æ³•

```
/**
 * Http æœåŠ¡å™¨é›†åˆ
 *
 * keyï¼šip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter é›†åˆ
 *
 * keyï¼špath æœåŠ¡å
 */
private final Map<String, HessianSkeleton> skeletonMap = new ConcurrentHashMap<String, HessianSkeleton>();
/**
 * HttpBinder$Adaptive å¯¹è±¡
 */
private HttpBinder httpBinder;

public HessianProtocol() {
    super(HessianException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` å±æ€§ï¼ŒHttpServer é›†åˆã€‚é”®ä¸º `ip:port` ï¼Œé€šè¿‡ `#getAddr(url)` æ–¹æ³•ï¼Œè®¡ç®—ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` å±æ€§ï¼Œ`com.caucho.hessian.server.HessianSkeleton` é›†åˆã€‚è¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸º `HttpServer => DispatcherServlet => HessianHandler => HessianSkeleton` ã€‚

- `httpBinder` å±æ€§ï¼ŒHttpBinder$Adaptive å¯¹è±¡ï¼Œé€šè¿‡ `#setHttpBinder(httpBinder)` æ–¹æ³•ï¼ŒDubbo SPI è°ƒç”¨è®¾ç½®ã€‚

- `rpcExceptions = HessianException.class` ã€‚

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // è·å¾—æœåŠ¡å™¨åœ°å€
 4:     String addr = getAddr(url);
 5:     // è·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»ºã€‚
 6:     HttpServer server = serverMap.get(addr);
 7:     if (server == null) {
 8:         server = httpBinder.bind(url, new HessianHandler()); // HessianHandler
 9:         serverMap.put(addr, server);
10:     }
11:     // æ·»åŠ åˆ° skeletonMap ä¸­
12:     final String path = url.getAbsolutePath();
13:     HessianSkeleton skeleton = new HessianSkeleton(impl, type);
14:     skeletonMap.put(path, skeleton);
15:     // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
16:     return new Runnable() {
17:         public void run() {
18:             skeletonMap.remove(path);
19:         }
20:     };
21: }
```

- åŸºäº `dubbo-remoting-http` é¡¹ç›®ï¼Œä½œä¸º**é€šä¿¡æœåŠ¡å™¨**ã€‚
- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#getAddr(url)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡å™¨åœ°å€ã€‚
- ç¬¬ 5 è‡³ 10 è¡Œï¼šä» `serverMap` ä¸­ï¼Œè·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè°ƒç”¨ `HttpBinder#bind(url, handler)` æ–¹æ³•ï¼Œåˆ›å»º HttpServer å¯¹è±¡ã€‚æ­¤å¤„ä½¿ç”¨çš„ HessianHandler ï¼Œä¸‹æ–‡è¯¦ç»†è§£æã€‚
- ç¬¬ 11 è‡³ 14 è¡Œï¼šåˆ›å»º HessianSkeleton å¯¹è±¡ï¼Œæ·»åŠ åˆ° `skeletonMap` é›†åˆä¸­ã€‚
- ç¬¬ 15 è‡³ 20 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable å¯¹è±¡ã€‚

###### 3.2.1 HessianHandler

```
private class HessianHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        String uri = request.getRequestURI();
        // è·å¾— HessianSkeleton å¯¹è±¡
        HessianSkeleton skeleton = skeletonMap.get(uri);
        // å¿…é¡»æ˜¯ POST è¯·æ±‚
        if (!request.getMethod().equalsIgnoreCase("POST")) {
            response.setStatus(500);
        // æ‰§è¡Œè°ƒç”¨
        } else {
            RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
            try {
                skeleton.invoke(request.getInputStream(), response.getOutputStream());
            } catch (Throwable e) {
                throw new ServletException(e);
            }
        }
    }

}
```

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {
 4:     // åˆ›å»º HessianProxyFactory å¯¹è±¡
 5:     HessianProxyFactory hessianProxyFactory = new HessianProxyFactory();
 6:     // åˆ›å»ºè¿æ¥å™¨å·¥å‚ä¸º HttpClientConnectionFactory å¯¹è±¡ï¼Œå³ Apache HttpClient
 7:     String client = url.getParameter(Constants.CLIENT_KEY, Constants.DEFAULT_HTTP_CLIENT);
 8:     if ("httpclient".equals(client)) {
 9:         hessianProxyFactory.setConnectionFactory(new HttpClientConnectionFactory());
10:     } else if (client != null && client.length() > 0 && !Constants.DEFAULT_HTTP_CLIENT.equals(client)) {
11:         throw new IllegalStateException("Unsupported http protocol client=\"" + client + "\"!");
12:     }
13:     // è®¾ç½®è¶…æ—¶æ—¶é—´
14:     int timeout = url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
15:     hessianProxyFactory.setConnectTimeout(timeout);
16:     hessianProxyFactory.setReadTimeout(timeout);
17:     // åˆ›å»º Service Proxy å¯¹è±¡
18:     return (T) hessianProxyFactory.create(serviceType, url.setProtocol("http").toJavaURL(), Thread.currentThread().getContextClassLoader());
19: }
```

- åŸºäº HttpClient ï¼Œä½œä¸º**é€šä¿¡å®¢æˆ·ç«¯**ã€‚
- ç¬¬ 5 è¡Œï¼šåˆ›å»º `com.caucho.hessian.client.HessianProxyFactory` å¯¹è±¡ã€‚
- ç¬¬ 6 è‡³ 12 è¡Œï¼šåˆ›å»º**è¿æ¥å™¨å·¥å‚**ä¸º `com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory` ã€‚
- ç¬¬ 13 è‡³ 16 è¡Œï¼šè®¾ç½®è¶…æ—¶æ—¶é—´ã€‚
- ç¬¬ 18 è¡Œï¼šè°ƒç”¨ `HessianProxyFactory#create(Class<?> api, URL url, ClassLoader loader)` æ–¹æ³•ï¼Œç”Ÿæˆ Service Proxy å¯¹è±¡ã€‚

###### 3.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof HessianConnectionException) {
        if (e.getCause() != null) {
            Class<?> cls = e.getCause().getClass();
            if (SocketTimeoutException.class.equals(cls)) {
                return RpcException.TIMEOUT_EXCEPTION;
            }
        }
        return RpcException.NETWORK_EXCEPTION;
    } else if (e instanceof HessianMethodSerializationException) {
        return RpcException.SERIALIZATION_EXCEPTION;
    }
    return super.getErrorCode(e);
}
```

- å°†å¼‚å¸¸ï¼Œç¿»è¯‘æˆ Dubbo å¼‚å¸¸ç ã€‚

#### 3.4 destroy

```
@Override
public void destroy() {
    // é”€æ¯
    super.destroy();
    // é”€æ¯ HttpServer
    for (String key : new ArrayList<String>(serverMap.keySet())) {
        HttpServer server = serverMap.remove(key);
        if (server != null) {
            try {
                if (logger.isInfoEnabled()) {
                    logger.info("Close hessian server " + server.getUrl());
                }
                server.close();
            } catch (Throwable t) {
                logger.warn(t.getMessage(), t);
            }
        }
    }
}
```

- è¿™éƒ¨åˆ†æ˜¯ `dubbo-rpc-http` æ‰€ç¼ºå¤±çš„ã€‚

# è¿œç¨‹è°ƒç”¨-WebService

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `webservice://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

- æœåŠ¡æš´éœ²
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-webservice` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” webservice://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> åŸºäº WebService çš„è¿œç¨‹è°ƒç”¨åè®®ï¼ŒåŸºäº [Apache CXF](http://cxf.apache.org/) çš„ frontend-simple å’Œ transports-http å®ç°ã€‚

> å¯ä»¥å’ŒåŸç”Ÿ WebService æœåŠ¡äº’æ“ä½œï¼Œå³ï¼š
>
> - æä¾›è€…ç”¨ Dubbo çš„ WebService åè®®æš´éœ²æœåŠ¡ï¼Œæ¶ˆè´¹è€…ç›´æ¥ç”¨æ ‡å‡† WebService æ¥å£è°ƒç”¨ï¼Œ
> - æˆ–è€…æä¾›æ–¹ç”¨æ ‡å‡† WebService æš´éœ²æœåŠ¡ï¼Œæ¶ˆè´¹æ–¹ç”¨ Dubbo çš„ WebService åè®®è°ƒç”¨ã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾ï¼ˆçº¢åœˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š

![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_16/01.png)

> æ—ç™½å›ï¼šæ•´ä½“å®ç°å’Œ `dubbo-rpc-http` ä¸€è‡´ï¼Œæ‰€ä»¥å†…å®¹ä¸Šå’Œ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡è°ƒç”¨ï¼ˆä¸‰ï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆHTTPï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/rpc-http/?self) å·®ä¸å¤šã€‚

## 2. WebServiceProtocol

[`com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-webservice/src/main/java/com/alibaba/dubbo/rpc/protocol/webservice/WebServiceProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ`webservice://` åè®®å®ç°ç±»ã€‚

#### 2.1 æ„é€ æ–¹æ³•

```
/**
 * é»˜è®¤æœåŠ¡å™¨ç«¯å£
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http æœåŠ¡å™¨é›†åˆ
 *
 * keyï¼šip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * ã€Šæˆ‘çœ¼ä¸­çš„CXFä¹‹Busã€‹http://jnn.iteye.com/blog/94746
 * ã€ŠCXF BUSã€‹https://blog.csdn.net/chen_fly2011/article/details/56664908
 */
private final ExtensionManagerBus bus = new ExtensionManagerBus();
/**
 *
 */
private final HTTPTransportFactory transportFactory = new HTTPTransportFactory();
/**
 * HttpBinder$Adaptive å¯¹è±¡
 */
private HttpBinder httpBinder;

public WebServiceProtocol() {
    super(Fault.class);
    bus.setExtension(new ServletDestinationFactory(), HttpDestinationFactory.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` å±æ€§ï¼ŒHttpServer é›†åˆã€‚é”®ä¸º `ip:port` ï¼Œé€šè¿‡ `#getAddr(url)` æ–¹æ³•ï¼Œè®¡ç®—ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` å±æ€§ï¼Œ`com.caucho.hessian.server.HessianSkeleton` é›†åˆã€‚è¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸º `HttpServer => DispatcherServlet => WebServiceHandler => ServletController` ã€‚

- `httpBinder` å±æ€§ï¼ŒHttpBinder$Adaptive å¯¹è±¡ï¼Œé€šè¿‡ `#setHttpBinder(httpBinder)` æ–¹æ³•ï¼ŒDubbo SPI è°ƒç”¨è®¾ç½®ã€‚

- `rpcExceptions = Fault.class` ã€‚

- ```
  bus
  ```

   

  å’Œ

   

  ```
  transportFactory
  ```

   

  å±æ€§ï¼Œå¯ä»¥å‚çœ‹å¦‚ä¸‹æ–‡ç« ï¼š

  - [ã€Šæˆ‘çœ¼ä¸­çš„CXFä¹‹Busã€‹](http://jnn.iteye.com/blog/94746)
  - [ã€ŠCXF BUSã€‹](https://blog.csdn.net/chen_fly2011/article/details/56664908)

- ğŸ™‚ è‰¿è‰¿å¯¹ Apache CXF äº†è§£ä¸å¤šï¼Œæ‰€ä»¥æœ¬æ–‡æ›´å¤šæ¢³ç†å¥½æ•´ä½“è„‰ç»œã€‚

#### 2.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // è·å¾—æœåŠ¡å™¨åœ°å€
 4:     String addr = getAddr(url);
 5:     // è·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»ºã€‚
 6:     HttpServer httpServer = serverMap.get(addr);
 7:     if (httpServer == null) {
 8:         httpServer = httpBinder.bind(url, new WebServiceHandler()); // WebServiceHandler
 9:         serverMap.put(addr, httpServer);
10:     }
11:     // åˆ›å»º ServerFactoryBean å¯¹è±¡
12:     final ServerFactoryBean serverFactoryBean = new ServerFactoryBean();
13:     serverFactoryBean.setAddress(url.getAbsolutePath());
14:     serverFactoryBean.setServiceClass(type);
15:     serverFactoryBean.setServiceBean(impl);
16:     serverFactoryBean.setBus(bus);
17:     serverFactoryBean.setDestinationFactory(transportFactory);
18:     serverFactoryBean.create();
19:     // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
20:     return new Runnable() {
21:         public void run() {
22:             serverFactoryBean.destroy();
23:         }
24:     };
25: }
```

- åŸºäº `dubbo-remoting-http` é¡¹ç›®ï¼Œä½œä¸º**é€šä¿¡æœåŠ¡å™¨**ã€‚
- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#getAddr(url)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡å™¨åœ°å€ã€‚
- ç¬¬ 5 è‡³ 10 è¡Œï¼šä» `serverMap` ä¸­ï¼Œè·å¾— HttpServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè°ƒç”¨ `HttpBinder#bind(url, handler)` æ–¹æ³•ï¼Œåˆ›å»º HttpServer å¯¹è±¡ã€‚æ­¤å¤„ä½¿ç”¨çš„ WebServiceHandler ï¼Œä¸‹æ–‡è¯¦ç»†è§£æã€‚
- ç¬¬ 11 è‡³ 18 è¡Œï¼šåˆ›å»º ServerFactoryBean å¯¹è±¡ã€‚
- ç¬¬ 19 è‡³ 24 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable å¯¹è±¡ã€‚

###### 2.2.1 WebServiceHandler

```
private class WebServiceHandler implements HttpHandler {

    private volatile ServletController servletController;

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        // åˆ›å»º ServletController å¯¹è±¡ï¼Œè®¾ç½®ä½¿ç”¨ DispatcherServlet ã€‚
        if (servletController == null) {
            HttpServlet httpServlet = DispatcherServlet.getInstance();
            if (httpServlet == null) {
                response.sendError(500, "No such DispatcherServlet instance.");
                return;
            }
            synchronized (this) {
                if (servletController == null) {
                    servletController = new ServletController(transportFactory.getRegistry(), httpServlet.getServletConfig(), httpServlet);
                }
            }
        }
        // è®¾ç½®è°ƒç”¨æ–¹åœ°å€
        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
        // æ‰§è¡Œè°ƒç”¨
        servletController.invoke(request, response);
    }

}
```

#### 2.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // åˆ›å»º ClientProxyFactoryBean å¯¹è±¡
 5:     ClientProxyFactoryBean proxyFactoryBean = new ClientProxyFactoryBean();
 6:     proxyFactoryBean.setAddress(url.setProtocol("http").toIdentityString());
 7:     proxyFactoryBean.setServiceClass(serviceType);
 8:     proxyFactoryBean.setBus(bus);
 9:     // åˆ›å»º Service Proxy å¯¹è±¡
10:     T ref = (T) proxyFactoryBean.create();
11:     // è®¾ç½®è¶…æ—¶ç›¸å…³å±æ€§
12:     Client proxy = ClientProxy.getClient(ref);
13:     HTTPConduit conduit = (HTTPConduit) proxy.getConduit();
14:     HTTPClientPolicy policy = new HTTPClientPolicy();
15:     policy.setConnectionTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
16:     policy.setReceiveTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
17:     conduit.setClient(policy);
18:     return ref;
19: }
```

- ç¬¬ 4 è‡³ 8 è¡Œï¼šåˆ›å»º ClientProxyFactoryBean å¯¹è±¡ã€‚
- ç¬¬ 10 è¡Œï¼šåˆ›å»º Service Proxy å¯¹è±¡ã€‚
- ç¬¬ 11 è‡³ 17 è¡Œï¼šè®¾ç½®**è¶…æ—¶ç›¸å…³**å±æ€§ã€‚

###### 2.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof Fault) {
        e = e.getCause();
    }
    if (e instanceof SocketTimeoutException) {
        return RpcException.TIMEOUT_EXCEPTION;
    } else if (e instanceof IOException) {
        return RpcException.NETWORK_EXCEPTION;
    }
    return super.getErrorCode(e);
}
```

- å°†å¼‚å¸¸ï¼Œç¿»è¯‘æˆ Dubbo å¼‚å¸¸ç ã€‚

# è¿œç¨‹è°ƒç”¨-REST

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `rest://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

- æœåŠ¡æš´éœ²
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-rest` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€Šåœ¨Dubboä¸­å¼€å‘RESTé£æ ¼çš„è¿œç¨‹è°ƒç”¨ï¼ˆRESTful Remotingï¼‰ã€‹](https://dangdangdotcom.github.io/dubbox/rest.html) ã€‚

> æˆ‘ä»¬åŸºäºæ ‡å‡†çš„ Java REST APIâ€”â€”JAX-RS 2.0ï¼ˆJava API for RESTful Web Services sçš„ç®€å†™ï¼‰ï¼Œä¸º dubbo æä¾›äº†æ¥è¿‘é€æ˜çš„ REST è°ƒç”¨æ”¯æŒã€‚ç”±äºå®Œå…¨å…¼å®¹ Java æ ‡å‡† AP Iï¼Œæ‰€ä»¥ä¸º dubbo å¼€å‘çš„æ‰€æœ‰RESTæœåŠ¡ï¼Œæœªæ¥è„±ç¦» dubbo æˆ–è€…ä»»ä½•ç‰¹å®šçš„ REST åº•å±‚å®ç°ä¸€èˆ¬ä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ JAX-RS çš„ç®€ä»‹ï¼š

> JAX-RS æ˜¯æ ‡å‡†çš„ Java REST API ï¼Œå¾—åˆ°äº†ä¸šç•Œçš„å¹¿æ³›æ”¯æŒå’Œåº”ç”¨ï¼Œå…¶è‘—åçš„å¼€æºå®ç°å°±æœ‰å¾ˆå¤šï¼ŒåŒ…æ‹¬ Oracle çš„ Jersey ï¼ŒRedHat çš„ Resteasy ï¼ŒApache çš„ CXF å’Œ Wink ï¼Œä»¥åŠrestlet ç­‰ç­‰ã€‚å¦å¤–ï¼Œæ‰€æœ‰æ”¯æŒ JavaEE 6.0 ä»¥ä¸Šè§„èŒƒçš„å•†ç”¨ JavaEE åº”ç”¨æœåŠ¡å™¨éƒ½å¯¹ JAX-RS æä¾›äº†æ”¯æŒã€‚å› æ­¤ï¼ŒJAX-RS æ˜¯ä¸€ç§å·²ç»éå¸¸æˆç†Ÿçš„è§£å†³æ–¹æ¡ˆï¼Œå¹¶ä¸”é‡‡ç”¨å®ƒæ²¡æœ‰ä»»ä½•æ‰€è°“ vendor lock-in çš„é—®é¢˜ã€‚

åœ¨ `dubbo-rpc-rest` é¡¹ç›®ä¸­ï¼Œç›®å‰ä½¿ç”¨ä½¿ç”¨çš„æ˜¯ RedHat çš„ **Resteasy** ã€‚åœ¨ `pom.xml` å¼•å…¥å¦‚ä¸‹ï¼š

```
<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-jaxrs</artifactId>
</dependency>

<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-client</artifactId>
</dependency>

// è¿˜æœ‰å…¶ä»–å¯é€‰çš„ resteasy ç›¸å…³çš„å¼•ç”¨ï¼Œæ­¤å¤„æš‚æ—¶çœç•¥ã€‚
```

å› ä¸ºæœ¬æ–‡ä¼šæ¶‰åŠåˆ°å¤§é‡çš„ Resteasy çš„åŸç†ï¼Œè‰¿è‰¿çœ‹äº† [ã€ŠRESTEASY ,ä»å­¦ä¼šä½¿ç”¨åˆ°äº†è§£åŸç†ã€‹](http://www.cnblogs.com/langtianya/p/7624647.html) ï¼Œè§‰å¾—éå¸¸ä¸é”™ï¼Œèƒ–å‹ä¸€å®šè¦çœ‹å™¢ã€‚ğŸ˜ˆ ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ¬æ–‡ä¸ä¼šé‡å¤è¯¦ç»†åˆ†äº« Resteasy çš„åŸç†ï¼Œå“ˆå“ˆå“ˆã€‚

æœ¬æ–‡æ¶‰åŠçš„ç±»ï¼Œå¦‚ä¸‹å›¾ï¼š

[![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_19/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_19/01.png)ç±»å›¾

æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ RestProtocol çš„å®ç°ä»£ç ï¼Œç„¶åå†çœ‹å…¶ä»–å±‚çš„å®ç°ã€‚

## 2. RestProtocol

[`com.alibaba.dubbo.rpc.protocol.rest.RestProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ`rest://` åè®®å®ç°ç±»ã€‚

#### 2.1 æ„é€ æ–¹æ³•

```
/**
 * æœåŠ¡å™¨é»˜è®¤ç«¯å£
 */
private static final int DEFAULT_PORT = 80;

/**
 * æœåŠ¡å™¨é›†åˆ
 *
 * keyï¼šip:port
 */
private final Map<String, RestServer> servers = new ConcurrentHashMap<String, RestServer>();
/**
 * æœåŠ¡å™¨å·¥å‚ï¼Œè´Ÿè´£åˆ›å»ºæœåŠ¡å™¨
 */
private final RestServerFactory serverFactory = new RestServerFactory();
/**
 * å®¢æˆ·ç«¯æ•°ç»„
 */
// TODO in the future maybe we can just use a single rest client and connection manager
private final List<ResteasyClient> clients = Collections.synchronizedList(new LinkedList<ResteasyClient>());
/**
 * è¿æ¥ç›‘æ§å™¨
 */
private volatile ConnectionMonitor connectionMonitor;

public RestProtocol() {
    super(WebApplicationException.class, ProcessingException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    serverFactory.setHttpBinder(httpBinder);
}

public int getDefaultPort() {
    return DEFAULT_PORT;
}
```

- æœåŠ¡æš´éœ²ç›¸å…³å±æ€§ï¼š`servers` `serverFactory` ã€‚
- æœåŠ¡å¼•ç”¨ç›¸å…³å±æ€§ï¼š`clients` `connectionMonitor` ã€‚
- `rpcExceptions = WebApplicationException.class å’Œ ProcessingException.class` ã€‚
- `#setHttpBinder(httpBinder)` æ–¹æ³•ï¼Œåœ¨ RestProtocol å¯¹è±¡åˆ›å»ºæ—¶ï¼Œè¢« Dubbo SPI æœºåˆ¶è°ƒç”¨ï¼Œå‘ `serverFactory` æ³¨å…¥ `httpBinder` å±æ€§ã€‚ä¸ºä»€ä¹ˆè¿™ä¹ˆåšï¼Ÿåœ¨ RestServerFactory çš„å®ç°ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°åŸå› ã€‚

#### 2.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // è·å¾—æœåŠ¡å™¨åœ°å€
 4:     String addr = getAddr(url);
 5:     // è·å¾—æœåŠ¡çš„çœŸå®ç±»åï¼Œä¾‹å¦‚ DemoServiceImpl
 6:     Class implClass = ServiceClassHolder.getInstance().popServiceClass();
 7:     // è·å¾— RestServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›è¡Œåˆ›å»ºã€‚
 8:     RestServer server = servers.get(addr);
 9:     if (server == null) {
10:         server = serverFactory.createServer(url.getParameter(Constants.SERVER_KEY, "jetty"));
11:         server.start(url); // å¯åŠ¨
12:         servers.put(addr, server);
13:     }
14: 
15:     // è·å¾— ContextPath è·¯å¾„ã€‚
16:     String contextPath = getContextPath(url);
17:     if ("servlet".equalsIgnoreCase(url.getParameter(Constants.SERVER_KEY, "jetty"))) { // å¤–éƒ¨çš„å®¹å™¨ï¼Œéœ€è¦ä» ServletContext ä¸­è·å¾—ã€‚
18:         ServletContext servletContext = ServletManager.getInstance().getServletContext(ServletManager.EXTERNAL_SERVER_PORT);
19:         if (servletContext == null) {
20:             throw new RpcException("No servlet context found. Since you are using server='servlet', " +
21:                     "make sure that you've configured " + BootstrapListener.class.getName() + " in web.xml");
22:         }
23:         String webappPath = servletContext.getContextPath();
24:         if (StringUtils.isNotEmpty(webappPath)) {
25:             // å»æ‰ `/` èµ·å§‹
26:             webappPath = webappPath.substring(1);
27:             // æ ¡éªŒ URL ä¸­é…ç½®çš„ `contextPath` æ˜¯å¤–éƒ¨å®¹å™¨çš„ `contextPath` èµ·å§‹ã€‚
28:             if (!contextPath.startsWith(webappPath)) {
29:                 throw new RpcException("Since you are using server='servlet', " +
30:                         "make sure that the 'contextpath' property starts with the path of external webapp");
31:             }
32:             // æˆªå–æ‰èµ·å§‹éƒ¨åˆ†
33:             contextPath = contextPath.substring(webappPath.length());
34:             // å»æ‰ `/` èµ·å§‹
35:             if (contextPath.startsWith("/")) {
36:                 contextPath = contextPath.substring(1);
37:             }
38:         }
39:     }
40:     // è·å¾—ä»¥ `@Path` ä¸ºæ³¨è§£çš„åŸºç¡€ç±»ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨ `implClass` ä¸Šæ·»åŠ äº†è¯¥æ³¨è§£ï¼Œå³å°±æ˜¯ `implClass` ç±»ã€‚
41:     final Class resourceDef = GetRestful.getRootResourceClass(implClass) != null ? implClass : type;
42:     // éƒ¨ç½²åˆ°æœåŠ¡å™¨ä¸Š
43:     server.deploy(resourceDef, impl, contextPath);
44:     // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
45:     final RestServer s = server;
46:     return new Runnable() {
47:         public void run() {
48:             // TODO due to dubbo's current architecture,
49:             // it will be called from registry protocol in the shutdown process and won't appear in logs
50:             s.undeploy(resourceDef);
51:         }
52:     };
53: }
```

- ç¬¬ 4 è¡Œï¼šè°ƒç”¨ `#getAddr(url)` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡å™¨åœ°å€ `ip:port` ã€‚

- ç¬¬ 6 è¡Œï¼šè°ƒç”¨ `ServiceClassHolder#popServiceClass()` æ–¹æ³•ï¼Œè·å¾—æœåŠ¡çš„çœŸå®ç±»åï¼Œä¾‹å¦‚ï¼šDemoServiceImpl ã€‚åœ¨ ServiceConfig åˆå§‹åŒ–æ—¶ï¼Œä¼šè°ƒç”¨å¦‚ä¸‹ä»£ç ï¼š

  ```
  ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));
  ```

  - å½“ç„¶ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªä¼˜é›…çš„å®ç°ï¼Œæœªæ¥å¯èƒ½ä¼šé‡æ„ä¼˜åŒ–è¿™å—çš„ä»£ç ã€‚

- ç¬¬ 7 è‡³ 13 è¡Œï¼šä» `servers` ä¸­ï¼Œè·å¾— RestServer å¯¹è±¡ã€‚è‹¥ä¸å­˜åœ¨ï¼Œè°ƒç”¨ `RestServerFactory#createServer(url)` æ–¹æ³•è¿›è¡Œåˆ›å»ºï¼Œå¹¶ä¸”ï¼Œè°ƒç”¨ `RestServer#start(url)` æ–¹æ³•ï¼Œè¿›è¡Œå¯åŠ¨ã€‚

- ç¬¬ 15 è‡³ 39 è¡Œï¼šè°ƒç”¨ `#getContextPath(url)` æ–¹æ³•ï¼Œè·å¾— ContextPath è·¯å¾„ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected String getContextPath(URL url) {
      int pos = url.getPath().lastIndexOf("/"); // å°¾éƒ¨ / ä¹‹å
      return pos > 0 ? url.getPath().substring(0, pos) : "";
  }
  ```

- ç¬¬ 41 è¡Œï¼šè·å¾—ä»¥ `@Path` ä¸ºæ³¨è§£çš„åŸºç¡€ç±»ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨ `implClass` ä¸Šæ·»åŠ äº†è¯¥æ³¨è§£ï¼Œå³å°±æ˜¯ `implClass` ç±»ã€‚å½“ç„¶ï¼Œå®˜æ–¹æœ‰ä¸€æ®µè¯éå¸¸å…³é”®ï¼Œå¦‚ä¸‹ï¼š

  > **Annotationæ”¾åœ¨æ¥å£ç±»è¿˜æ˜¯å®ç°ç±»**

  > åœ¨Dubbo ä¸­å¼€å‘ REST æœåŠ¡ä¸»è¦éƒ½æ˜¯é€šè¿‡ JAX-RS çš„ annotation æ¥å®Œæˆé…ç½®çš„ï¼Œåœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬éƒ½æ˜¯å°† annotation æ”¾åœ¨æœåŠ¡çš„å®ç°ç±»ä¸­ã€‚ä½†å…¶å®ï¼Œæˆ‘ä»¬å®Œå…¨ä¹Ÿå¯ä»¥å°† annotation æ”¾åˆ°æœåŠ¡çš„æ¥å£ä¸Šï¼Œè¿™ä¸¤ç§æ–¹å¼æ˜¯å®Œå…¨ç­‰ä»·çš„ã€‚
  >
  > åœ¨ä¸€èˆ¬åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬å»ºè®®å°† annotation æ”¾åˆ°æœåŠ¡å®ç°ç±»ï¼Œè¿™æ · annotation å’Œ java å®ç°ä»£ç ä½ç½®æ›´æ¥è¿‘ï¼Œæ›´ä¾¿äºå¼€å‘å’Œç»´æŠ¤ã€‚å¦å¤–æ›´é‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸€èˆ¬å€¾å‘äºé¿å…å¯¹æ¥å£çš„æ±¡æŸ“ï¼Œä¿æŒæ¥å£çš„çº¯å‡€æ€§å’Œå¹¿æ³›é€‚ç”¨æ€§ã€‚
  >
  > ã€å…³é”®ã€‘
  > *ä½†æ˜¯ï¼Œå¦‚åæ–‡æ‰€è¿°ï¼Œå¦‚æœæˆ‘ä»¬è¦ç”¨dubboç›´æ¥å¼€å‘çš„æ¶ˆè´¹ç«¯æ¥è®¿é—®æ­¤æœåŠ¡ï¼Œåˆ™annotationå¿…é¡»æ”¾åˆ°æ¥å£ä¸Šã€‚*
  >
  > å¦‚æœæ¥å£å’Œå®ç°ç±»éƒ½åŒæ—¶æ·»åŠ äº†annotationï¼Œåˆ™å®ç°ç±»çš„ annotation é…ç½®ä¼šç”Ÿæ•ˆï¼Œæ¥å£ä¸Šçš„ annotation è¢«ç›´æ¥å¿½ç•¥ã€‚

- ç¬¬ 43 è¡Œï¼šè°ƒç”¨ `RestServer#deploy(resourceDef, impl, contextPath)` æ–¹æ³•ï¼Œéƒ¨ç½² Service åˆ°æœåŠ¡å™¨ä¸Šã€‚åˆ°äº†æ­¤å¤„ï¼ŒæœåŠ¡æš´éœ²å°±å·²ç»å®Œæˆï¼Œé‚£ä¹ˆ**è¯·æ±‚æ˜¯å¦‚ä½•è°ƒåº¦åˆ° Service çš„å‘¢**ï¼Ÿåœ¨ [ã€Œ3. RestServerã€](http://svip.iocoder.cn/Dubbo/rpc-rest/#) è¯¦ç»†è§£æã€‚

- ç¬¬ 44 è‡³ 52 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable ã€‚

#### 2.3 doRefer

```
 1: @Override
 2: protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {
 3:     // åˆ›å»º ConnectionMonitor å¯¹è±¡ã€‚
 4:     if (connectionMonitor == null) {
 5:         connectionMonitor = new ConnectionMonitor();
 6:     }
 7: 
 8:     // åˆ›å»º HttpClient è¿æ¥æ± ç®¡ç†å™¨
 9:     // TODO more configs to add
10:     PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
11:     // 20 is the default maxTotal of current PoolingClientConnectionManager
12:     connectionManager.setMaxTotal(url.getParameter(Constants.CONNECTIONS_KEY, 20)); // æœ€å¤§è¯·æ±‚æ•°
13:     connectionManager.setDefaultMaxPerRoute(url.getParameter(Constants.CONNECTIONS_KEY, 20)); // æ¯ä¸ªè·¯ç”±ï¼Œæœ€å¤§è¯·æ±‚æ•°
14:     // æ·»åŠ åˆ° ConnectionMonitor ä¸­ã€‚
15:     connectionMonitor.addConnectionManager(connectionManager);
16: 
17:     // åˆ›å»º RequestConfig å¯¹è±¡
18:     RequestConfig requestConfig = RequestConfig.custom()
19:             .setConnectTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)) // è¿æ¥è¶…æ—¶
20:             .setSocketTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)) // è¯·æ±‚è¶…æ—¶
21:             .build();
22:     // åˆ›å»º SocketConfig å¯¹è±¡
23:     SocketConfig socketConfig = SocketConfig.custom()
24:             .setSoKeepAlive(true) // ä¿æŒè¿æ¥
25:             .setTcpNoDelay(true)
26:             .build();
27:     // åˆ›å»º HttpClient å¯¹è±¡ ã€Apacheã€‘
28:     CloseableHttpClient httpClient = HttpClientBuilder.create()
29:             .setKeepAliveStrategy(new ConnectionKeepAliveStrategy() { // ä¼˜å…ˆä»¥æœåŠ¡å™¨è¿”å›çš„ä¸ºå‡†ï¼Œç¼ºçœä¸º 30 ç§’ã€‚
30:                 public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
31:                     HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE));
32:                     while (it.hasNext()) {
33:                         HeaderElement he = it.nextElement();
34:                         String param = he.getName();
35:                         String value = he.getValue();
36:                         if (value != null && param.equalsIgnoreCase("timeout")) {
37:                             return Long.parseLong(value) * 1000;
38:                         }
39:                     }
40:                     // TODO constant
41:                     return 30 * 1000;
42:                 }
43:             })
44:             .setDefaultRequestConfig(requestConfig)
45:             .setDefaultSocketConfig(socketConfig)
46:             .build();
47: 
48:     // åˆ›å»º ApacheHttpClient4Engine å¯¹è±¡ ã€Resteasyã€‘
49:     ApacheHttpClient4Engine engine = new ApacheHttpClient4Engine(httpClient/*, localContext*/);
50:     // åˆ›å»º ResteasyClient å¯¹è±¡ ã€Resteasyã€‘
51:     ResteasyClient client = new ResteasyClientBuilder().httpEngine(engine).build();
52:     // æ·»åŠ åˆ°å®¢æˆ·ç«¯é›†åˆ
53:     clients.add(client);
54: 
55:     // è®¾ç½® RpcContextFilter è¿‡æ»¤å™¨
56:     client.register(RpcContextFilter.class);
57:     // ä» `extension` é…ç½®é¡¹ï¼Œè®¾ç½®å¯¹åº”çš„ç»„ä»¶ï¼ˆè¿‡æ»¤å™¨ Filter ã€æ‹¦æˆªå™¨ Interceptor ã€å¼‚å¸¸åŒ¹é…å™¨ ExceptionMapper ç­‰ç­‰ï¼‰ã€‚
58:     for (String clazz : Constants.COMMA_SPLIT_PATTERN.split(url.getParameter(Constants.EXTENSION_KEY, ""))) {
59:         if (!StringUtils.isEmpty(clazz)) {
60:             try {
61:                 client.register(Thread.currentThread().getContextClassLoader().loadClass(clazz.trim()));
62:             } catch (ClassNotFoundException e) {
63:                 throw new RpcException("Error loading JAX-RS extension class: " + clazz.trim(), e);
64:             }
65:         }
66:     }
67: 
68:     // åˆ›å»º Service Proxy å¯¹è±¡ã€‚
69:     // TODO protocol
70:     ResteasyWebTarget target = client.target("http://" + url.getHost() + ":" + url.getPort() + "/" + getContextPath(url));
71:     return target.proxy(serviceType);
72: }
```

- ç¬¬ 3 è‡³ 6 è¡Œï¼šåˆ›å»º ConnectionMonitor å¯¹è±¡ã€‚

- ç¬¬ 8 è‡³ 15 è¡Œï¼šåˆ›å»º HttpClient è¿æ¥æ± ç®¡ç†å™¨ï¼Œè®¾ç½®**è¯·æ±‚æ•°**ç›¸å…³é…ç½®ï¼Œå¹¶ä¸”æ·»åŠ åˆ° ConnectionMonitor ä¸­ã€‚

- ç¬¬ 17 è‡³ 46 è¡Œï¼šåˆ›å»º **Apache** HttpClient å¯¹è±¡ã€‚

  - ç¬¬ 17 è‡³ 21 è¡Œï¼šåˆ›å»º RequestConfig å¯¹è±¡ï¼Œè®¾ç½®**è¶…æ—¶**ç›¸å…³é…ç½®ã€‚

  - ç¬¬ 22 è‡³ 26 è¡Œï¼šåˆ›å»º SocketConfig å¯¹è±¡ï¼Œè®¾ç½®**è¿æ¥**ç›¸å…³é…ç½®ã€‚

  - ç¬¬ 29 è‡³ 43 è¡Œï¼šåˆ›å»º ConnectionKeepAliveStrategy å¯¹è±¡ï¼Œä¼˜å…ˆä»¥æœåŠ¡å™¨è¿”å› `Keep-Alive` ä¸ºå‡†ï¼Œç¼ºçœä¸º 30 ç§’ã€‚å‚è§æ–‡ç«  [ã€ŠHttpClient4.5.2 è¿æ¥ç®¡ç†ã€‹](http://study121007.iteye.com/blog/2304274) çš„ **[2.6. è¿æ¥å­˜æ´»ç­–ç•¥](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** ï¼š

    > Http è§„èŒƒæ²¡æœ‰è§„å®šä¸€ä¸ªæŒä¹…è¿æ¥åº”è¯¥ä¿æŒå­˜æ´»å¤šä¹…ã€‚æœ‰äº› Http æœåŠ¡å™¨ä½¿ç”¨éæ ‡å‡†çš„ Keep-Alive å¤´æ¶ˆæ¯å’Œå®¢æˆ·ç«¯è¿›è¡Œäº¤äº’ï¼ŒæœåŠ¡å™¨ç«¯ä¼šä¿æŒæ•°ç§’æ—¶é—´å†…ä¿æŒè¿æ¥ã€‚HttpClient ä¹Ÿä¼šåˆ©ç”¨è¿™ä¸ªå¤´æ¶ˆæ¯ã€‚å¦‚æœæœåŠ¡å™¨è¿”å›çš„å“åº”ä¸­æ²¡æœ‰åŒ…å« Keep-Alive å¤´æ¶ˆæ¯ï¼ŒHttpClientä¼šè®¤ä¸ºè¿™ä¸ªè¿æ¥å¯ä»¥æ°¸è¿œä¿æŒã€‚ç„¶è€Œï¼Œå¾ˆå¤šæœåŠ¡å™¨éƒ½ä¼šåœ¨ä¸é€šçŸ¥å®¢æˆ·ç«¯çš„æƒ…å†µä¸‹ï¼Œå…³é—­ä¸€å®šæ—¶é—´å†…ä¸æ´»åŠ¨çš„è¿æ¥ï¼Œæ¥èŠ‚çœæœåŠ¡å™¨èµ„æºã€‚åœ¨æŸäº›æƒ…å†µä¸‹é»˜è®¤çš„ç­–ç•¥æ˜¾å¾—å¤ªä¹è§‚ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦è‡ªå®šä¹‰è¿æ¥å­˜æ´»ç­–ç•¥ã€‚

- ç¬¬ 48 è‡³ 53 è¡Œï¼šåˆ›å»º **Resteasy** ResteasyClient å¯¹è±¡ï¼Œå¹¶ä¸”æ·»åŠ åˆ°å®¢æˆ·ç«¯é›†åˆ `clients` ä¸­ã€‚

- ç¬¬ 55 è¡Œï¼šè°ƒç”¨ `ResteasyClient#register(Class<?> componentClass)` æ–¹æ³•ï¼Œæ³¨å†Œ RpcContextFilter åˆ° ResteasyClient ä¸­ã€‚

- ç¬¬ 57 è‡³ 66 è¡Œï¼šä» `extension` é…ç½®é¡¹ï¼Œè®¾ç½®å¯¹åº”çš„ç»„ä»¶ï¼ˆè¿‡æ»¤å™¨ Filter ã€æ‹¦æˆªå™¨ Interceptor ã€å¼‚å¸¸åŒ¹é…å™¨ ExceptionMapper ç­‰ç­‰ï¼‰ã€‚è¯¦ç»†è¯´æ˜ï¼Œå‚è§ [ã€Šåœ¨Dubboä¸­å¼€å‘RESTé£æ ¼çš„è¿œç¨‹è°ƒç”¨ï¼ˆRESTful Remotingï¼‰ã€‹](https://dangdangdotcom.github.io/dubbox/rest.html) çš„ **[æ·»åŠ è‡ªå®šä¹‰çš„Filterã€Interceptorç­‰](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** ã€‚

- ç¬¬ 68 è‡³ 71 è¡Œï¼šåˆ›å»º ResteasyWebTarget å¯¹è±¡ï¼Œå¹¶è°ƒç”¨ `ResteasyWebTarget#proxy(serviceType)` æ–¹æ³•ï¼Œåˆ›å»º **Service Proxy** å¯¹è±¡ã€‚

- **æ³¨æ„**ï¼Œä¸Šæ–‡ä¹Ÿæåˆ°äº†ï¼Œå¦‚æœä½¿ç”¨ Dubbo `rest://` Consumer ï¼Œéœ€è¦å°† JAX-RS çš„**æ³¨è§£** åˆ° Service æ¥å£ç±»ä¸­ï¼Œå¦åˆ™ï¼Œè¯·æ±‚çš„å‚æ•°å’Œæ–¹æ³•çš„å‚æ•°ï¼Œæ— æ³•æ˜ å°„ä¸Šã€‚

###### 2.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    // TODO
    return super.getErrorCode(e);
}
```

- ç›®å‰ï¼Œæš‚æœªå®ç°å¼‚å¸¸ç¿»è¯‘æˆ Dubbo çš„é”™è¯¯ç ã€‚
- ğŸ™‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸ä½¿ç”¨ Dubbo `rest://` Consumer ï¼Œè€Œæ˜¯è®© Dubbo æš´éœ² `dubbo://` æœåŠ¡ï¼Œä½¿ç”¨ Dubbo `dubbo://` Consumer ã€‚

###### 2.3.2 ConnectionMonitor

```
protected class ConnectionMonitor extends Thread {

    /**
     * æ˜¯å¦å…³é—­
     */
    private volatile boolean shutdown;
    /**
     * HttpClient è¿æ¥æ± ç®¡ç†å™¨é›†åˆ
     */
    private final List<PoolingHttpClientConnectionManager> connectionManagers = Collections.synchronizedList(new LinkedList<PoolingHttpClientConnectionManager>());

    public void addConnectionManager(PoolingHttpClientConnectionManager connectionManager) {
        connectionManagers.add(connectionManager);
    }

    @Override
    public void run() {
        try {
            while (!shutdown) {
                synchronized (this) {
                    // ç­‰å¾… 1000 ms
                    wait(1000); // å¯è¢«ä¸‹é¢ shutdown() æ–¹æ³•ï¼Œå¼ºè¡Œå…³é—­
                    for (PoolingHttpClientConnectionManager connectionManager : connectionManagers) {
                        connectionManager.closeExpiredConnections();
                        // TODO constant
                        connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                    }
                }
            }
        } catch (InterruptedException ex) {
            shutdown();
        }
    }

    public void shutdown() {
        // æ ‡è®°å…³é—­
        shutdown = true;
        // æ¸…é™¤ç®¡ç†å™¨é›†åˆ
        connectionManagers.clear();
        // å”¤é†’ç­‰å¾…çº¿ç¨‹
        synchronized (this) {
            notifyAll();
        }
    }

}
```

- ä¸ºä»€ä¹ˆæœ‰äº†**è¿æ¥æ± **ï¼Œè¿˜éœ€è¦æœ‰è¿™æ ·ä¸€ä¸ª Monitor å‘¢ï¼Ÿå‚è§æ–‡ç«  [ã€ŠHttpClient4.5.2 è¿æ¥ç®¡ç†ã€‹](http://study121007.iteye.com/blog/2304274) çš„ **[2.5. è¿æ¥å›æ”¶ç­–ç•¥](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** ï¼š

  > ç»å…¸é˜»å¡ I/O æ¨¡å‹çš„ä¸€ä¸ªä¸»è¦ç¼ºç‚¹å°±æ˜¯åªæœ‰å½“ç»„ä¾§ I/O æ—¶ï¼Œsocket æ‰èƒ½å¯¹ I/O äº‹ä»¶åšå‡ºååº”ã€‚å½“è¿æ¥è¢«ç®¡ç†å™¨æ”¶å›åï¼Œè¿™ä¸ªè¿æ¥ä»ç„¶å­˜æ´»ï¼Œä½†æ˜¯å´æ— æ³•ç›‘æ§socketçš„çŠ¶æ€ï¼Œä¹Ÿæ— æ³•å¯¹I/Oäº‹ä»¶åšå‡ºåé¦ˆã€‚å¦‚æœè¿æ¥è¢«æœåŠ¡å™¨ç«¯å…³é—­äº†ï¼Œå®¢æˆ·ç«¯ç›‘æµ‹ä¸åˆ°è¿æ¥çš„çŠ¶æ€å˜åŒ–ï¼ˆä¹Ÿå°±æ— æ³•æ ¹æ®è¿æ¥çŠ¶æ€çš„å˜åŒ–ï¼Œå…³é—­æœ¬åœ°çš„ socket ï¼‰ã€‚
  >
  > HttpClientä¸ºäº†ç¼“è§£è¿™ä¸€é—®é¢˜é€ æˆçš„å½±å“ï¼Œä¼šåœ¨ä½¿ç”¨æŸä¸ªè¿æ¥å‰ï¼Œç›‘æµ‹è¿™ä¸ªè¿æ¥æ˜¯å¦å·²ç»è¿‡æ—¶ï¼Œå¦‚æœæœåŠ¡å™¨ç«¯å…³é—­äº†è¿æ¥ï¼Œé‚£ä¹ˆè¿æ¥å°±ä¼šå¤±æ•ˆã€‚è¿™ç§è¿‡æ—¶æ£€æŸ¥å¹¶ä¸æ˜¯ 100% æœ‰æ•ˆï¼Œå¹¶ä¸”ä¼šç»™æ¯ä¸ªè¯·æ±‚å¢åŠ  10 åˆ° 30 æ¯«ç§’é¢å¤–å¼€é”€ã€‚å”¯ä¸€ä¸€ä¸ªå¯è¡Œçš„ï¼Œä¸” does not involve a one thread per socket model for idle connections çš„è§£å†³åŠæ³•ï¼Œæ˜¯å»ºç«‹ä¸€ä¸ªç›‘æ§çº¿ç¨‹ï¼Œæ¥ä¸“é—¨å›æ”¶ç”±äºé•¿æ—¶é—´ä¸æ´»åŠ¨è€Œè¢«åˆ¤å®šä¸ºå¤±æ•ˆçš„è¿æ¥ã€‚è¿™ä¸ªç›‘æ§çº¿ç¨‹å¯ä»¥å‘¨æœŸæ€§çš„è°ƒç”¨ClientConnectionManager ç±»çš„ closeExpiredConnections() æ–¹æ³•æ¥å…³é—­è¿‡æœŸçš„è¿æ¥ï¼Œå›æ”¶è¿æ¥æ± ä¸­è¢«å…³é—­çš„è¿æ¥ã€‚å®ƒä¹Ÿå¯ä»¥é€‰æ‹©æ€§çš„è°ƒç”¨ ClientConnectionManager ç±»çš„ closeIdleConnections() æ–¹æ³•æ¥å…³é—­ä¸€æ®µæ—¶é—´å†…ä¸æ´»åŠ¨çš„è¿æ¥ã€‚

#### 2.4 destroy

```
@Override
public void destroy() {
    // çˆ¶ç±»é”€æ¯
    super.destroy();

    // å…³é—­ ConnectionMonitor
    if (connectionMonitor != null) {
        connectionMonitor.shutdown();
    }

    // å…³é—­æœåŠ¡å™¨
    for (Map.Entry<String, RestServer> entry : servers.entrySet()) {
        try {
            if (logger.isInfoEnabled()) {
                logger.info("Closing the rest server at " + entry.getKey());
            }
            entry.getValue().stop();
        } catch (Throwable t) {
            logger.warn("Error closing rest server", t);
        }
    }
    servers.clear();

    // å…³é—­å®¢æˆ·ç«¯
    if (logger.isInfoEnabled()) {
        logger.info("Closing rest clients");
    }
    for (ResteasyClient client : clients) {
        try {
            client.close();
        } catch (Throwable t) {
            logger.warn("Error closing rest client", t);
        }
    }
    clients.clear();
}
```

## 3. Server

#### 3.1 RestServer

[`com.alibaba.dubbo.rpc.protocol.rest.RestServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestServer.java) ï¼ŒRest Server æ¥å£ã€‚æ–¹æ³•å¦‚ä¸‹ï¼š

```
public interface RestServer {

    /**
     * å¯åŠ¨æœåŠ¡å™¨
     *
     * @param url URL å¯¹è±¡
     */
    void start(URL url);

    /**
     * åœæ­¢æœåŠ¡å™¨
     */
    void stop();

    /**
     * éƒ¨ç½²æœåŠ¡
     *
     * @param resourceDef æœåŠ¡ç±»
     * @param resourceInstance æœåŠ¡å¯¹è±¡
     * @param contextPath ContextPath
     */
    void deploy(Class resourceDef, Object resourceInstance, String contextPath);

    /**
     * å–æ¶ˆæœåŠ¡
     *
     * @param resourceDef æœåŠ¡ç±»
     */
    void undeploy(Class resourceDef);

}
```

- ä¸¤å¯¹æ–¹æ³•ï¼š`start(...)` å’Œ `stop()` æ–¹æ³•ï¼Œ`#deploy(...)` å’Œ `undeploy(...)` æ–¹æ³•ã€‚

#### 3.2 BaseRestServer

[`com.alibaba.dubbo.rpc.protocol.rest.BaseRestServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/BaseRestServer.java) ï¼Œå®ç° RestServer æ¥å£ï¼ŒRest Server **æŠ½è±¡åŸºç±»**ã€‚

###### 3.2.1 æŠ½è±¡æ–¹æ³•

```
protected abstract ResteasyDeployment getDeployment();

protected abstract void doStart(URL url);
```

###### 3.2.2 start

```
 1: @Override
 2: public void start(URL url) {
 3:     // æ·»åŠ  MediaType
 4:     getDeployment().getMediaTypeMappings().put("json", "application/json");
 5:     getDeployment().getMediaTypeMappings().put("xml", "text/xml");
 6: //    server.getDeployment().getMediaTypeMappings().put("xml", "application/xml");
 7:     // æ·»åŠ è¿‡æ»¤å™¨ RpcContextFilter
 8:     getDeployment().getProviderClasses().add(RpcContextFilter.class.getName());
 9:     // TODO users can override this mapper, but we just rely on the current priority strategy of resteasy
10:     // æ·»åŠ å¼‚å¸¸åŒ¹é… RpcExceptionMapper
11:     getDeployment().getProviderClasses().add(RpcExceptionMapper.class.getName());
12:     // ä» `extension` é…ç½®é¡¹ï¼Œæ·»åŠ å¯¹åº”çš„ç»„ä»¶ï¼ˆè¿‡æ»¤å™¨ Filter ã€æ‹¦æˆªå™¨ Interceptor ã€å¼‚å¸¸åŒ¹é…å™¨ ExceptionMapper ç­‰ç­‰ï¼‰
13:     loadProviders(url.getParameter(Constants.EXTENSION_KEY, ""));
14: 
15:     // å¯åŠ¨æœåŠ¡å™¨
16:     doStart(url);
17: }
```

- ç¬¬ 3 è‡³ 5 è¡Œï¼šæ·»åŠ  `json` `xml` ä¸¤ä¸ª MediaType ã€‚

- ç¬¬ 8 è¡Œï¼šæ·»åŠ è¿‡æ»¤å™¨ RpcContextFilter ã€‚è¿™ä¸ªè¿‡æ»¤å™¨ï¼Œæˆ‘ä»¬åœ¨ ResteasyClient çš„åˆå§‹åŒ–æ—¶ï¼Œä¹Ÿçœ‹åˆ°äº†ã€‚

- ç¬¬ 9 è¡Œï¼šæ·»åŠ å¼‚å¸¸åŒ¹é… RpcExceptionMapper ã€‚

- ç¬¬ 13 è¡Œï¼šè°ƒç”¨ `#loadProviders(value)` æ–¹æ³•ï¼Œä» `extension` é…ç½®é¡¹ï¼Œæ·»åŠ å¯¹åº”çš„ç»„ä»¶ï¼ˆè¿‡æ»¤å™¨ Filter ã€æ‹¦æˆªå™¨ Interceptor ã€å¼‚å¸¸åŒ¹é…å™¨ ExceptionMapper ç­‰ç­‰ï¼‰ã€‚è¿™å—ä»£ç ï¼Œä»¬åœ¨ ResteasyClient çš„åˆå§‹åŒ–æ—¶ï¼Œä¹Ÿçœ‹åˆ°äº†ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected void loadProviders(String value) {
      for (String clazz : Constants.COMMA_SPLIT_PATTERN.split(value)) {
          if (!StringUtils.isEmpty(clazz)) {
              getDeployment().getProviderClasses().add(clazz.trim());
          }
      }
  }
  ```

- ç¬¬ 16 è¡Œï¼šè°ƒç”¨ `#doStart(url)` **æŠ½è±¡**æ–¹æ³•ï¼Œå¯åŠ¨æœåŠ¡å™¨ã€‚

###### 3.2.3 deploy

```
@Override
public void deploy(Class resourceDef, Object resourceInstance, String contextPath) {
    if (StringUtils.isEmpty(contextPath)) {
        getDeployment().getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef));
    } else {
        getDeployment().getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef), contextPath);
    }
}
```

- è°ƒç”¨ `ResteasyDeployment#addResourceFactory(ResourceFactory)` æ–¹æ³•ï¼Œéƒ¨ç½² Service æœåŠ¡ã€‚è¿™é‡Œï¼Œå¦‚æœç±»æ¯” SpringMVC ï¼Œå°±æ˜¯æ·»åŠ  `@RestController` æ³¨è§£çš„ç±»ã€‚
- [`com.alibaba.dubbo.rpc.protocol.rest.DubboResourceFactory`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboResourceFactory.java) ï¼Œæ¯”è¾ƒæ˜“æ‡‚ï¼Œèƒ–å‹è‡ªå·±çœ‹å“ˆã€‚
- åˆ°äº†æ­¤å¤„ï¼Œæˆ‘ä»¬å°±å¯ä»¥çœ‹ä¸€ä¸‹ Resteasy çš„è¯·æ±‚å¤„ç†è¿‡ç¨‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

> FROM [ã€ŠRESTEASY ,ä»å­¦ä¼šä½¿ç”¨åˆ°äº†è§£åŸç†ã€‹](http://www.cnblogs.com/langtianya/p/7624647.html) *åŸºç¡€ä¸Šä¿®æ”¹*
>
> [![æµç¨‹](http://static.iocoder.cn/images/Dubbo/2018_10_19/02.png)](http://static.iocoder.cn/images/Dubbo/2018_10_19/02.png)æµç¨‹
>
> - HttpServletDispatcher ï¼šæ¥å—å¹¶åˆ†å‘å®¢æˆ·ç«¯ http è¯·æ±‚
> - ResourceFactory ï¼šè´Ÿè´£å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚çš„å¯¹è±¡ç”±è°æ¥è´Ÿè´£å¤„ç†
> - Registry ï¼š
>   - æœåŠ¡å™¨å¯åŠ¨æ—¶åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰Restèµ„æºæ—¶ï¼Œä¼šè§£æä¸Šé¢çš„æ³¨è§£ï¼Œå¹¶å°†æ³¨è§£ç›¸å¯¹è·¯å¾„å’Œè¯¥ç±»ä¸­æ‰§è¡Œçš„æ–¹æ³•å»ºç«‹å¯¹åº”å…³ç³»æ³¨å†Œåˆ° Registry ä¸­ã€‚
>   - å½“å®¢æˆ·ç«¯è¯·æ±‚è¿‡æ¥æ—¶ä¼šæ ¹æ®è¯·æ±‚ä¸­çš„ç›¸å¯¹è·¯å¾„å» Registry ä¸­æŸ¥æ‰¾å¯¹åº”çš„ Invoker å¯¹è±¡ï¼Œç„¶åæ‰§è¡Œå¹¶å°†å¤„ç†ç»“æœè¿”å›ã€‚

ğŸ™‚ æ˜¯ä¸æ˜¯ä¸€ä¸‹å­å°±æ¸…æ™°äº†ï¼Œä¸–ç•Œåˆæ˜äº®äº†ï¼Ÿï¼

###### 3.2.4 undeploy

```
@Override
public void undeploy(Class resourceDef) {
    getDeployment().getRegistry().removeRegistrations(resourceDef);
}
```

#### 3.3 NettyHttpServer

[`com.alibaba.dubbo.rpc.protocol.rest.NettyHttpServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/NettyHttpServer.java) ï¼Œå®ç° BaseRestServer æŠ½è±¡åŸºç±»ï¼ŒåŸºäº Netty çš„ HTTP æœåŠ¡å™¨å®ç°ç±»ã€‚

**æ³¨æ„**ï¼ŒNettyHttpServer ä¸æ˜¯ Servlet Container ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨ `@Context` æ³¨è§£ã€‚

###### 3.3.1 doStart

```
private final NettyJaxrsServer server = new NettyJaxrsServer();

  1: @Override
  2: protected void doStart(URL url) {
  3:     // è®¾ç½® NettyJaxrsServer çš„å±æ€§
  4:     String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
  5:     if (!url.isAnyHost() && NetUtils.isValidLocalHost(bindIp)) {
  6:         server.setHostname(bindIp); // Hostname
  7:     }
  8:     server.setPort(url.getParameter(Constants.BIND_PORT_KEY, url.getPort())); // Port
  9:     Map<ChannelOption, Object> channelOption = new HashMap<ChannelOption, Object>();
 10:     channelOption.put(ChannelOption.SO_KEEPALIVE, url.getParameter(Constants.KEEP_ALIVE_KEY, Constants.DEFAULT_KEEP_ALIVE)); // Keep-Alive
 11:     server.setChildChannelOptions(channelOption);
 12:     server.setExecutorThreadCount(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)); // æ‰§è¡Œçº¿ç¨‹æ•°
 13:     server.setIoWorkerCount(url.getParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS)); // IO çº¿ç¨‹æ•°
 14:     server.setMaxRequestSize(url.getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD)); // è¯·æ±‚æœ€å¤§é•¿åº¦
 15:     // å¯åŠ¨ NettyJaxrsServer
 16:     server.start();
 17: }
```

- `server` å±æ€§ï¼Œ **Netty4** å¯¹ Resteasy Server çš„å®ç°ã€‚
- ç¬¬ 3 è‡³ 14 è¡Œï¼šè®¾ç½® NettyJaxrsServer çš„å±æ€§ã€‚
- ç¬¬ 16 è¡Œï¼šè°ƒç”¨ `NettyJarxrsServer#start()` æ–¹æ³•ï¼Œå¯åŠ¨æœåŠ¡å™¨ã€‚

###### 3.3.2 stop

```
@Override
public void stop() {
    server.stop();
}
```

###### 3.3.3 getDeployment

```
@Override
protected ResteasyDeployment getDeployment() {
    return server.getDeployment();
}
```

#### 3.4 DubboHttpServer

[`com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboHttpServer.java) ï¼Œå®ç° BaseRestServer æŠ½è±¡åŸºç±»ï¼ŒåŸºäº `dubbo-remoting-http` çš„ HTTP æœåŠ¡å™¨å®ç°ç±»ã€‚

###### 3.4.1 æ„é€ æ–¹æ³•

```
/**
 * Resteasy HttpServletDispatcher
 */
private final HttpServletDispatcher dispatcher = new HttpServletDispatcher();
/**
 * Resteasy ResteasyDeployment
 */
private final ResteasyDeployment deployment = new ResteasyDeployment();
/**
 * Dubbo HttpBinder$Adaptive
 */
private HttpBinder httpBinder;
/**
 * HttpServer å¯¹è±¡
 */
private HttpServer httpServer;

public DubboHttpServer(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- DubboHttpServer ç›¸æ¯” NettyHttpServer çš„è¯·æ±‚æµç¨‹ä¼š**å¤æ‚**ä¸€äº›ï¼Œ`Dubbo DispatcherServlet => Dubbo RestHandler => Resteasy HttpServletDispatcher => ...` ã€‚

###### 3.4.2 doStart

```
 1: @Override
 2: protected void doStart(URL url) {
 3:     // åˆ›å»º HttpServer å¯¹è±¡ï¼Œä½¿ç”¨ RestHandler ä½œä¸ºå¤„ç†å™¨ã€‚
 4:     // TODO jetty will by default enable keepAlive so the xml config has no effect now
 5:     httpServer = httpBinder.bind(url, new RestHandler());
 6: 
 7:     // è·å¾— ServletContext å¯¹è±¡
 8:     ServletContext servletContext = ServletManager.getInstance().getServletContext(url.getPort());
 9:     if (servletContext == null) {
10:         servletContext = ServletManager.getInstance().getServletContext(ServletManager.EXTERNAL_SERVER_PORT);
11:     }
12:     if (servletContext == null) {
13:         throw new RpcException("No servlet context found. If you are using server='servlet', " +
14:                 "make sure that you've configured " + BootstrapListener.class.getName() + " in web.xml");
15:     }
16:     // è®¾ç½® ResteasyDeployment
17:     servletContext.setAttribute(ResteasyDeployment.class.getName(), deployment); // https://github.com/resteasy/Resteasy/blob/master/server-adapters/resteasy-undertow/src/main/java/org/jboss/resteasy/plugins/server/undertow/UndertowJaxrsServer.java#L74
18: 
19:     // åˆå§‹åŒ– Resteasy HttpServletDispatcher
20:     try {
21:         dispatcher.init(new SimpleServletConfig(servletContext));
22:     } catch (ServletException e) {
23:         throw new RpcException(e);
24:     }
25: }
```

- ç¬¬ 5 è¡Œï¼šè°ƒç”¨ `HttpBinder#bind(url, handler)` æ–¹æ³•ï¼Œåˆ›å»º HttpServer å¯¹è±¡ï¼Œä½¿ç”¨ RestHandler ä½œä¸ºå¤„ç†å™¨ã€‚

- ç¬¬ 7 è‡³ 17 è¡Œï¼šè·å¾— ServletContext å¯¹è±¡ï¼Œè®¾ç½® ResteasyDeployment åˆ°å±æ€§ ã€‚

  - ä¸ºä»€ä¹ˆæ˜¯ `ResteasyDeployment.class.getName()` å‘¢ï¼Ÿå‚è§ [UndertowJaxrsServer](https://github.com/resteasy/Resteasy/blob/master/server-adapters/resteasy-undertow/src/main/java/org/jboss/resteasy/plugins/server/undertow/UndertowJaxrsServer.java#L74) çš„ä»£ç ã€‚

- ç¬¬ 19 è‡³ 24 è¡Œï¼šè°ƒç”¨

   

  ```
  HttpServletDispatcher#init(ServletConfig)
  ```

   

  æ–¹æ³•ï¼Œåˆå§‹åŒ– Resteasy è°ƒåº¦å™¨ã€‚

  - [SimpleServletConfig](https://github.com/YunaiV/dubbo/blob/f83e70b53389a064e49babe32e61a5648002a44a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboHttpServer.java#L89-L120) ï¼Œä¸»è¦æ˜¯å®ç° ServletName ä¸º `"DispatcherServlet"` ã€‚

###### 3.4.3 stop

```
@Override
public void stop() {
    httpServer.close();
}
```

###### 3.4.4 getDeployment

```
@Override
protected ResteasyDeployment getDeployment() {
    return deployment;
}
```

###### 3.4.5 RestHandler

```
private class RestHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        // è®¾ç½®
        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
        // è°ƒåº¦è¯·æ±‚
        dispatcher.service(request, response);
    }

}
```

- å®ç° HttpHandler æ¥å£ã€‚
- è°ƒç”¨ `HttpServletDispatcher#service(request, response)` æ–¹æ³•ï¼Œè°ƒåº¦è¯·æ±‚ï¼Œç»™ Resteasy HttpServletDispatcher ã€‚

#### 3.5 RestServerFactory

[`com.alibaba.dubbo.rpc.protocol.rest.RestServerFactory`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestServerFactory.java) ï¼Œåˆ›å»º RestServer çš„å·¥å‚ã€‚

ğŸ™‚ ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±çœ‹çœ‹ã€‚

## 4. Filter

ğŸ˜ˆ è¿™æ˜¯ JAX-RS ä¸­çš„ Filter ï¼Œè€Œä¸æ˜¯ Dubbo çš„ Filter ã€‚

#### 4.1 RpcContextFilter

[`com.alibaba.dubbo.rpc.protocol.rest.RpcContextFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RpcContextFilter.java) ï¼Œå®ç° ContainerRequestFilter å’Œ ClientRequestFilter æ¥å£ï¼Œ**å¤„ç† RpcContext** çš„ Filter å®ç°ç±»ã€‚

- Client Filter ï¼šé€šè¿‡å°† Dubbo RpcContext Attachment ï¼Œè®¾ç½®åˆ° Http Header çš„ `Dubbo-Attachments` ä¸­ï¼Œè¯·æ±‚ä¼ é€’ç»™ Server ã€‚
- Server Filter ï¼šè§£æ Http Header çš„ `Dubbo-Attachments` ï¼Œè®¾ç½®åˆ° RpcContext Attachment ä¸­ã€‚

ğŸ™‚ ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±çœ‹çœ‹ã€‚

#### 4.2 LoggingFilter

[`com.alibaba.dubbo.rpc.protocol.rest.support.LoggingFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/support/LoggingFilter.java) ï¼Œå®ç° ContainerRequestFilter å’Œ ClientRequestFilter **ç­‰ç­‰**æ¥å£ï¼Œæ‰“å°æ—¥å¿—çš„ Filter ã€‚**ç›®å‰ä»…æ‰“å°è¯·æ±‚å’Œå“åº”çš„ Header** ã€‚

é»˜è®¤æœªä½¿ç”¨ï¼Œéœ€è¦é…ç½®ã€‚

ğŸ™‚ ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±çœ‹çœ‹ã€‚

## 5. ExceptionMapper

[`com.alibaba.dubbo.rpc.protocol.rest.ExceptionMapper`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ExceptionMapper.java) ï¼Œå®ç° `javax.ws.rs.ext.ExceptionMapper` æ¥å£ï¼ŒRPC å¼‚å¸¸åŒ¹é…å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
 1: @Override
 2: public Response toResponse(RpcException e) {
 3:     // å‚æ•°ä¸åˆæ³•ï¼Œæ‹¼æ¥è¿”å› Response
 4:     // TODO do more sophisticated exception handling and output
 5:     if (e.getCause() instanceof ConstraintViolationException) { // java validation å¼‚å¸¸
 6:         return handleConstraintViolationException((ConstraintViolationException) e.getCause());
 7:     }
 8:     // æ™®é€š Response è¿”å›
 9:     // we may want to avoid exposing the dubbo exception details to certain clients
10:     // TODO for now just do plain text output
11:     return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity("Internal server error: " + e.getMessage()).type(ContentType.TEXT_PLAIN_UTF_8).build();
12: }
```

- ç¬¬ 3 è‡³ 7 è¡Œï¼šå½“ Java Validation æ ¡éªŒå‘ç°å‚æ•°ä¸åˆæ³•æ—¶ï¼Œè°ƒç”¨ `#handleConstraintViolationException(ConstraintViolationException)` æ–¹æ³•ï¼Œå¤„ç†å‚æ•°ä¸åˆæ³•çš„å¼‚å¸¸ï¼Œæ‹¼æ¥è¿”å› Response ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  protected Response handleConstraintViolationException(ConstraintViolationException cve) {
      ViolationReport report = new ViolationReport();
      for (ConstraintViolation cv : cve.getConstraintViolations()) {
          report.addConstraintViolation(new RestConstraintViolation(
                  cv.getPropertyPath().toString(),
                  cv.getMessage(),
                  cv.getInvalidValue() == null ? "null" : cv.getInvalidValue().toString()));
      }
      // TODO for now just do xml output
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.TEXT_XML_UTF_8).build();
  }
  ```

  - æˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªè¯·æ±‚å¯ä»¥æœ‰å¤šä¸ªå‚æ•°ï¼Œå› æ­¤ï¼Œå¯ä»¥æœ‰å¤šä¸ªçº¦æŸæ¡ä»¶ï¼Œæ‰€ä»¥å¯ä»¥è¿åå¤šä¸ªã€‚
  - [`com.alibaba.dubbo.rpc.protocol.rest.ViolationReport`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ViolationReport.java) ï¼ŒRestConstraintViolation çš„é›†åˆã€‚
  - [`com.alibaba.dubbo.rpc.protocol.rest.RestConstraintViolation`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestConstraintViolation.java) ï¼Œ**ä¸€æ¡**ä¸ç¬¦åˆçº¦æŸ ã€‚
  - ç›®å‰ï¼Œä»…è¿”å› XML æ ¼å¼ã€‚å¦‚æœèƒ–å‹éœ€è¦ JSON æ ¼å¼ï¼Œå¯ä»¥è‡ªå·±æ‹“å±•è®¾ç½®ã€‚

- ç¬¬ 11 è¡Œï¼šæ™®é€š Response è¿”å›ã€‚

## 6. ContentType

[`com.alibaba.dubbo.rpc.protocol.rest.ContentType`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ContentType.java) ï¼ŒContentType æšä¸¾ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
public class ContentType {

    public static final String APPLICATION_JSON_UTF_8 = MediaType.APPLICATION_JSON + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";
    public static final String TEXT_XML_UTF_8 = MediaType.TEXT_XML + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";
    public static final String TEXT_PLAIN_UTF_8 = MediaType.TEXT_PLAIN + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";

}
```

# è¿œç¨‹è°ƒç”¨-WebService(rmi)

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `rmi://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸‰ä¸ªéƒ¨åˆ†**ï¼š

- æœåŠ¡æš´éœ²
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-rmi` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” rmi://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> RMI åè®®é‡‡ç”¨ JDK æ ‡å‡†çš„ `java.rmi.*` å®ç°ï¼Œé‡‡ç”¨é˜»å¡å¼çŸ­è¿æ¥å’Œ JDK æ ‡å‡†åºåˆ—åŒ–æ–¹å¼ã€‚

æœ¬æ–‡æ¶‰åŠç±»å›¾ï¼ˆçº¢åœˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š

[![ç±»å›¾](http://static.iocoder.cn/images/Dubbo/2018_10_22/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_22/01.png)ç±»å›¾

> æ—ç™½å›ï¼šæ•´ä½“å®ç°å’Œ `dubbo-rpc-http` ä¸€è‡´ï¼Œæ‰€ä»¥å†…å®¹ä¸Šå’Œ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡è°ƒç”¨ï¼ˆä¸‰ï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆHTTPï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/rpc-http/?self) å·®ä¸å¤šã€‚

## 2. RmiRemoteInvocation

```
public class RmiRemoteInvocation extends RemoteInvocation {

    private static final long serialVersionUID = 1L;

    private static final String dubboAttachmentsAttrName = "dubbo.attachments";

    /**
     * executed on consumer side
     *
     * æ„é€ å°†åœ¨æ¶ˆè´¹ç«¯æ‰§è¡Œ
     */
    public RmiRemoteInvocation(MethodInvocation methodInvocation) {
        super(methodInvocation);
        addAttribute(dubboAttachmentsAttrName, new HashMap<String, String>(RpcContext.getContext().getAttachments()));
    }

    /**
     * Need to restore context on provider side (Though context will be overridden by Invocation's attachment
     * when ContextFilter gets executed, we will restore the attachment when Invocation is constructed, check more
     * from {@link com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler}
     *
     * æœåŠ¡ç«¯æ‰§è¡Œæ—¶ï¼Œé‡æ–°æ”¾å…¥ä¸Šä¸‹æ–‡ï¼ˆè™½ç„¶è¿™æ—¶ä¸Šä¸‹æ–‡åœ¨ContextFilteræ‰§è¡Œæ—¶å°†è¢«Invocationçš„attachmentsè¦†ç›–ï¼Œæˆ‘ä»¬åœ¨Invocationæ„é€ æ—¶è¿˜åŸattachments, see InvokerInvocationHandlerï¼‰
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object invoke(Object targetObject) throws NoSuchMethodException, IllegalAccessException,
            InvocationTargetException {
        RpcContext context = RpcContext.getContext();
        context.setAttachments((Map<String, String>) getAttribute(dubboAttachmentsAttrName));
        try {
            return super.invoke(targetObject);
        } finally {
            context.setAttachments(null);
        }
    }
}
```

## 3. RmiProtocol

[`com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java) ï¼Œå®ç° AbstractProxyProtocol æŠ½è±¡ç±»ï¼Œ`rmi://` åè®®å®ç°ç±»ã€‚

#### 3.1 æ„é€ æ–¹æ³•

```
/**
 * é»˜è®¤ç«¯å£
 */
public static final int DEFAULT_PORT = 1099;

public RmiProtocol() {
    super(RemoteAccessException.class, RemoteException.class);
}

public int getDefaultPort() {
    return DEFAULT_PORT;
}
```

- `rpcExceptions = RemoteAccessException.class, RemoteException.class` ã€‚
- ğŸ™‚ è‰¿è‰¿å¯¹ RMIäº†è§£ä¸å¤šï¼Œæ‰€ä»¥æœ¬æ–‡æ›´å¤šæ¢³ç†å¥½æ•´ä½“è„‰ç»œã€‚

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {
 3:     // åˆ›å»º RmiServiceExporter å¯¹è±¡
 4:     final RmiServiceExporter rmiServiceExporter = new RmiServiceExporter();
 5:     rmiServiceExporter.setRegistryPort(url.getPort());
 6:     rmiServiceExporter.setServiceName(url.getPath());
 7:     rmiServiceExporter.setServiceInterface(type);
 8:     rmiServiceExporter.setService(impl);
 9:     try {
10:         rmiServiceExporter.afterPropertiesSet();
11:     } catch (RemoteException e) {
12:         throw new RpcException(e.getMessage(), e);
13:     }
14:     // è¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnable
15:     return new Runnable() {
16:         public void run() {
17:             try {
18:                 rmiServiceExporter.destroy();
19:             } catch (Throwable e) {
20:                 logger.warn(e.getMessage(), e);
21:             }
22:         }
23:     };
24: }
```

- ç¬¬ 3 è‡³ 13 è¡Œï¼šåˆ›å»º RmiServiceExporter å¯¹è±¡ã€‚
- ç¬¬ 14 è‡³ 23 è¡Œï¼šè¿”å›å–æ¶ˆæš´éœ²çš„å›è°ƒ Runnableã€‚

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // åˆ›å»º RmiProxyFactoryBean å¯¹è±¡
 5:     final RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();
 6:     // RMI needs extra parameter since it uses customized remote invocation object
 7:     // RMIä¼ è¾“æ—¶ä½¿ç”¨è‡ªå®šä¹‰çš„è¿œç¨‹æ‰§è¡Œå¯¹è±¡ï¼Œä»è€Œä¼ é€’é¢å¤–çš„å‚æ•°
 8:     if (url.getParameter(Constants.DUBBO_VERSION_KEY, Version.getVersion()).equals(Version.getVersion())) {
 9:         // Check dubbo version on provider, this feature only support
10:         rmiProxyFactoryBean.setRemoteInvocationFactory(new RemoteInvocationFactory() {
11:             public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {
12:                 return new RmiRemoteInvocation(methodInvocation);
13:             }
14:         });
15:     }
16:     // è®¾ç½®ç›¸å…³å‚æ•°
17:     rmiProxyFactoryBean.setServiceUrl(url.toIdentityString());
18:     rmiProxyFactoryBean.setServiceInterface(serviceType);
19:     rmiProxyFactoryBean.setCacheStub(true);
20:     rmiProxyFactoryBean.setLookupStubOnStartup(true);
21:     rmiProxyFactoryBean.setRefreshStubOnConnectFailure(true);
22:     rmiProxyFactoryBean.afterPropertiesSet();
23:     // åˆ›å»º Service Proxy å¯¹è±¡
24:     return (T) rmiProxyFactoryBean.getObject();
25: }
```

- ç¬¬ 5 è¡Œï¼šåˆ›å»º RmiProxyFactoryBean å¯¹è±¡ã€‚
- ç¬¬ 8 è‡³ 15 è¡Œï¼šè‹¥è¿œç¨‹æœåŠ¡æ˜¯ Dubbo RMI æœåŠ¡æ—¶ï¼ŒRMI ä¼ è¾“æ—¶ä½¿ç”¨è‡ªå®šä¹‰çš„è¿œç¨‹æ‰§è¡Œå¯¹è±¡ï¼Œä»è€Œä¼ é€’é¢å¤–çš„å‚æ•°ã€‚
- ç¬¬ 16 è‡³ 22 è¡Œï¼šè®¾ç½®ç›¸å…³å‚æ•°ã€‚å¦å¤–ï¼Œdubbo é…ç½®ä¸­çš„è¶…æ—¶æ—¶é—´å¯¹ RMI æ— æ•ˆï¼Œéœ€ä½¿ç”¨ java å¯åŠ¨å‚æ•°è®¾ç½® `-Dsun.rmi.transport.tcp.responseTimeout=3000` ï¼Œå‚è§ä¸‹é¢çš„ RMI é…ç½®
- ç¬¬ 24 è¡Œï¼šåˆ›å»º Service Proxy å¯¹è±¡ã€‚

###### 3.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof RemoteAccessException) {
        e = e.getCause();
    }
    if (e != null && e.getCause() != null) {
        Class<?> cls = e.getCause().getClass();
        if (SocketTimeoutException.class.equals(cls)) {
            return RpcException.TIMEOUT_EXCEPTION;
        } else if (IOException.class.isAssignableFrom(cls)) {
            return RpcException.NETWORK_EXCEPTION;
        } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {
            return RpcException.SERIALIZATION_EXCEPTION;
        }
    }
    return super.getErrorCode(e);
}
```

- å°†å¼‚å¸¸ï¼Œç¿»è¯‘æˆ Dubbo å¼‚å¸¸ç ã€‚

# è¿œç¨‹è°ƒç”¨-Redis

## 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬åˆ†äº« `redis://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸¤ä¸ªä¸ªéƒ¨åˆ†**ï¼š

- ~~æœåŠ¡æš´éœ²~~
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-redis` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” redis://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/redis.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> åŸºäº Redis å®ç°çš„ RPC åè®®ã€‚

ç®€å•çš„è¯´ï¼Œé€šè¿‡ Dubbo Service çš„è°ƒç”¨æ–¹å¼ï¼Œ**é€æ˜åŒ–**å¯¹ Redis çš„è®¿é—®ã€‚
è¿™æ ·ï¼Œå¦‚æœæœªæ¥å¸Œæœ›ï¼Œä¿®æ”¹ç¼“å­˜çš„è§£å†³æ–¹æ¡ˆï¼Œä¸ç”¨ä¿®æ”¹ä»£ç ï¼Œè€Œåªè¦ä¿®æ”¹ Dubbo Service çš„é…ç½®ã€‚
å°±å¥½åƒï¼ŒJava JDBC API æœ‰ MySQL JDBC ã€Oracle JDBC ç­‰å¤šç§å®ç°ï¼Œåªéœ€è¦ä¿®æ”¹å¯¹åº”çš„ JDBC é©±åŠ¨å®ç°ç±»ï¼Œå°±å¯ä»¥è¿æ¥ä¸Šä¸åŒçš„æ•°æ®åº“ã€‚

å¦å¤–ï¼ŒDubbo æä¾› `memcached://` åè®®ï¼Œå’Œ `redis://` å¯¹ç­‰ï¼Œå·®åˆ«ç‚¹åœ¨å‰è€…ä½¿ç”¨ Memcached ï¼Œåè€…ä½¿ç”¨ Redis ã€‚

## 2. RedisProtocol

[`com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java) ï¼Œå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼Œ`redis://` åè®®å®ç°ç±»ã€‚

#### 2.1 export

```
@Override
public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
    throw new UnsupportedOperationException("Unsupported export redis service. url: " + invoker.getUrl());
}
```

å®é™…è®¿é—®çš„å°±æ˜¯ Redis Server å®ä¾‹ï¼Œå› æ­¤æ— éœ€è¿›è¡Œ Dubbo æœåŠ¡æš´éœ²ã€‚å®¢æˆ·ç«¯é…ç½®å¼•ç”¨æ–¹å¼å¦‚ä¸‹ï¼š

> åœ¨å®¢æˆ·ç«¯ä½¿ç”¨ï¼Œæ³¨å†Œä¸­å¿ƒè¯»å–ï¼š
> `<dubbo:reference id="store" interface="java.util.Map" group="member" />`
>
> æˆ–è€…ï¼Œç‚¹å¯¹ç‚¹ç›´è¿ï¼š
> `<dubbo:reference id="store" interface="java.util.Map" url="redis://10.20.153.10:6379"`

#### 2.2 refer

```
  1: @Override
  2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
  3:     try {
  4:         // åˆ›å»º GenericObjectPoolConfig å¯¹è±¡ï¼Œè®¾ç½®é…ç½®
  5:         GenericObjectPoolConfig config = new GenericObjectPoolConfig();
  6:         config.setTestOnBorrow(url.getParameter("test.on.borrow", true));
  7:         config.setTestOnReturn(url.getParameter("test.on.return", false));
  8:         config.setTestWhileIdle(url.getParameter("test.while.idle", false));
  9:         if (url.getParameter("max.idle", 0) > 0)
 10:             config.setMaxIdle(url.getParameter("max.idle", 0));
 11:         if (url.getParameter("min.idle", 0) > 0)
 12:             config.setMinIdle(url.getParameter("min.idle", 0));
 13:         if (url.getParameter("max.active", 0) > 0)
 14:             config.setMaxTotal(url.getParameter("max.active", 0));
 15:         if (url.getParameter("max.total", 0) > 0)
 16:             config.setMaxTotal(url.getParameter("max.total", 0));
 17:         if (url.getParameter("max.wait", 0) > 0)
 18:             config.setMaxWaitMillis(url.getParameter("max.wait", 0));
 19:         if (url.getParameter("num.tests.per.eviction.run", 0) > 0)
 20:             config.setNumTestsPerEvictionRun(url.getParameter("num.tests.per.eviction.run", 0));
 21:         if (url.getParameter("time.between.eviction.runs.millis", 0) > 0)
 22:             config.setTimeBetweenEvictionRunsMillis(url.getParameter("time.between.eviction.runs.millis", 0));
 23:         if (url.getParameter("min.evictable.idle.time.millis", 0) > 0)
 24:             config.setMinEvictableIdleTimeMillis(url.getParameter("min.evictable.idle.time.millis", 0));
 25:         // åˆ›å»º JedisPool å¯¹è±¡
 26:         final JedisPool jedisPool = new JedisPool(config, url.getHost(), url.getPort(DEFAULT_PORT),
 27:                 url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
 28: 
 29:         // å¤„ç†æ–¹æ³•åçš„æ˜ å°„
 30:         final int expiry = url.getParameter("expiry", 0);
 31:         final String get = url.getParameter("get", "get");
 32:         final String set = url.getParameter("set", Map.class.equals(type) ? "put" : "set");
 33:         final String delete = url.getParameter("delete", Map.class.equals(type) ? "remove" : "delete");
 34: 
 35:         // åˆ›å»º Invoker å¯¹è±¡
 36:         return new AbstractInvoker<T>(type, url) {
 37: 
 38:             @Override
 39:             protected Result doInvoke(Invocation invocation) {
 40:                 Jedis resource = null;
 41:                 try {
 42:                     // è·å¾— Redis Resource
 43:                     resource = jedisPool.getResource();
 44:                     // Redis get æŒ‡ä»¤
 45:                     if (get.equals(invocation.getMethodName())) {
 46:                         if (invocation.getArguments().length != 1) {
 47:                             throw new IllegalArgumentException("The redis get method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 48:                         }
 49:                         // è·å¾—å€¼
 50:                         byte[] value = resource.get(String.valueOf(invocation.getArguments()[0]).getBytes());
 51:                         if (value == null) {
 52:                             return new RpcResult();
 53:                         }
 54:                         // ååºåˆ—åŒ–
 55:                         ObjectInput oin = getSerialization(url).deserialize(url, new ByteArrayInputStream(value));
 56:                         // è¿”å›ç»“æœ
 57:                         return new RpcResult(oin.readObject());
 58:                     // Redis set/put æŒ‡ä»¤
 59:                     } else if (set.equals(invocation.getMethodName())) {
 60:                         if (invocation.getArguments().length != 2) {
 61:                             throw new IllegalArgumentException("The redis set method arguments mismatch, must be two arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 62:                         }
 63:                         // åºåˆ—åŒ–
 64:                         byte[] key = String.valueOf(invocation.getArguments()[0]).getBytes();
 65:                         ByteArrayOutputStream output = new ByteArrayOutputStream();
 66:                         ObjectOutput value = getSerialization(url).serialize(url, output);
 67:                         value.writeObject(invocation.getArguments()[1]);
 68:                         // è®¾ç½®å€¼
 69:                         resource.set(key, output.toByteArray());
 70:                         if (expiry > 1000) {
 71:                             resource.expire(key, expiry / 1000);
 72:                         }
 73:                         // è¿”å›ç»“æœ
 74:                         return new RpcResult();
 75:                     } else if (delete.equals(invocation.getMethodName())) {
 76:                         if (invocation.getArguments().length != 1) {
 77:                             throw new IllegalArgumentException("The redis delete method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 78:                         }
 79:                         // åˆ é™¤å€¼
 80:                         resource.del(String.valueOf(invocation.getArguments()[0]).getBytes());
 81:                         // è¿”å›ç»“æœ
 82:                         return new RpcResult();
 83:                     } else {
 84:                         throw new UnsupportedOperationException("Unsupported method " + invocation.getMethodName() + " in redis service.");
 85:                     }
 86:                 } catch (Throwable t) {
 87:                     RpcException re = new RpcException("Failed to invoke redis service method. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url + ", cause: " + t.getMessage(), t);
 88:                     if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {
 89:                         re.setCode(RpcException.TIMEOUT_EXCEPTION);
 90:                     } else if (t instanceof JedisConnectionException || t instanceof IOException) {
 91:                         re.setCode(RpcException.NETWORK_EXCEPTION);
 92:                     } else if (t instanceof JedisDataException) {
 93:                         re.setCode(RpcException.SERIALIZATION_EXCEPTION);
 94:                     }
 95:                     throw re;
 96:                 } finally {
 97:                     // å½’è¿˜ Redis Resource
 98:                     if (resource != null) {
 99:                         try {
100:                             jedisPool.returnResource(resource);
101:                         } catch (Throwable t) {
102:                             logger.warn("returnResource error: " + t.getMessage(), t);
103:                         }
104:                     }
105:                 }
106:             }
107: 
108:             @Override
109:             public void destroy() {
110:                 // æ ‡è®°é”€æ¯
111:                 super.destroy();
112:                 // é”€æ¯ Redis Pool
113:                 try {
114:                     jedisPool.destroy();
115:                 } catch (Throwable e) {
116:                     logger.warn(e.getMessage(), e);
117:                 }
118:             }
119: 
120:         };
121:     } catch (Throwable t) {
122:         throw new RpcException("Failed to refer redis service. interface: " + type.getName() + ", url: " + url + ", cause: " + t.getMessage(), t);
123:     }
124: }
```

- ä½¿ç”¨ Jedis è®¿é—® Redis Server ã€‚

- ç¬¬ 4 è‡³ 24 è¡Œï¼šåˆ›å»º GenericObjectPoolConfig å¯¹è±¡ï¼Œä» Dubbo URL ä¸­è¯»å–ç›¸å…³é…ç½®ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸ºä»€ä¹ˆ Dubbo çš„é…ç½®ç±»ä¸­ï¼Œæœ‰ `arguments` å±æ€§äº†ã€‚å¯ä»¥ä½¿ç”¨å®ƒï¼Œå®ç°ä¸åŒ Protocol åè®®çš„è‡ªå®šä¹‰å±æ€§ã€‚

- ç¬¬ 25 è‡³ 27 è¡Œï¼šåˆ›å»º JedisPool å¯¹è±¡ã€‚

- ç¬¬ 29 è‡³ 33 è¡Œï¼šå¤„ç†æ–¹æ³•åçš„æ˜ å°„ã€‚

  > å¦‚æœæ–¹æ³•åå’Œ redis çš„æ ‡å‡†æ–¹æ³•åä¸ç›¸åŒï¼Œåˆ™éœ€è¦é…ç½®æ˜ å°„å…³ç³»ï¼š
  > `<dubbo:reference id="cache" interface="com.foo.CacheService" url="memcached://10.20.153.10:11211" p:set="putFoo" p:get="getFoo" p:delete="removeFoo" />`

  - å½“å¯¹åº”çš„æœåŠ¡æ¥å£æ˜¯ `java.util.Map` æ—¶ï¼Œå¯¹åº”çš„ Redis æ•°æ®ç»“æ„ä¸º **Map** ã€‚

- ç¬¬ 35 è‡³ 120 è¡Œï¼šåˆ›å»º Invoker å¯¹è±¡ã€‚

###### 2.2.1 doInvoke

- ç¬¬ 43 è¡Œï¼šè·å¾— Redis Resource å¯¹è±¡ã€‚
- ç¬¬ 44 è‡³ 57 è¡Œï¼šRedis **get** æŒ‡ä»¤ã€‚
- ç¬¬ 58 è‡³ 74 è¡Œï¼šRedis **set/put** æŒ‡ä»¤ã€‚
- ç¬¬ 75 è‡³ 83 è¡Œï¼šRedis **delete/remove** æŒ‡ä»¤ã€‚
- ç¬¬ 84 è‡³ 85 è¡Œï¼šç›®å‰å…¶ä»–å‘½ä»¤ï¼Œæš‚æ—¶ä¸æ”¯æŒã€‚
- ç¬¬ 86 è‡³ 95 è¡Œï¼šç¿»è¯‘å¼‚å¸¸æˆ Dubbo é”™è¯¯ç ã€‚
- ç¬¬ 97 è‡³ 105 è¡Œï¼šå½’è¿˜ Redis Resource å¯¹è±¡ã€‚

###### 2.2.2 destroy

- ç¬¬ 111 è¡Œï¼šè°ƒç”¨ `super#destroy()` æ–¹æ³•ï¼Œæ ‡è®°é”€æ¯ã€‚
- ç¬¬ 112 è‡³ 117 è¡Œï¼šè°ƒç”¨ `JedisPool#destroy()` æ–¹æ³•ï¼Œé”€æ¯ Redis Pool ã€‚

# è¿œç¨‹è°ƒç”¨-Memcached

## 1. æ¦‚è¿°

æœ¬æ–‡æ¥ [ã€Šç²¾å°½ Dubbo æºç åˆ†æ â€”â€” æœåŠ¡è°ƒç”¨ï¼ˆå…«ï¼‰ä¹‹è¿œç¨‹è°ƒç”¨ï¼ˆRedisï¼‰ã€‹](http://svip.iocoder.cn/Dubbo/rpc-redis/?self) ï¼Œæˆ‘ä»¬åˆ†äº« `memcached://` åè®®çš„è¿œç¨‹è°ƒç”¨ï¼Œä¸»è¦åˆ†æˆ**ä¸¤ä¸ªä¸ªéƒ¨åˆ†**ï¼š

- ~~æœåŠ¡æš´éœ²~~
- æœåŠ¡å¼•ç”¨
- æœåŠ¡è°ƒç”¨

å¯¹åº”é¡¹ç›®ä¸º `dubbo-rpc-memcached` ã€‚

å¯¹åº”æ–‡æ¡£ä¸º [ã€ŠDubbo ç”¨æˆ·æŒ‡å— â€”â€” memcached://ã€‹](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/memcached.html) ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

> åŸºäº Memcached å®ç°çš„ RPC åè®®ã€‚

## 2. MemcachedProtocol

[`com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-memcached/src/main/java/com/alibaba/dubbo/rpc/protocol/memcached/MemcachedProtocol.java) ï¼Œå®ç° AbstractProtocol æŠ½è±¡ç±»ï¼Œ`memcached://` åè®®å®ç°ç±»ã€‚

#### 2.1 export

```
@Override
public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
    throw new UnsupportedOperationException("Unsupported export redis service. url: " + invoker.getUrl());
}
```

å®é™…è®¿é—®çš„å°±æ˜¯ Memcached Server å®ä¾‹ï¼Œå› æ­¤æ— éœ€è¿›è¡Œ Dubbo æœåŠ¡æš´éœ²ã€‚å®¢æˆ·ç«¯é…ç½®å¼•ç”¨æ–¹å¼å¦‚ä¸‹ï¼š

> åœ¨å®¢æˆ·ç«¯ä½¿ç”¨ï¼Œæ³¨å†Œä¸­å¿ƒè¯»å–ï¼š
> `<dubbo:reference id="store" interface="java.util.Map" group="member" />`
>
> æˆ–è€…ï¼Œç‚¹å¯¹ç‚¹ç›´è¿ï¼š
> `<dubbo:reference id="store" interface="java.util.Map" url="memcached://10.20.153.10:11211"`

#### 2.2 refer

```
 1: @Override
 2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
 3:     try {
 4:         // åˆ›å»º MemcachedClient å¯¹è±¡
 5:         String address = url.getAddress();
 6:         String backup = url.getParameter(Constants.BACKUP_KEY);
 7:         if (backup != null && backup.length() > 0) {
 8:             address += "," + backup;
 9:         }
10:         MemcachedClientBuilder builder = new XMemcachedClientBuilder(AddrUtil.getAddresses(address));
11:         final MemcachedClient memcachedClient = builder.build();
12: 
13:         // å¤„ç†æ–¹æ³•åçš„æ˜ å°„
14:         final int expiry = url.getParameter("expiry", 0);
15:         final String get = url.getParameter("get", "get");
16:         final String set = url.getParameter("set", Map.class.equals(type) ? "put" : "set");
17:         final String delete = url.getParameter("delete", Map.class.equals(type) ? "remove" : "delete");
18:         return new AbstractInvoker<T>(type, url) {
19: 
20:             @Override
21:             protected Result doInvoke(Invocation invocation) throws Throwable {
22:                 try {
23:                     // Memcached get æŒ‡ä»¤
24:                     if (get.equals(invocation.getMethodName())) {
25:                         if (invocation.getArguments().length != 1) {
26:                             throw new IllegalArgumentException("The memcached get method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
27:                         }
28:                         return new RpcResult(memcachedClient.get(String.valueOf(invocation.getArguments()[0])));
29:                     // Memcached set æŒ‡ä»¤
30:                     } else if (set.equals(invocation.getMethodName())) {
31:                         if (invocation.getArguments().length != 2) {
32:                             throw new IllegalArgumentException("The memcached set method arguments mismatch, must be two arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
33:                         }
34:                         memcachedClient.set(String.valueOf(invocation.getArguments()[0]), expiry, invocation.getArguments()[1]);
35:                         return new RpcResult();
36:                     // Memcached delele æŒ‡ä»¤
37:                     } else if (delete.equals(invocation.getMethodName())) {
38:                         if (invocation.getArguments().length != 1) {
39:                             throw new IllegalArgumentException("The memcached delete method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
40:                         }
41:                         memcachedClient.delete(String.valueOf(invocation.getArguments()[0]));
42:                         return new RpcResult();
43:                     // ä¸æ”¯æŒçš„æŒ‡ä»¤ï¼ŒæŠ›å‡ºå¼‚å¸¸
44:                     } else {
45:                         throw new UnsupportedOperationException("Unsupported method " + invocation.getMethodName() + " in memcached service.");
46:                     }
47:                 } catch (Throwable t) {
48:                     RpcException re = new RpcException("Failed to invoke memcached service method. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url + ", cause: " + t.getMessage(), t);
49:                     if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {
50:                         re.setCode(RpcException.TIMEOUT_EXCEPTION);
51:                     } else if (t instanceof MemcachedException || t instanceof IOException) {
52:                         re.setCode(RpcException.NETWORK_EXCEPTION);
53:                     }
54:                     throw re;
55:                 }
56:             }
57: 
58:             @Override
59:             public void destroy() {
60:                 // æ ‡è®°é”€æ¯
61:                 super.destroy();
62:                 // å…³é—­ MemcachedClient
63:                 try {
64:                     memcachedClient.shutdown();
65:                 } catch (Throwable e) {
66:                     logger.warn(e.getMessage(), e);
67:                 }
68:             }
69: 
70:         };
71:     } catch (Throwable t) {
72:         throw new RpcException("Failed to refer memcached service. interface: " + type.getName() + ", url: " + url + ", cause: " + t.getMessage(), t);
73:     }
74: }
```

- ç¬¬ 4 è‡³ 11 è¡Œï¼šåˆ›å»º MemcachedClient å¯¹è±¡ã€‚
- ç¬¬ 13 è‡³ 17 è¡Œï¼šå¤„ç†æ–¹æ³•åçš„æ˜ å°„ã€‚æ­¤å¤„æœ‰ä¸ªé—®é¢˜ï¼ŒMemcached ä¸å­˜åœ¨ Map æ•°æ®ç»“æ„ï¼Œå› æ­¤ä¸å­˜åœ¨ put å’Œ remove æŒ‡ä»¤ã€‚
- ç¬¬ 18 è‡³ 73 è¡Œï¼šåˆ›å»º Invoker å¯¹è±¡ã€‚

###### 2.2.1 doInvoke

- ç¬¬ 23 è‡³ 28 è¡Œï¼šMemcached **get** æŒ‡ä»¤ã€‚
- ç¬¬ 29 è‡³ 35 è¡Œï¼šMemcached **set** æŒ‡ä»¤ã€‚
- ç¬¬ 36 è‡³ 42 è¡Œï¼šMemcached **delete** æŒ‡ä»¤ã€‚
- ç¬¬ 43 è‡³ 46 è¡Œï¼šç›®å‰å…¶ä»–å‘½ä»¤ï¼Œæš‚æ—¶ä¸æ”¯æŒã€‚
- ç¬¬ 47 è‡³ 55 è¡Œï¼šç¿»è¯‘å¼‚å¸¸æˆ Dubbo é”™è¯¯ç ã€‚

###### 2.2.2 destroy

- ç¬¬ 61 è¡Œï¼šè°ƒç”¨ `super#destroy()` æ–¹æ³•ï¼Œæ ‡è®°é”€æ¯ã€‚
- ç¬¬ 63 è‡³ 67 è¡Œï¼šè°ƒç”¨ `Memcached#shutdown()` æ–¹æ³•ï¼Œå…³é—­ MemcachedClient ã€‚