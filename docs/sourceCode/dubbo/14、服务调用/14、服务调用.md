# 本地调用

## 1. 概述

从这篇文章开始，我们开始分享**服务调用**的实现。在前面，艿艿已经写了服务：

- 本地暴露、远程暴露
- 本地引用、远程引用

那么在服务调用，必然也是分：

- 本地调用
- 远程调用

本文分享**本地调用**，在 `dubbo-rpc-injvm` 模块实现。

相比远程调用，实现上会简单很多：因为调用的服务，就在本地进程内，且不存在多个，所以不需要**集群容错**和**网络通信**相关的功能。

## 2. 调试环境

> 友情提示：笔者建议胖友先尝试自己搭建本地调用的调试环境，如果碰到问题在看本小节。

基于 `dubbo-demo-consumer` 改造：

1、将 `dubbo-demo-provider` 模块的 `com.alibaba.dubbo.demo.provider.DemoServiceImpl` 类，复制到 `dubbo-demo-consumer` 模块的 `com.alibaba.dubbo.demo.consumer` 包下。

2、在 `resources/META-INF/spring` 目录下，新建 `dubbo-demo-injvm.xml` 文件，内容如下：

```
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">

    <dubbo:application name="demo-injvm"/>

    <dubbo:registry address="N/A"/>

    <dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" protocol="injvm" scope="local" />

    <bean id="demoServiceImpl" class="com.alibaba.dubbo.demo.consumer.DemoServiceImpl"/>
    <dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoServiceImpl" protocol="injvm" scope="local" />

</beans>
```

3、修改 `com.alibaba.dubbo.demo.consumer.Consumer` 类，加载的 Spring 配置文件为 `dubbo-demo-injvm.xml` ，代码如下：

```
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{"META-INF/spring/dubbo-demo-injvm.xml"});
```

4、启动 Consumer ，即可开始调试。

------

[`dubbo-demo-consumer`](https://github.com/YunaiV/dubbo/tree/f14e4e4fffaede31cbece589e0f543ec6669b2ae/dubbo-demo/dubbo-demo-consumer) ，是笔者改完，可运行的一个快照版本。

## 3. 顺序图

- 消费者调用服务的顺序图：![消费者调用服务的顺序图](http://static.iocoder.cn/images/Dubbo/2018_10_01/01.png)
- 提供者提供服务的顺序图：![提供者提供服务的顺序图](http://static.iocoder.cn/images/Dubbo/2018_10_01/02.png)

🙂 流程上还是比较简单的，笔者就不哔哔了。如果胖友不太理解，可以回看之前的文章，再多多调试理解，或者知识星球发帖一起讨论。

下面，我们来看每个步骤的实现代码。

## 4. 消费者调用服务

#### 4.1 Proxy

> 提示：对应图中 [1] [2] [3]

见 [《精尽 Dubbo 源码分析 —— 动态代理（一）之 Javassist》](http://svip.iocoder.cn/Dubbo/proxy-javassist/?self) 文章。

#### 4.2 ProtocolFilterWrapper

> 提示：对应图中 [5]

ProtocolFilterWrapper 的带有过滤链的 Invoker ，整个调用过程和 J2EE FilterChain 是一致的，具体每个 Dubbo Filter 的实现，我们另开文章。

```
for (int i = filters.size() - 1; i >= 0; i--) {
    final Filter filter = filters.get(i);
    final Invoker<T> next = last;
    last = new Invoker<T>() {

        public Class<T> getInterface() {
            return invoker.getInterface();
        }

        public URL getUrl() {
            return invoker.getUrl();
        }

        public boolean isAvailable() {
            return invoker.isAvailable();
        }

        public Result invoke(Invocation invocation) throws RpcException {
            return filter.invoke(next, invocation);
        }

        public void destroy() {
            invoker.destroy();
        }

        @Override
        public String toString() {
            return invoker.toString();
        }
    };
}
```

`#invoke(invocation)` 方法中，调用 `Filter#(invoker, invocation)` 方法，不断执行过滤逻辑。而在 Filter 中，又不断调用 `Invoker#invoker(invocation)` 方法，最终最后一个 Filter ，会调用 `InjvmInvoker#invoke(invocation)` 方法，继续执行逻辑。

> 友情提示，InjvmInvoker 只是此处的例子，不同的协议，会调用不同的 Invoker 实现类，例如 Dubbo 协议，调用的是 DubboInvoker 。

另外，Filter 调用 Invoker 的示例如下：

```
public class DemoFilter implements Filter {

    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        return invoker.invoke(invocation); // 调用
    }
}
```

#### 4.3 ListenerInvokerWrapper

> 提示：对应图中 [6]

ListenerInvokerWrapper 类，主要目的是为了 InvokerListener 的触发，目前该监听器只有 `#referred(invoker)` `#destroyed(invoker)` 两个接口方法，并未对 `#invoke(invocation)` 的过程，实现监听。因此，ListenerInvokerWrapper 的 `#invoke(invocation)` 的实现基本等于零，代码如下：

```
@Override
public Result invoke(Invocation invocation) throws RpcException {
    return invoker.invoke(invocation);
}
```

#### 4.4 AbstractInvoker

> 提示：对应图中 [7]

AbstractInvoker ，在 `#invoke(invocation)` 方法中，实现了**公用逻辑**，同时**抽象**了 `#doInvoke(invocation)` 方法，子类实现自定义逻辑。代码如下：

```
 1: public Result invoke(Invocation inv) throws RpcException {
 2:     if (destroyed.get()) {
 3:         throw new RpcException("Rpc invoker for service " + this + " on consumer " + NetUtils.getLocalHost()
 4:                 + " use dubbo version " + Version.getVersion()
 5:                 + " is DESTROYED, can not be invoked any more!");
 6:     }
 7:     RpcInvocation invocation = (RpcInvocation) inv;
 8:     // 设置 `invoker` 属性
 9:     invocation.setInvoker(this);
10:     // 添加公用的隐式传参，例如，`path` `interface` 等等，详见 RpcInvocation 类。
11:     if (attachment != null && attachment.size() > 0) {
12:         invocation.addAttachmentsIfAbsent(attachment);
13:     }
14:     // 添加自定义的隐士传参
15:     Map<String, String> context = RpcContext.getContext().getAttachments();
16:     if (context != null) {
17:         invocation.addAttachmentsIfAbsent(context);
18:     }
19:     // 设置 `async=true` ，若为异步方法
20:     if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {
21:         invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
22:     }
23:     RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
24:
25:     // 执行调用
26:     try {
27:         return doInvoke(invocation);
28:     // TODO 【8023 biz exception】
29:     } catch (InvocationTargetException e) { // biz exception
30:         Throwable te = e.getTargetException();
31:         if (te == null) {
32:             return new RpcResult(e);
33:         } else {
34:             if (te instanceof RpcException) {
35:                 ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);
36:             }
37:             return new RpcResult(te);
38:         }
39:     } catch (RpcException e) {
40:         if (e.isBiz()) {
41:             return new RpcResult(e);
42:         } else {
43:             throw e;
44:         }
45:     } catch (Throwable e) {
46:         return new RpcResult(e);
47:     }
48: }
```

- 第 7 至 23 行：设置 `invocation` 的属性。

  - 第 9 行：设置 `invoker` 属性为自己。在上面，我们已经看到 Invoker 是层层嵌套，只要到了这里才是真正的 Invoker 对象。

  - 第 10 至 13 行：添加**公用的**的隐式传参。例如，`path` `interface` 等等。所有见 [RpcInvocation](https://github.com/apache/incubator-dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/RpcInvocation.java#L50-L76) 构造方法。从 `Invocation#addAttachmentsIfAbsent(context)` 方法，不存在才添加，因此业务上隐式传参的 KEY 不能冲突到这几个。

  - 第 14 至 18 行：添加**自定义的**隐式传参，从 `RpcContext.attachments` 中。使用 RpcContext 隐式传参需要注意：

    > 注意：RpcContext 是一个临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。
    > 比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。

  - 第 19 至 23 行：异步方法，相关的处理，后面文章分享。

- 第 27 行：调用 `#doInvoke(invocation)` **抽象**方法，实现不同协议自定义的调用实现。代码如下：

  ```
  protected abstract Result doInvoke(Invocation invocation) throws Throwable;
  ```

- 第 28 至 47 行：// TODO 【8023 biz exception】

看完这个方法，我们可以看到，一次 Dubbo RPC ，涉及到抽象模型如下图：

![RPC](http://static.iocoder.cn/images/Dubbo/2018_10_01/03.png)

#### 4.5 InjvmInvoker

> 提示：对应图中 [8]

`#doInvoke(invocation)` 实现方法，代码如下：

```
/**
 * Exporter 集合
 *
 * key: 服务键
 *
 * 该值实际就是 {@link com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap}
 */
private final Map<String, Exporter<?>> exporterMap;

  1: @Override
  2: public Result doInvoke(Invocation invocation) throws Throwable {
  3:     // 获得 Exporter 对象
  4:     Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());
  5:     if (exporter == null) {
  6:         throw new RpcException("Service [" + key + "] not found.");
  7:     }
  8:     // 设置服务提供者地址为本地
  9:     RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, 0);
 10:     // 调用
 11:     return exporter.getInvoker().invoke(invocation);
 12: }
```

- 第 3 至 7 行：调用

   

  ```
  InjvmProtocol#getExporter(exporterMap, url)
  ```

   

  方法，获得对应的 Exporter 对象。在

   

  《精尽 Dubbo 源码分析 —— 服务暴露（一）之本地暴露（Injvm）》

   

  中，我们已经看到，

  ```
  exporterMap
  ```

   

  属性，就是从 InjvmProtocol 的

   

  ```
  exporterMap
  ```

   

  属性。

  - 在远程调用中，选择服务提供者的逻辑会更加复杂，后续文章见。

- 第 9 行：设置服务提供者地址为本地。

- 第 11 行：获得到 Exporter 对象，里面就有**服务提供者的 Invoker 对象**。调用 `Invoker#invoke(invocation)` 方法，调用服务。

## 5. 提供者提供服务

#### 5.1 InjvmInvoker

> 提示：对应图中 [1] [2]

在 [「4.5 InjvmInvoker」](http://svip.iocoder.cn/Dubbo/rpc-injvm/#) 已经分享。

#### 5.2 ProtocolFilterWrapper

> 提示：对应图中 [3] [4]

在 [「4.2 ProtocolFilterWrapper」](http://svip.iocoder.cn/Dubbo/rpc-injvm/#) 基本一致，差异点在服务消费者和提供者的过滤器是**不同**的。

#### 5.3 DelegateProviderMetaDataInvoker

> 提示：对应图中 [5]

DelegateProviderMetaDataInvoker ，带有服务提供者配置 ServiceConfig 的 Invoker 对象。从目前代码上来看，ServiceConfig 暂时没用到。

`#invoke(invocation)` 方法，代码如下：

```
/**
 * Invoker 对象
 */
protected final Invoker<T> invoker;
/**
 * 服务提供者配置
 */
private ServiceConfig metadata;

@Override
public Result invoke(Invocation invocation) throws RpcException {
    return invoker.invoke(invocation);
}
```

#### 5.4 Wrapper

> 提示：对应图中 [6] [7] [8] [9]

见 [《精尽 Dubbo 源码分析 —— 动态代理（一）之 Javassist》](http://svip.iocoder.cn/Dubbo/proxy-javassist/?self) 文章。

# 远程调用-1:通信实现

## 1. 概述

从本文开始，我们开始分享 `dubbo://` 协议的远程调用，主要分成**四个部分**：

1. 通信实现
2. 同步调用
3. 异步调用
4. 参数回调

本文分享 **通信实现** 部分。

😈 [《精尽 Dubbo 源码解析 —— NIO 服务器》](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/#) 系列，是本文的**前置文章**，所以胖友需要先读完这个系列。哈哈哈，当然，也可以凑合看看先。

本文涉及类图如下：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_10_04/01_01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_04/01_01.png)类图

## 2. Server

在 [《精尽 Dubbo 源码分析 —— 服务引用（二）之远程暴露（Dubbo）》](http://svip.iocoder.cn/Dubbo/reference-export-dubbo/?self) 中，我们看到使用的 Server 实现类是 **HeaderExchangeServer** 。

## 3. Client

在 [《精尽 Dubbo 源码分析 —— 服务引用（二）之远程引用（Dubbo）》](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self) 中，我们看到使用的 Client 实现类是 **ReferenceCountExchangeClient** 和 **LazyConnectExchangeClient** 。

## 4. ExchangeHandler

在 DubboProtocol 中，实现了 ExchangeHandler ，代码如下：

```
private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {

    @Override
    public Object reply(ExchangeChannel channel, Object message) throws RemotingException {
        // ... 省略具体实现
    }

    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        // ... 省略具体实现
    }

    @Override
    public void connected(Channel channel) throws RemotingException {
        this.invoke(channel, Constants.ON_CONNECT_KEY);
    }

    @Override
    public void disconnected(Channel channel) throws RemotingException {
        // ... 省略具体实现
    }

    private void invoke(Channel channel, String methodKey) {
        // ... 省略具体实现
    }

};
```

这个处理器，负责将请求，**转发到对应的 Invoker 对象**，执行逻辑，返回结果。
当然，本文不细分享，放在 **同步调用** 一文详细解析。

## 5. Codec

在 [ExchangeCodec](https://github.com/apache/incubator-dubbo/blob/master/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/exchange/codec/ExchangeCodec.java) 中，我们看到对 Request 和 Response 的**通用**解析。但是它是**不满足**在 `dubbo://` 协议中，对 [RpcInvocation](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) 和 [RpcResult](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/) 作为 **内容体( Body )** 的编解码的需要的。

另外，在 `dubbo://` 协议中，支持 [参数回调](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) 的特性，也是需要在编解码做一些**特殊逻辑**。

下面，让我们来一起瞅瞅代码实现吧。

#### 5.1 DubboCountCodec

[`com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ，实现 Codec2 接口，支持**多消息**的编解码器。

###### 5.1.1 构造方法

```
/**
 * 编解码器
 */
private DubboCodec codec = new DubboCodec();
```

- 在 Dubbo Client 和 Server 创建的过程，我们看到设置了编解码器为 `"dubbo"` ，从而通过 Dubbo SPI 机制，加载到 DubboCountCodec 。相关内容如下：

  ```
  // DubboProtocol#createServer(...)
  url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
  
  // DubboProtocol#initClient(...)
  url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);
  
  // META-INF/dubbo/internal/com.alibaba.dubbo.remoting.Codec2
  dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboCountCodec
  ```

- 实际编解码的逻辑，使用 DubboCodec ，即 `codec` 属性。

###### 5.1.2 编码

```
@Override
public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {
    codec.encode(channel, buffer, msg);
}
```

###### 5.1.3 解码

```
 1: @Override
 2: public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {
 3:     // 记录当前读位置
 4:     int save = buffer.readerIndex();
 5:     // 创建 MultiMessage 对象
 6:     MultiMessage result = MultiMessage.create();
 7:     do {
 8:         // 解码
 9:         Object obj = codec.decode(channel, buffer);
10:         // 输入不够，重置读进度
11:         if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {
12:             buffer.readerIndex(save);
13:             break;
14:         // 解析到消息
15:         } else {
16:             // 添加结果消息
17:             result.addMessage(obj);
18:             // 记录消息长度到隐式参数集合，用于 MonitorFilter 监控
19:             logMessageLength(obj, buffer.readerIndex() - save);
20:             // 记录当前读位置
21:             save = buffer.readerIndex();
22:         }
23:     } while (true);
24:     // 需要更多的输入
25:     if (result.isEmpty()) {
26:         return Codec2.DecodeResult.NEED_MORE_INPUT;
27:     }
28:     // 返回解析到的消息
29:     if (result.size() == 1) {
30:         return result.get(0);
31:     }
32:     return result;
33: }
```

- 包含两块逻辑：1）多消息解析的支持。2）记录每条消息的长度，用于 MonitorFilter 监控。

- 第 4 行：记录当前读位置，用于下面计算每条消息的长度。

- 第 6 行：创建 MultiMessage 对象。MultiMessageHandler 支持对它的处理分发。

- 第 7 至 23 行：**循环**解析消息，直到结束。

- 第 9 行：调用 `DubboCodec#decode(channel, buffer)` 方法，解码。

- 第 11 至 13 行：字节数组不够，重置读进度，结束解析。

- 第 15 至 22 行：解析到消息，添加到 `result` 。

  - 第 19 行：调用 `#logMessageLength(obj, length)` 方法，记录消息长度到**隐式参数集合**，用于 MonitorFilter 监控。代码如下：

    ```
    private void logMessageLength(Object result, int bytes) {
        if (bytes <= 0) {
            return;
        }
        if (result instanceof Request) {
            try {
                ((RpcInvocation) ((Request) result).getData()).setAttachment(Constants.INPUT_KEY, String.valueOf(bytes)); // 请求
            } catch (Throwable e) {
                /* ignore */
            }
        } else if (result instanceof Response) {
            try {
                ((RpcResult) ((Response) result).getResult()).setAttachment(Constants.OUTPUT_KEY, String.valueOf(bytes)); // 响应
            } catch (Throwable e) {
                /* ignore */
            }
        }
    }
    ```

    - x

  - 第 21 行：记录当前读位置，用于计算**下一条**消息的长度。

- 第 24 至 27 行：需要更多的输入。

- 第 28 至 32 行：返回结果。

#### 5.2 DubboCodec

[`com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DubboCountCodec.java) ，实现 Codec2 接口，继承 ExchangeCodec 类，**Dubbo 编解码器**实现类。

###### 5.2.1 构造方法

```
/**
 * 协议名
 */
public static final String NAME = "dubbo";
/**
 * 协议版本
 */
public static final String DUBBO_VERSION = Version.getVersion(DubboCodec.class, Version.getVersion());

/**
 * 响应 - 异常
 */
public static final byte RESPONSE_WITH_EXCEPTION = 0;
/**
 * 响应 - 正常（空返回）
 */
public static final byte RESPONSE_VALUE = 1;
/**
 * 响应 - 正常（有返回）
 */
public static final byte RESPONSE_NULL_VALUE = 2;

/**
 * 方法参数 - 空（参数）
 */
public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
/**
 * 方法参数 - 空（类型）
 */
public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];
```

###### 5.2.2 编码内容体

####### 5.2.2.1 请求

```
 1: @Override
 2: protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException {
 3:     RpcInvocation inv = (RpcInvocation) data;
 4: 
 5:     // 写入 `dubbo` `path` `version`
 6:     out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));
 7:     out.writeUTF(inv.getAttachment(Constants.PATH_KEY));
 8:     out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));
 9: 
10:     // 写入方法、方法签名、方法参数集合
11:     out.writeUTF(inv.getMethodName());
12:     out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));
13:     Object[] args = inv.getArguments();
14:     if (args != null) {
15:         for (int i = 0; i < args.length; i++) {
16:             out.writeObject(CallbackServiceCodec.encodeInvocationArgument(channel, inv, i));
17:         }
18:     }
19: 
20:     // 写入隐式传参集合
21:     out.writeObject(inv.getAttachments());
22: }
```

- 🙂 胖友看下代码注释。
- 编码 RpcInvocation 对象，写入需要编码的字段。
- 对应的解码，在 DecodeableRpcInvocation 中。
- 第 16 行：调用 `CallbackServiceCodec#encodeInvocationArgument(...)` 方法，编码参数。主要用于 [参数回调](http://dubbo.apache.org/zh-cn/docs/user/demos/callback-parameter.html) 功能，后面的文章，详细解析。

####### 5.2.2.2 响应

```
 1: @Override
 2: protected void encodeResponseData(Channel channel, ObjectOutput out, Object data) throws IOException {
 3:     Result result = (Result) data;
 4: 
 5:     Throwable th = result.getException();
 6:     // 正常
 7:     if (th == null) {
 8:         Object ret = result.getValue();
 9:         // 空返回
10:         if (ret == null) {
11:             out.writeByte(RESPONSE_NULL_VALUE);
12:         // 有返回
13:         } else {
14:             out.writeByte(RESPONSE_VALUE);
15:             out.writeObject(ret);
16:         }
17:     // 异常
18:     } else {
19:         out.writeByte(RESPONSE_WITH_EXCEPTION);
20:         out.writeObject(th);
21:     }
22: }
```

- 🙂 胖友看下代码注释。
- 编码 Result 对象，写入需要编码的字段。
- 对应的解码，在 DecodeableRpcResult 中。

###### 5.2.3 解码内容体

```
 1: @Override
 2: protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
 3:     byte flag = header[2];
 4:     // 获得 Serialization 对象
 5:     byte proto = (byte) (flag & SERIALIZATION_MASK);
 6:     Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
 7:     // 获得请求||响应编号
 8:     // get request id.
 9:     long id = Bytes.bytes2long(header, 4);
10:     // 解析响应
11:     if ((flag & FLAG_REQUEST) == 0) {
12:         // decode response.
13:         Response res = new Response(id);
14:         // ... 省略代码
15:         return res;
16:     // 解析请求
17:     } else {
18:         // decode request.
19:         Request req = new Request(id);
20:         // ... 省略代码
21:         return req;
22:     }
23: }
```

- 第 4 至 6 行：调用 `CodeSupport#getSerialization(url, proto)` 方法，获得 Serialization 对象，用于下面反序列化内容体的每个字段。
- 第 9 行：获得请求或响应的编号。
- 第 10 至 15 行：解析响应( Response )。
- 第 16 至 22 行：解析请求( Request )。

####### 5.2.3.1 请求

```
 1: // decode response.
 2: Response res = new Response(id);
 3: // 若是心跳事件，进行设置
 4: if ((flag & FLAG_EVENT) != 0) {
 5:     res.setEvent(Response.HEARTBEAT_EVENT);
 6: }
 7: // 设置状态
 8: // get status.
 9: byte status = header[3];
10: res.setStatus(status);
11: // 正常响应状态
12: if (status == Response.OK) {
13:     try {
14:         Object data;
15:         // 解码心跳事件
16:         if (res.isHeartbeat()) {
17:             data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
18:         // 解码其它事件
19:         } else if (res.isEvent()) {
20:             data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
21:         // 解码普通响应
22:         } else {
23:             DecodeableRpcResult result;
24:             // 在通信框架（例如，Netty）的 IO 线程，解码
25:             if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
26:                 result = new DecodeableRpcResult(channel, res, is, (Invocation) getRequestData(id), proto);
27:                 result.decode();
28:             // 在 Dubbo ThreadPool 线程，解码，使用 DecodeHandler
29:             } else {
30:                 result = new DecodeableRpcResult(channel, res, new UnsafeByteArrayInputStream(readMessageData(is)), (Invocation) getRequestData(id), proto);
31:             }
32:             data = result;
33:         }
34:         // 设置结果
35:         res.setResult(data);
36:     } catch (Throwable t) {
37:         if (log.isWarnEnabled()) {
38:             log.warn("Decode response failed: " + t.getMessage(), t);
39:         }
40:         res.setStatus(Response.CLIENT_ERROR);
41:         res.setErrorMessage(StringUtils.toString(t));
42:     }
43: // 异常响应状态
44: } else {
45:     res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());
46: }
47: return res;
```

- 🙂 胖友看下代码注释。我们重点讲下可能**比较绕**的地方。

- 第 21 至 33 行：解码普通响应。我们可以看到代码分成【第 25 至 27 行】【第 28 至 31 行】

  两段

  。

  - 相同点，使用 **DecodeableRpcResult** 解码。前者，比较好理解，【第 27 行】已经调用；后者，在 DecodeHandler 中，才最终调用 `DecodeableRpcResult#decode()` 方法。
  - 差异点，使用**哪个线程**解码。前者，还是比较好理解，当前线程，即通信框架（例如，Netty）的 IO 线程。后者，Dubbo ThreadPool 线程中。
  - `decode.in.io` 配置项，目前在 Dubbo 文档中，并未说明，应该是**性能调优**，具体笔者还没测试过。嘿嘿。

####### 5.2.3.2 响应

```
 1: // decode request.
 2: Request req = new Request(id);
 3: req.setVersion("2.0.0");
 4: // 是否需要响应
 5: req.setTwoWay((flag & FLAG_TWOWAY) != 0);
 6: // 若是心跳事件，进行设置
 7: if ((flag & FLAG_EVENT) != 0) {
 8:     req.setEvent(Request.HEARTBEAT_EVENT);
 9: }
10: try {
11:     Object data;
12:     // 解码心跳事件
13:     if (req.isHeartbeat()) {
14:         data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));
15:     // 解码其它事件
16:     } else if (req.isEvent()) {
17:         data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));
18:     // 解码普通请求
19:     } else {
20:         // 在通信框架（例如，Netty）的 IO 线程，解码
21:         DecodeableRpcInvocation inv;
22:         if (channel.getUrl().getParameter(Constants.DECODE_IN_IO_THREAD_KEY, Constants.DEFAULT_DECODE_IN_IO_THREAD)) {
23:             inv = new DecodeableRpcInvocation(channel, req, is, proto);
24:             inv.decode();
25:         // 在 Dubbo ThreadPool 线程，解码，使用 DecodeHandler
26:         } else {
27:             inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(readMessageData(is)), proto);
28:         }
29:         data = inv;
30:     }
31:     req.setData(data);
32: } catch (Throwable t) {
33:     if (log.isWarnEnabled()) {
34:         log.warn("Decode request failed: " + t.getMessage(), t);
35:     }
36:     // bad request
37:     req.setBroken(true);
38:     req.setData(t);
39: }
40: return req;
```

- 和 [「5.2.3.1 请求」](http://svip.iocoder.cn/Dubbo/rpc-dubbo-1-remoting/#) **类似**，差异点在使用 **DecodeableRpcInvocation** 。
- 🙂 胖友看下代码注释。

#### 5.3 DecodeableRpcInvocation

[`com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java) ，实现 Codec 和 Decodeable 接口，继承 RpcInvocation 类，**可解码**的 RpcInvocation 实现类。

当服务消费者，调用服务提供者，前者编码的 RpcInvocation 对象，后者解码成 DecodeableRpcInvocation 对象。

从目前的代码实现来看，Codec 接口，可不实现。

###### 5.3.1 构造方法

```
/**
 * 通道
 */
private Channel channel;
/**
 * Serialization 类型编号
 */
private byte serializationType;
/**
 * 输入流
 */
private InputStream inputStream;
/**
 * 请求
 */
private Request request;
/**
 * 是否已经解码完成
 */
private volatile boolean hasDecoded;
```

###### 5.3.2 解码

```
@Override
public void decode() {
    if (!hasDecoded && channel != null && inputStream != null) {
        try {
            decode(channel, inputStream);
        } catch (Throwable e) {
            if (log.isWarnEnabled()) {
                log.warn("Decode rpc invocation failed: " + e.getMessage(), e);
            }
            request.setBroken(true);
            request.setData(e);
        } finally {
            hasDecoded = true;
        }
    }
}

@Override
public Object decode(Channel channel, InputStream input) throws IOException {
    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);

    // 解码 `dubbo` `path` `version`
    setAttachment(Constants.DUBBO_VERSION_KEY, in.readUTF());
    setAttachment(Constants.PATH_KEY, in.readUTF());
    setAttachment(Constants.VERSION_KEY, in.readUTF());

    // 解码方法、方法签名、方法参数集合
    setMethodName(in.readUTF());
    try {
        Object[] args;
        Class<?>[] pts;
        String desc = in.readUTF();
        if (desc.length() == 0) {
            pts = DubboCodec.EMPTY_CLASS_ARRAY;
            args = DubboCodec.EMPTY_OBJECT_ARRAY;
        } else {
            pts = ReflectUtils.desc2classArray(desc);
            args = new Object[pts.length];
            for (int i = 0; i < args.length; i++) {
                try {
                    args[i] = in.readObject(pts[i]);
                } catch (Exception e) {
                    if (log.isWarnEnabled()) {
                        log.warn("Decode argument failed: " + e.getMessage(), e);
                    }
                }
            }
        }
        setParameterTypes(pts);

        // 解码隐式传参集合
        Map<String, String> map = (Map<String, String>) in.readObject(Map.class);
        if (map != null && map.size() > 0) {
            Map<String, String> attachment = getAttachments();
            if (attachment == null) {
                attachment = new HashMap<String, String>();
            }
            attachment.putAll(map);
            setAttachments(attachment);
        }

        // 进一步解码方法参数，主要为了参数返回
        // decode argument ,may be callback
        for (int i = 0; i < args.length; i++) {
            args[i] = CallbackServiceCodec.decodeInvocationArgument(channel, this, pts, i, args[i]);
        }
        setArguments(args);
    } catch (ClassNotFoundException e) {
        throw new IOException(StringUtils.toString("Read invocation data failed.", e));
    } finally {
        if (in instanceof Cleanable) {
            ((Cleanable) in).cleanup();
        }
    }
    return this;
}
```

- 🙂 胖友看下代码注释。

#### 5.4 DecodeableRpcResult

> 和 DecodeableRpcInvocation 一致。

[`com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/DecodeableRpcResult.java) ，实现 Codec 和 Decodeable 接口，继承 RpcResult 类，**可解码**的 RpcResult 实现类。

当服务提供者者，返回服务消费者调用结果，前者编码的 RpcResult 对象，后者解码成 DecodeableRpcResult 对象。

从目前的代码实现来看，Codec 接口，可不实现。

###### 5.4.1 构造方法

```
/**
 * 通道
 */
private Channel channel;
/**
 * Serialization 类型编号
 */
private byte serializationType;
/**
 * 输入流
 */
private InputStream inputStream;
/**
 * 请求
 */
private Response response;
/**
 * Invocation 对象
 */
private Invocation invocation;
/**
 * 是否已经解码完成
 */
private volatile boolean hasDecoded;
```

###### 5.4.2 解码

```
@Override
public void decode() {
    if (!hasDecoded && channel != null && inputStream != null) {
        try {
            decode(channel, inputStream);
        } catch (Throwable e) {
            if (log.isWarnEnabled()) {
                log.warn("Decode rpc result failed: " + e.getMessage(), e);
            }
            response.setStatus(Response.CLIENT_ERROR);
            response.setErrorMessage(StringUtils.toString(e));
        } finally {
            hasDecoded = true;
        }
    }
}

@Override
public Object decode(Channel channel, InputStream input) throws IOException {
    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType).deserialize(channel.getUrl(), input);

    // 读取标记位
    byte flag = in.readByte();
    switch (flag) {
        case DubboCodec.RESPONSE_NULL_VALUE: // 无返回值
            break;
        case DubboCodec.RESPONSE_VALUE: // 有返回值
            try {
                Type[] returnType = RpcUtils.getReturnTypes(invocation);
                setValue(returnType == null || returnType.length == 0 ? in.readObject() :
                        (returnType.length == 1 ? in.readObject((Class<?>) returnType[0])
                                // 返回结果:Type[]{method.getReturnType(), method.getGenericReturnType()}
                                : in.readObject((Class<?>) returnType[0], returnType[1])));
            } catch (ClassNotFoundException e) {
                throw new IOException(StringUtils.toString("Read response data failed.", e));
            }
            break;
        case DubboCodec.RESPONSE_WITH_EXCEPTION: // 异常
            try {
                Object obj = in.readObject();
                if (!(obj instanceof Throwable)) {
                    throw new IOException("Response data error, expect Throwable, but get " + obj);
                }
                setException((Throwable) obj);
            } catch (ClassNotFoundException e) {
                throw new IOException(StringUtils.toString("Read response data failed.", e));
            }
            break;
        default:
            throw new IOException("Unknown result flag, expect '0' '1' '2', get " + flag);
    }
    if (in instanceof Cleanable) {
        ((Cleanable) in).cleanup();
    }
    return this;
}
```

# 远程调用-2:同步调用

## 1. 概述

本文分享 `dubbo://` 协议的远程调用的**第二部分：同步调用**。

在 `dubbo://` 协议的调用，一共分成三种：

1. sync 同步调用
2. async 异步调用
3. oneway 单向调用

前两种比较好理解，都是基于 Request Response 模型，差异点在异步调用，服务消费者**不阻塞**等待结果，而是通过**回调**的方式，处理服务提供者返回的结果。
最后一种，基于 Message 模型，发起调用，而不关注等待和关注执行结果。
因此，从性能上：oneway > async > sync 。

> 友情提示：本文会分享 sync 和 oneway 两种方式。

## 2. 顺序图

- 消费者调用服务的顺序图：[![顺序图](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_01.jpeg)顺序图

  - 此图是在

     

    ```
    injvm://
    ```

     

    协议的顺序图的基础上修改：

    - 将 InjvmInvoker 替换成 DubboInvoker 。
    - 在 `#doInvoker()` 方法中，DubboInvoker 会调用 Client ，向服务提供者发起请求。

  - 可能会有胖友问，

    集群容错

    呢？在 InvokerInvocationHandler 之后，ProtocolFilterWrapper$Invoker 之前。如下图所示：

    ![集群容错](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_02.png)

    集群容错

    - 🙂 我们后面专门写几篇文章，专门分享集群容错，所以本文略过。

- 提供者提供服务的顺序图：[![顺序图](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_03.jpeg)顺序图

  - 此图是在

     

    ```
    injvm://
    ```

     

    协议的顺序图的基础上修改：

    - InjvmInvoker 替换成 ExchangeServer 。例如在 Netty4 中，IO Worker 解析请求，转发给 ExchangeHandler 处理。
    - InjvmProtocol 替换成 DubboProtocol 。在该类中，实现了自定义的 ExchangeHandler 处理请求。**注意**，在 **Dubbo ThreadPool** 中处理请求，参见 [《Dubbo 用户指南 —— 线程模型》](http://dubbo.apache.org/zh-cn/docs/user/demos/thread-model.html) 文档。

## 3. 消费者调用服务

调用 `DubboInvoker#invoke(Invocation)` 方法，调用服务。代码如下：

```
/**
 * 使用的 {@link #clients} 的位置
 */
private final AtomicPositiveInteger index = new AtomicPositiveInteger();

  1: @Override
  2: protected Result doInvoke(final Invocation invocation) {
  3:     RpcInvocation inv = (RpcInvocation) invocation;
  4:     // 获得方法名
  5:     final String methodName = RpcUtils.getMethodName(invocation);
  6:     // 获得 `path`( 服务名 )，`version`
  7:     inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());
  8:     inv.setAttachment(Constants.VERSION_KEY, version);
  9: 
 10:     // 获得 ExchangeClient 对象
 11:     ExchangeClient currentClient;
 12:     if (clients.length == 1) {
 13:         currentClient = clients[0];
 14:     } else {
 15:         currentClient = clients[index.getAndIncrement() % clients.length];
 16:     }
 17:     // 远程调用
 18:     try {
 19:         // 获得是否异步调用
 20:         boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);
 21:         // 获得是否单向调用
 22:         boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
 23:         // 获得超时时间
 24:         int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
 25:         // 单向调用
 26:         if (isOneway) {
 27:             boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
 28:             currentClient.send(inv, isSent);
 29:             RpcContext.getContext().setFuture(null);
 30:             return new RpcResult();
 31:         // 异步调用
 32:         } else if (isAsync) {
 33:             ResponseFuture future = currentClient.request(inv, timeout);
 34:             RpcContext.getContext().setFuture(new FutureAdapter<Object>(future));
 35:             return new RpcResult();
 36:         // 同步调用
 37:         } else {
 38:             RpcContext.getContext().setFuture(null);
 39:             return (Result) currentClient.request(inv, timeout).get();
 40:         }
 41:     } catch (TimeoutException e) {
 42:         throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
 43:     } catch (RemotingException e) {
 44:         throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
 45:     }
 46: }
```

- 第 5 行：调用 `RpcUtils#getMethodName()` 方法，获得方法名。代码如下：

  ```
  public static String getMethodName(Invocation invocation) {
      // 泛化调用，第一个参数为方法名
      if (Constants.$INVOKE.equals(invocation.getMethodName())
              && invocation.getArguments() != null
              && invocation.getArguments().length > 0
              && invocation.getArguments()[0] instanceof String) {
          return (String) invocation.getArguments()[0];
      }
      // 普通调用，直接获得
      return invocation.getMethodName();
  }
  ```

- 第 6 至 8 行：获得 `path`( 服务名 )、`version` 。

- 第 10 至 16 行：**顺序**，获得 ExchangeClient 对象。

- 第 20 行：调用 `RpcUtils#isAsync(url, invocation)` 方法，判断是否异步调用。代码如下：

  ```
  public static boolean isAsync(URL url, Invocation inv) {
      return Boolean.TRUE.toString().equals(inv.getAttachment(Constants.ASYNC_KEY)) // RpcContext#asyncCall(Callable) 方法，可以设置
              || url.getMethodParameter(getMethodName(inv), Constants.ASYNC_KEY, false);
  }
  ```

  - 获得是否异步。服务引用或方法，任一配置 `async = true` ，即为异步。

- 第 22 行：调用 `RpcUtils#isOneway(url, invocation)` 方法，判断是否异步调用。代码如下：

  ```
  public static boolean isOneway(URL url, Invocation inv) {
      return Boolean.FALSE.toString().equals(inv.getAttachment(Constants.RETURN_KEY)) // RpcContext#asyncCall(Runnable) 方法，可以设置
              || !url.getMethodParameter(getMethodName(inv), Constants.RETURN_KEY, true);
  }
  ```

  - 获得是否单向。方法配置 `return = true` ，即为单向。

- 第 24 行：调用 `URL#getMethodParameter(method, key, defaultValue)` 方法，获得远程调用超时时间，单位：毫秒。

- 第 25 至 30 行：oneway 单向调用。

  - 第 28 行：**注意**，调用的是 `ExchangeClient#send(invocation, sent)` 方法，发送**消息**，而不是**请求**。
  - 第 29 行：设置 `RpcContext.future = null` ，无需 FutureFilter ，异步回调。
  - 第 30 行：创建 RpcResult 对象，**空返回**。

- 第 31 至 35 行：async 异步调用。

  - 第 33 行：调用 `ExchangeClient#request(invocation, timeout)` 方法，发送**请求**。
  - 第 34 行：调用 `RpcContext#setFuture(future)` 方法，在 FutureFitler 中，异步回调。
  - 第 35 行：创建 RpcResult 对象，**空返回**。

- 第 36 至 40 行：sync 同步调用。

  - 第 38 行：设置 `RpcContext.future = null` ，无需 FutureFilter ，异步回调。
  - 第 39 行：调用 `ExchangeClient#request(invocation, timeout)` 方法，发送**请求**。
  - 第 39 行：调用 `ResponseFuture#get()` 方法，**阻塞**等待，返回结果。

## 4. 提供者提供服务

在 DubboProtocol 类中，实现了自己的 ExchangeHandler 对象，处理请求、消息、连接、断开连接等事件。对于服务消费者的远程调用，通过 `#reply(ExchangeChannel channel, Object message)` 和 `#reply(Channel channel, Object message)` 方法来处理。如下图所示：[![ExchangeHandler](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_04.png)](http://static.iocoder.cn/images/Dubbo/2018_10_04/02_04.png)ExchangeHandler

下面，我们来看看每个方法的实现代码。

#### 4.1 reply

```
 1: @Override
 2: public Object reply(ExchangeChannel channel, Object message) throws RemotingException {
 3:     if (message instanceof Invocation) {
 4:         Invocation inv = (Invocation) message;
 5:         // 获得请求对应的 Invoker 对象
 6:         Invoker<?> invoker = getInvoker(channel, inv);
 7:         // 如果是callback 需要处理高版本调用低版本的问题
 8:         // need to consider backward-compatibility if it's a callback
 9:         if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
10:             String methodsStr = invoker.getUrl().getParameters().get("methods");
11:             boolean hasMethod = false;
12:             if (methodsStr == null || !methodsStr.contains(",")) {
13:                 hasMethod = inv.getMethodName().equals(methodsStr);
14:             } else {
15:                 String[] methods = methodsStr.split(",");
16:                 for (String method : methods) {
17:                     if (inv.getMethodName().equals(method)) {
18:                         hasMethod = true;
19:                         break;
20:                     }
21:                 }
22:             }
23:             if (!hasMethod) {
24:                 logger.warn(new IllegalStateException("The methodName " + inv.getMethodName() + " not found in callback service interface ,invoke will be ignored. please update the api interface. url is:" + invoker.getUrl()) + " ,invocation is :" + inv);
25:                 return null;
26:             }
27:         }
28:         // 设置调用方的地址
29:         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
30:         // 执行调用
31:         return invoker.invoke(inv);
32:     }
33:     throw new RemotingException(channel, message.getClass().getName() + ": " + message
34:             + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress());
35: }
```

- 用于处理服务消费者的同步调用和异步调用的请求。

- 第 6 行：调用 `#getInvoker(channel, invocation)` 方法，获得请求对应的 Invoker 对象。代码如下：

  ```
  /**
   * Exporter 集合
   *
   * key: 服务键 {@link #serviceKey(URL)} 或 {@link URL#getServiceKey()} 。
   *      不同协议会不同
   */
  protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM 父类 AbstractProtocol.java
  
    1: Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException {
    2:     boolean isCallBackServiceInvoke;
    3:     boolean isStubServiceInvoke;
    4:     int port = channel.getLocalAddress().getPort();
    5:     String path = inv.getAttachments().get(Constants.PATH_KEY);
    6:     // TODO 【8033 参数回调】
    7:     // if it's callback service on client side
    8:     isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));
    9:     if (isStubServiceInvoke) {
   10:         port = channel.getRemoteAddress().getPort();
   11:     }
   12:     // 如果是参数回调，获得真正的服务名 `path` 。
   13:     // callback
   14:     isCallBackServiceInvoke = isClientSide(channel) && !isStubServiceInvoke;
   15:     if (isCallBackServiceInvoke) {
   16:         path = inv.getAttachments().get(Constants.PATH_KEY) + "." + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);
   17:         inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());
   18:     }
   19:     // 获得服务建
   20:     String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));
   21:     // 获得 Exporter 对象
   22:     DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);
   23:     // 获得 Invoker 对象
   24:     if (exporter == null) {
   25:         throw new RemotingException(channel, "Not found exported service: " + serviceKey + " in " + exporterMap.keySet() + ", may be version or group mismatch " + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress() + ", message:" + inv);
   26:     }
   27:     return exporter.getInvoker();
   28: }
  ```

  - 第 6 至 11 行：TODO 【8033 参数回调】

  - 第 12 至 18 行：如果是参数回调，获得真正的服务名 `path` 。在**参数回调**一文中，我们详细解析。

  - 第 20 行：调用 `#serviceKey(port, path, version)` 方法，获得服务键。代码如下：

    ```
    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) {
        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);
    }
    ```

  - 第 22 行：从 `exporterMap` 集合中，获得 Exporter 对象。

  - 第 23 至 27 行：获得 Invoker 对象。

- 第 8 至 27 行：如果是**参数回调**，校验服务消费者实际存在对应的回调方法，通过方法名判断。

- 第 29 行：设置调用方的地址。

- 第 31 行：调用 `Invoker#invoke(invocation)` 方法，执行调用，并返回结果。后续的逻辑，和 `injvm://` 协议是一致的。

#### 4.2 received

```
@Override
public void received(Channel channel, Object message) throws RemotingException {
    if (message instanceof Invocation) {
        this.reply((ExchangeChannel) channel, message);
    } else {
        super.received(channel, message);
    }
}
```

- 用于处理服务消费者的**单次调用**的消息，通过判断消息类型是不是 Invocation 。

#### 4.3 connected && disconnected

> 本小节和 Dubbo RPC 无关系，只是为了完整分享 DubboProtocol ExchangeHandler 的完整代码实现。

在服务提供者上，有 `"onconnect"` 和 `"ondisconnect"` 配置项，在服务提供者连接或断开连接时，调用 Service 对应的方法。目前这个配置项，在 Dubbo 文档里，暂未提及。当然，这个在实际场景下，基本没用过。

```
@Override
public void connected(Channel channel) {
    this.invoke(channel, Constants.ON_CONNECT_KEY);
}

@Override
public void disconnected(Channel channel) throws RemotingException {
    if (logger.isInfoEnabled()) {
        logger.info("disconected from " + channel.getRemoteAddress() + ",url:" + channel.getUrl());
    }
    this.invoke(channel, Constants.ON_DISCONNECT_KEY);
}
```

- 调用 `#invoke(channel, methodKey)` 方法，执行对应的方法。代码如下：

  ```
  /**
   * 调用方法
   *
   * @param channel 通道
   * @param methodKey 方法名
   */
  private void invoke(Channel channel, String methodKey) {
      // 创建 Invocation 对象
      Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
      // 调用 received 方法，执行对应的方法
      if (invocation != null) {
          try {
              this.received(channel, invocation);
          } catch (Throwable t) {
              logger.warn("Failed to invoke event method " + invocation.getMethodName() + "(), cause: " + t.getMessage(), t);
          }
      }
  }
  
  private Invocation createInvocation(Channel channel, URL url, String methodKey) {
      String method = url.getParameter(methodKey);
      if (method == null || method.length() == 0) {
          return null;
      }
      RpcInvocation invocation = new RpcInvocation(method, new Class<?>[0], new Object[0]);
      invocation.setAttachment(Constants.PATH_KEY, url.getPath());
      invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));
      invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));
      invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));
      if (url.getParameter(Constants.STUB_EVENT_KEY, false)) {
          invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());
      }
      return invocation;
  }
  ```

# 远程调用-3:异步调用

## 1. 概述

本文分享 `dubbo://` 协议的远程调用的**第三部分：异步调用**。

对应 [《Dubbo 用户指南 —— 事件通知》](http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html) 文档。定义如下：

> 在调用之前、调用之后、出现异常时，会触发 `oninvoke`、`onreturn`、`onthrow` 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。

看完定义，是不是有点疑惑，和本文的标题仿佛有些出入？相信自己，你是对的，标题是不严谨的，“错误”点如下：

- `oninvoke` 配置项，设置服务消费者**调用**服务提供者**之前**，执行前置方法，类似 AOP 的 `#beforeMethod(...)` 方法。
- `onreturn` 和 `onthrow` 配置项，设置服务消费者**调用**服务提供者**之后**，执行后置方法，类似 AOP 的 `#afterMethod(...)` 方法。有一点我们需要注意，一开始笔者理解错了，并非只有 `async = true` ，异步调用才支持回调，同步调用和单向调用也支持回调。

具体的调用，在 [《精尽 Dubbo 源码分析 —— 服务调用（二）之远程调用（Dubbo）【2】同步调用》「3. 消费者调用服务」](http://svip.iocoder.cn/Dubbo/rpc-dubbo-2-sync/?self) 中，我们已经看到调用的代码。如果胖友没看过，建议先去看看。

## 2. FutureAdapter

[`com.alibaba.dubbo.rpc.protocol.dubbo.FutureAdapter`](http://svip.iocoder.cn/Dubbo/rpc-dubbo-3-async/todo) ，实现 Future 接口，适配 ResponseFuture 。通过这样的方式，对上层调用方，**透明**化 ResponseFuture 的存在。代码如下：

```
public class FutureAdapter<V> implements Future<V> {

    private final ResponseFuture future;

    public FutureAdapter(ResponseFuture future) {
        this.future = future;
    }

    public ResponseFuture getFuture() {
        return future;
    }

    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return future.isDone();
    }

    @Override
    @SuppressWarnings("unchecked")
    public V get() throws InterruptedException, ExecutionException {
        try {
            return (V) (((Result) future.get()).recreate());
        } catch (RemotingException e) {
            throw new ExecutionException(e.getMessage(), e);
        } catch (Throwable e) {
            throw new RpcException(e);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        int timeoutInMillis = (int) unit.convert(timeout, TimeUnit.MILLISECONDS);
        try {
            return (V) (((Result) future.get(timeoutInMillis)).recreate());
        } catch (com.alibaba.dubbo.remoting.TimeoutException e) {
            throw new TimeoutException(StringUtils.toString(e));
        } catch (RemotingException e) {
            throw new ExecutionException(e.getMessage(), e);
        } catch (Throwable e) {
            throw new RpcException(e);
        }
    }

}
```

## 3. FutureFilter

[`com.alibaba.dubbo.rpc.protocol.dubbo.filte.FutureFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-default/src/main/java/com/alibaba/dubbo/rpc/protocol/dubbo/filter/FutureFilter.java) ，实现 Filter 接口，事件通知过滤器。实现代码如下：

```
 1: @Activate(group = Constants.CONSUMER)
 2: public class FutureFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(final Invoker<?> invoker, final Invocation invocation) throws RpcException {
 6:         // 获得是否异步调用
 7:         final boolean isAsync = RpcUtils.isAsync(invoker.getUrl(), invocation);
 8: 
 9:         // 触发前置方法
10:         fireInvokeCallback(invoker, invocation);
11:         // need to configure if there's return value before the invocation in order to help invoker to judge if it's
12:         // necessary to return future.
13:         // 调用方法
14:         Result result = invoker.invoke(invocation);
15: 
16:         // 触发回调方法
17:         if (isAsync) { // 异步回调
18:             asyncCallback(invoker, invocation);
19:         } else { // 同步回调
20:             syncCallback(invoker, invocation, result);
21:         }
22:         return result;
23:     }
24:     
25:     // ... 省略部分方法
26: }
```

- `@Activate(group = Constants.CONSUMER)` 注解，基于 Dubbo SPI Activate 机制，只有**服务消费者**才生效该过滤器。
- 第 7 行：调用 `RpcUtils#isAsync(url, invocation)` 方法，判断是否异步调用。
- 第 10 行：调用 `#fireInvokeCallback(invoker, invocation)` 方法，触发前置方法。
- 第 14 行：调用 `invoker#invoke(invocation)` 方法，调用**服务提供者**，即 Dubbo RPC 。
- 第 16 至 21 行：触发回调方法。
  - 第 17 至 18 行：若**是**异步调用，调用 `#asyncCallback(invoker, invocation)` 方法，执行异步回调。
  - 第 19 至 21 行：若**非**异步调用，调用 `#syncCallback(invoker, invocation)` 方法，执行同步回调。
- 第 22 行：返回结果。如果是异步调用或单向调用，所以返回结果是**空**的。

#### 3.1 fireInvokeCallback

```
 1: /**
 2:  * 触发前置方法
 3:  *
 4:  * @param invoker Invoker 对象
 5:  * @param invocation Invocation 对象
 6:  */
 7: private void fireInvokeCallback(final Invoker<?> invoker, final Invocation invocation) {
 8:     // 获得前置方法和对象
 9:     final Method onInvokeMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_METHOD_KEY));
10:     final Object onInvokeInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_INVOKE_INSTANCE_KEY));
11:     if (onInvokeMethod == null && onInvokeInst == null) {
12:         return;
13:     }
14:     if (onInvokeMethod == null || onInvokeInst == null) {
15:         throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onreturn callback config , but no such " + (onInvokeMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
16:     }
17:     if (!onInvokeMethod.isAccessible()) {
18:         onInvokeMethod.setAccessible(true);
19:     }
20: 
21:     // 调用前置方法
22:     Object[] params = invocation.getArguments();
23:     try {
24:         onInvokeMethod.invoke(onInvokeInst, params);
25:     } catch (InvocationTargetException e) {
26:         fireThrowCallback(invoker, invocation, e.getTargetException());
27:     } catch (Throwable e) {
28:         fireThrowCallback(invoker, invocation, e);
29:     }
30: }
```

- 第 8 至 19 行：获得前置方法和对象。StaticContext 在 [《精尽 Dubbo 源码分析 —— API 配置（三）之服务消费者》](http://svip.iocoder.cn/Dubbo/configuration-api-3/?self) 中，已经详细解析。
- 第 21 至 29 行：**反射**调用前置方法。

#### 3.2 syncCallback

```
/**
 * 同步回调
 *
 * @param invoker Invoker 对象
 * @param invocation Invocation 对象
 * @param result RPC 结果
 */
private void syncCallback(final Invoker<?> invoker, final Invocation invocation, final Result result) {
    if (result.hasException()) { // 异常，触发异常回调
        fireThrowCallback(invoker, invocation, result.getException());
    } else { // 正常，触发正常回调
        fireReturnCallback(invoker, invocation, result.getValue());
    }
}
```

- `#fireThrowCallback(invoker, invocation, exception)` 方法，触发异常回调方法，代码如下：

  ```
  private void fireReturnCallback(final Invoker<?> invoker, final Invocation invocation, final Object result) {
      // 获得 `onreturn` 方法和对象
      final Method onReturnMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_METHOD_KEY));
      final Object onReturnInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_RETURN_INSTANCE_KEY));
      //not set onreturn callback
      if (onReturnMethod == null && onReturnInst == null) {
          return;
      }
      if (onReturnMethod == null || onReturnInst == null) {
          throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onreturn callback config , but no such " + (onReturnMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
      }
      if (!onReturnMethod.isAccessible()) {
          onReturnMethod.setAccessible(true);
      }
  
      // 参数数组
      Object[] args = invocation.getArguments();
      Object[] params;
      Class<?>[] rParaTypes = onReturnMethod.getParameterTypes();
      if (rParaTypes.length > 1) {
          if (rParaTypes.length == 2 && rParaTypes[1].isAssignableFrom(Object[].class)) {
              params = new Object[2];
              params[0] = result;
              params[1] = args;
          } else {
              params = new Object[args.length + 1];
              params[0] = result;
              System.arraycopy(args, 0, params, 1, args.length);
          }
      } else {
          params = new Object[]{result};
      }
  
      // 调用方法
      try {
          onReturnMethod.invoke(onReturnInst, params);
      } catch (InvocationTargetException e) {
          fireThrowCallback(invoker, invocation, e.getTargetException());
      } catch (Throwable e) {
          fireThrowCallback(invoker, invocation, e);
      }
  }
  ```

- `#fireReturnCallback(invoker, invocation, result)` 方法，触发正常回调方法，代码如下：

  ```
  private void fireThrowCallback(final Invoker<?> invoker, final Invocation invocation, final Throwable exception) {
      // 获得 `onthrow` 方法和对象
      final Method onthrowMethod = (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_METHOD_KEY));
      final Object onthrowInst = StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), Constants.ON_THROW_INSTANCE_KEY));
      // onthrow callback not configured
      if (onthrowMethod == null && onthrowInst == null) {
          return;
      }
      if (onthrowMethod == null || onthrowInst == null) {
          throw new IllegalStateException("service:" + invoker.getUrl().getServiceKey() + " has a onthrow callback config , but no such " + (onthrowMethod == null ? "method" : "instance") + " found. url:" + invoker.getUrl());
      }
      if (!onthrowMethod.isAccessible()) {
          onthrowMethod.setAccessible(true);
      }
  
      Class<?>[] rParaTypes = onthrowMethod.getParameterTypes();
      if (rParaTypes[0].isAssignableFrom(exception.getClass())) { // 符合异常
          try {
              // 参数数组
              Object[] args = invocation.getArguments();
              Object[] params;
              if (rParaTypes.length > 1) {
                  if (rParaTypes.length == 2 && rParaTypes[1].isAssignableFrom(Object[].class)) {
                      params = new Object[2];
                      params[0] = exception;
                      params[1] = args;
                  } else {
                      params = new Object[args.length + 1];
                      params[0] = exception;
                      System.arraycopy(args, 0, params, 1, args.length);
                  }
              } else {
                  params = new Object[]{exception};
              }
  
              // 调用方法
              onthrowMethod.invoke(onthrowInst, params);
          } catch (Throwable e) {
              logger.error(invocation.getMethodName() + ".call back method invoke error . callback method :" + onthrowMethod + ", url:" + invoker.getUrl(), e);
          }
      } else { // 不符合异常，打印错误日志
          logger.error(invocation.getMethodName() + ".call back method invoke error . callback method :" + onthrowMethod + ", url:" + invoker.getUrl(), exception);
      }
  }
  ```

#### 3.3 asyncCallback

```
/**
 * 异步回调
 *
 * @param invoker Invoker 对象
 * @param invocation Invocation 对象
 */
private void asyncCallback(final Invoker<?> invoker, final Invocation invocation) {
    // 获得 Future 对象
    Future<?> f = RpcContext.getContext().getFuture();
    if (f instanceof FutureAdapter) {
        ResponseFuture future = ((FutureAdapter<?>) f).getFuture();
        // 触发回调
        future.setCallback(new ResponseCallback() {

            /**
             * 触发正常回调方法
             *
             * @param rpcResult RPC 结果
             */
            public void done(Object rpcResult) {
                if (rpcResult == null) {
                    logger.error(new IllegalStateException("invalid result value : null, expected " + Result.class.getName()));
                    return;
                }
                // must be rpcResult
                if (!(rpcResult instanceof Result)) {
                    logger.error(new IllegalStateException("invalid result type :" + rpcResult.getClass() + ", expected " + Result.class.getName()));
                    return;
                }
                Result result = (Result) rpcResult;
                if (result.hasException()) { // 触发正常回调方法
                    fireThrowCallback(invoker, invocation, result.getException());
                } else { // 触发异常回调方法
                    fireReturnCallback(invoker, invocation, result.getValue());
                }
            }

            /**
             * 触发异常回调方法
             *
             * @param exception 异常
             */
            public void caught(Throwable exception) {
                fireThrowCallback(invoker, invocation, exception);
            }
        });
    }
}
```

# 远程调用-HTTP

## 1. 概述

本文，我们分享 `http://` 协议的远程调用，主要分成**三个部分**：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-http` 。

对应文档为 [《Dubbo 用户指南 —— http://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/http.html) 。定义如下：

> 基于 HTTP 表单的远程调用协议，采用 Spring 的 **HttpInvoker** 实现

**注意**，从定义上我们可以看出，不是我们常规理解的 HTTP 调用，而是 **Spring 的 HttpInvoker** 。

本文涉及类图（红圈部分）如下：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_10_10/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_10/01.png)类图

## 2. AbstractProxyProtocol

[`com.alibaba.dubbo.rpc.protocol.AbstractProxyProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/protocol/AbstractProxyProtocol.java) ，实现 AbstractProtocol 抽象类，**Proxy** 协议抽象类。为 HttpProtocol 、RestProtocol 等子类，提供公用的服务暴露、服务引用的**公用方法**，同时定义了如下**抽象方法**，用于不同子类协议实现类的**自定义**的逻辑：

```
/**
 * 执行暴露，并返回取消暴露的回调 Runnable
 *
 * @param impl 服务 Proxy 对象
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 消暴露的回调 Runnable
 * @throws RpcException 当发生异常
 */
protected abstract <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException;

/**
 * 执行引用，并返回调用远程服务的 Service 对象
 *
 * @param type 服务接口
 * @param url URL
 * @param <T> 服务接口
 * @return 调用远程服务的 Service 对象
 * @throws RpcException 当发生异常
 */
protected abstract <T> T doRefer(Class<T> type, URL url) throws RpcException;
```

#### 2.1 构造方法

```
/**
 * 需要抛出的异常类集合，详见 {@link #reder(Class, URL)} 方法。
 */
private final List<Class<?>> rpcExceptions = new CopyOnWriteArrayList<Class<?>>();
/**
 * ProxyFactory 对象
 */
private ProxyFactory proxyFactory;

public AbstractProxyProtocol() {
}

public AbstractProxyProtocol(Class<?>... exceptions) {
    for (Class<?> exception : exceptions) {
        addRpcException(exception);
    }
}

public void addRpcException(Class<?> exception) {
    this.rpcExceptions.add(exception);
}
```

- `rpcExceptions` 属性，不同协议的远程调用，会抛出的异常是不同的。在 `#refer(Class, URL)` 方法中，我们会看到对这个属性的使用，理解会更清晰一些。

#### 2.2 export

```
/**
 * Exporter 集合
 *
 * key: 服务键 {@link #serviceKey(URL)} 或 {@link URL#getServiceKey()} 。
 *      不同协议会不同
 */
protected final Map<String, Exporter<?>> exporterMap = new ConcurrentHashMap<String, Exporter<?>>(); // FROM AbstractProtocol.java

  1: @Override
  2: @SuppressWarnings("unchecked")
  3: public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
  4:     // 获得服务键
  5:     final String uri = serviceKey(invoker.getUrl());
  6:     // 获得 Exporter 对象。若已经暴露，直接返回。
  7:     Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
  8:     if (exporter != null) {
  9:         return exporter;
 10:     }
 11:     // 执行暴露服务
 12:     final Runnable runnable = doExport(proxyFactory.getProxy(invoker), invoker.getInterface(), invoker.getUrl());
 13:     // 创建 Exporter 对象
 14:     exporter = new AbstractExporter<T>(invoker) {
 15: 
 16:         @Override
 17:         public void unexport() {
 18:             // 取消暴露
 19:             super.unexport();
 20:             exporterMap.remove(uri);
 21:             // 执行取消暴露的回调
 22:             if (runnable != null) {
 23:                 try {
 24:                     runnable.run();
 25:                 } catch (Throwable t) {
 26:                     logger.warn(t.getMessage(), t);
 27:                 }
 28:             }
 29:         }
 30: 
 31:     };
 32:     // 添加到 Exporter 集合
 33:     exporterMap.put(uri, exporter);
 34:     return exporter;
 35: }
```

- 第 5 行：调用 `#serviceKey(url)` 方法，获得服务键。代码如下：

  ```
  protected static String serviceKey(URL url) {
      return ProtocolUtils.serviceKey(url);
  }
  ```

- 第 6 至 10 行：从 `exporterMap` 中，获得 Exporter 对象。若已经暴露，直接返回。

- 第 12 行：调用 `ProxyFactory#getProxy(invoker)` 方法，获得 Service Proxy 对象。

- 第 12 行：调用 `#doExport(impl, type, url)` **抽象**方法，执行**子类实现**的暴露服务。

- 第 14 至 31 行：创建 Exporter 对象。基于 AbstractExporter 抽象类实现，覆写

   

  ```
  #unexport()
  ```

   

  方法，代码如下：

  - 第 18 至 20 行：取消暴露。
  - 第 22 至 28 行：调用 `Runnable#run()` 方法，执行取消暴露的回调方法。

- 第 33 行：添加到 Exporter 集合。

#### 2.3 refer

```
/**
 * Invoker 集合
 */
//TODO SOFEREFENCE
protected final Set<Invoker<?>> invokers = new ConcurrentHashSet<Invoker<?>>(); // FROM AbstractProtocol.java

  1: @Override
  2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
  3:     // 执行引用服务
  4:     final Invoker<T> target = proxyFactory.getInvoker(doRefer(type, url), type, url);
  5:     // 创建 Invoker 对象
  6:     Invoker<T> invoker = new AbstractInvoker<T>(type, url) {
  7: 
  8:         @Override
  9:         protected Result doInvoke(Invocation invocation) throws Throwable {
 10:             try {
 11:                 // 调用
 12:                 Result result = target.invoke(invocation);
 13:                 // 若返回结果带有异常，并且需要抛出，则抛出异常。
 14:                 Throwable e = result.getException();
 15:                 if (e != null) {
 16:                     for (Class<?> rpcException : rpcExceptions) {
 17:                         if (rpcException.isAssignableFrom(e.getClass())) {
 18:                             throw getRpcException(type, url, invocation, e);
 19:                         }
 20:                     }
 21:                 }
 22:                 return result;
 23:             } catch (RpcException e) {
 24:                 // 若是未知异常，获得异常对应的错误码
 25:                 if (e.getCode() == RpcException.UNKNOWN_EXCEPTION) {
 26:                     e.setCode(getErrorCode(e.getCause()));
 27:                 }
 28:                 throw e;
 29:             } catch (Throwable e) {
 30:                 // 抛出 RpcException 异常
 31:                 throw getRpcException(type, url, invocation, e);
 32:             }
 33:         }
 34: 
 35:     };
 36:     // 添加到 Invoker 集合。
 37:     invokers.add(invoker);
 38:     return invoker;
 39: }
```

- 第 4 行：调用 `#doRefer(type, url)` **抽象**方法，执行**子类实现**的引用服务。

- 第 4 行：调用 `ProxyFactory#getInvoker(proxy, type, url)` 方法，获得 Invoker 对象。

- 第 6 至 35 行：创建 Invoker 对象。基于 AbstractExporter 抽象类实现，覆写 `#doInvoke(invocation)` 方法，代码如下：

  - 第 12 行：调用 `Invoker#invoke(invocation)` 方法，执行 RPC 调用。

  - 第 13 至 21 行：若返回结果带有异常，并且需要抛出( 异常在 `rpcExceptions` 中)，则抛出异常。

  - 第 22 行：返回调用结果。

  - 第 23 至 28 行：若捕捉到 RpcException 异常，调用 `#getErrorCode(Throwable)` 方法，获得异常对应的错误码。代码如下：

    ```
    /**
     * 获得异常对应的错误码
     *
     * @param e 异常
     * @return 错误码
     */
    protected int getErrorCode(Throwable e) {
        return RpcException.UNKNOWN_EXCEPTION;
    }
    ```

    - 子类协议实现类，一般会覆写这个方法，实现自己异常的翻译。

  - 第 29 至 32 行：若捕捉到 Throwable 异常，调用 `#getRpcException(type, url, invocation, e)` 方法，包装成 RpcException 异常，代码如下：

    ```
    protected RpcException getRpcException(Class<?> type, URL url, Invocation invocation, Throwable e) {
        RpcException re = new RpcException("Failed to invoke remote service: " + type + ", method: "
                + invocation.getMethodName() + ", cause: " + e.getMessage(), e);
        re.setCode(getErrorCode(e));
        return re;
    }
    ```

- 第 37 行：添加到 Invoker 集合。

## 3. HttpProtocol

[`com.alibaba.dubbo.rpc.protocol.http.HttpProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-http/src/main/java/com/alibaba/dubbo/rpc/protocol/http/HttpProtocol.java) ，实现 AbstractProxyProtocol 抽象类，`dubbo://` 协议实现类。

#### 3.1 构造方法

```
/**
 * 默认服务器端口
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http 服务器集合
 *
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter 集合
 *
 * key：path 服务名
 */
private final Map<String, HttpInvokerServiceExporter> skeletonMap = new ConcurrentHashMap<String, HttpInvokerServiceExporter>();
/**
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public HttpProtocol() {
    super(RemoteAccessException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` 属性，HttpServer 集合。键为 `ip:port` ，通过 `#getAddr(url)` 方法，计算。代码如下：

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` 属性，Spring HttpInvokerServiceExporter 集合。请求处理过程为 `HttpServer => DispatcherServlet => InternalHandler => HttpInvokerServiceExporter` 。

- `httpBinder` 属性，HttpBinder$Adaptive 对象，通过 `#setHttpBinder(httpBinder)` 方法，Dubbo SPI 调用设置。

- `rpcExceptions = RemoteAccessException.class` 。

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {
 3:     // 获得服务器地址
 4:     String addr = getAddr(url);
 5:     // 获得 HttpServer 对象。若不存在，进行创建。
 6:     HttpServer server = serverMap.get(addr);
 7:     if (server == null) {
 8:         server = httpBinder.bind(url, new InternalHandler()); // InternalHandler
 9:         serverMap.put(addr, server);
10:     }
11:     // 创建 HttpInvokerServiceExporter 对象
12:     final HttpInvokerServiceExporter httpServiceExporter = new HttpInvokerServiceExporter();
13:     httpServiceExporter.setServiceInterface(type);
14:     httpServiceExporter.setService(impl);
15:     try {
16:         httpServiceExporter.afterPropertiesSet();
17:     } catch (Exception e) {
18:         throw new RpcException(e.getMessage(), e);
19:     }
20:     // 添加到 skeletonMap 中
21:     final String path = url.getAbsolutePath();
22:     skeletonMap.put(path, httpServiceExporter);
23:     // 返回取消暴露的回调 Runnable
24:     return new Runnable() {
25:         public void run() {
26:             skeletonMap.remove(path);
27:         }
28:     };
29: }
```

- 基于 `dubbo-remoting-http` 项目，作为**通信服务器**。
- 第 4 行：调用 `#getAddr(url)` 方法，获得服务器地址。
- 第 5 至 10 行：从 `serverMap` 中，获得 HttpServer 对象。若不存在，调用 `HttpBinder#bind(url, handler)` 方法，创建 HttpServer 对象。此处使用的 InternalHandler ，下文详细解析。
- 第 11 至 19 行：创建 HttpInvokerServiceExporter 对象。
- 第 20 至 22 行：添加到 `skeletonMap` 集合中。
- 第 23 至 28 行：返回取消暴露的回调 Runnable 对象。

###### 3.2.1 InternalHandler

```
private class InternalHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        String uri = request.getRequestURI();
        // 获得 HttpInvokerServiceExporter 对象
        HttpInvokerServiceExporter skeleton = skeletonMap.get(uri);
        // 必须是 POST 请求
        if (!request.getMethod().equalsIgnoreCase("POST")) {
            response.setStatus(500);
        // 执行调用
        } else {
            RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
            try {
                skeleton.handleRequest(request, response);
            } catch (Throwable e) {
                throw new ServletException(e);
            }
        }
    }

}
```

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // 创建 HttpInvokerProxyFactoryBean 对象
 5:     final HttpInvokerProxyFactoryBean httpProxyFactoryBean = new HttpInvokerProxyFactoryBean();
 6:     httpProxyFactoryBean.setServiceUrl(url.toIdentityString());
 7:     httpProxyFactoryBean.setServiceInterface(serviceType);
 8:     // 创建执行器 SimpleHttpInvokerRequestExecutor 对象
 9:     String client = url.getParameter(Constants.CLIENT_KEY);
10:     if (client == null || client.length() == 0 || "simple".equals(client)) {
11:         SimpleHttpInvokerRequestExecutor httpInvokerRequestExecutor = new SimpleHttpInvokerRequestExecutor() {
12:             protected void prepareConnection(HttpURLConnection con,
13:                                              int contentLength) throws IOException {
14:                 super.prepareConnection(con, contentLength);
15:                 con.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
16:                 con.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
17:             }
18:         };
19:         httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
20:     // 创建执行器 HttpComponentsHttpInvokerRequestExecutor 对象
21:     } else if ("commons".equals(client)) {
22:         HttpComponentsHttpInvokerRequestExecutor httpInvokerRequestExecutor = new HttpComponentsHttpInvokerRequestExecutor();
23:         httpInvokerRequestExecutor.setReadTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
24:         httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);
25:     } else {
26:         throw new IllegalStateException("Unsupported http protocol client " + client + ", only supported: simple, commons");
27:     }
28:     httpProxyFactoryBean.afterPropertiesSet();
29:     // 返回 HttpInvokerProxyFactoryBean 对象
30:     return (T) httpProxyFactoryBean.getObject();
31: }
```

- 基于 HttpClient ，作为**通信客户端**。

- 第 4 至 7 行：创建 HttpInvokerProxyFactoryBean 对象。

- 第 9 至 27 行：获得

   

  ```
  client
  ```

   

  配置项，根据该配置项，创建对应的执行器。

  - `"simple"`：第 10 至 19 行：创建执行器 SimpleHttpInvokerRequestExecutor 对象。
  - `"commons"`：第 20 至 24 行：创建执行器 HttpComponentsHttpInvokerRequestExecutor 对象。
  - 两者的差异点在于使用的 HttpClient 不同，前者使用 JDK HttpClient ，后者使用 Apache HttpClient 。

- 第 30 行：返回 HttpInvokerProxyFactoryBean 对象。

- 🙂 具体 RPC 调用的实现，在父类 `#refer()` 方法里。

###### 3.3.1 getErrorCode

```
@Override
@SuppressWarnings("Duplicates")
protected int getErrorCode(Throwable e) {
    if (e instanceof RemoteAccessException) {
        e = e.getCause();
    }
    if (e != null) {
        Class<?> cls = e.getClass();
        if (SocketTimeoutException.class.equals(cls)) {
            return RpcException.TIMEOUT_EXCEPTION;
        } else if (IOException.class.isAssignableFrom(cls)) {
            return RpcException.NETWORK_EXCEPTION;
        } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {
            return RpcException.SERIALIZATION_EXCEPTION;
        }
    }
    return super.getErrorCode(e);
}
```

- 将异常，翻译成 Dubbo 异常码。

# 远程调用-Hessian

## 1. 概述

本文，我们分享 `hessian://` 协议的远程调用，主要分成**三个部分**：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-hessian` 。

对应文档为 [《Dubbo 用户指南 —— hessian://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/hessian.html) 。定义如下：

> Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。

> Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：
>
> - 提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用
> - 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。

本文涉及类图（红圈部分）如下：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_10_13/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_13/01.png)类图

> 旁白君：整体实现和 `dubbo-rpc-http` 一致，所以内容上和 [《精尽 Dubbo 源码分析 —— 服务调用（三）之远程调用（HTTP）》](http://svip.iocoder.cn/Dubbo/rpc-http/?self) 差不多。

## 2. HttpClientConnection

`com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnection` ，实现 HessianConnection 接口，HttpClient 连接器实现类。

```
public class HttpClientConnection implements HessianConnection {

    /**
     * Apache HttpClient
     */
    private final HttpClient httpClient;

    private final ByteArrayOutputStream output;

    private final HttpPost request;

    private volatile HttpResponse response;

    public HttpClientConnection(HttpClient httpClient, URL url) {
        this.httpClient = httpClient;
        this.output = new ByteArrayOutputStream();
        this.request = new HttpPost(url.toString());
    }

    @Override
    public void addHeader(String key, String value) {
        request.addHeader(new BasicHeader(key, value));
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        return output;
    }

    @Override
    public void sendRequest() throws IOException {
        request.setEntity(new ByteArrayEntity(output.toByteArray()));
        this.response = httpClient.execute(request);
    }

    @Override
    public int getStatusCode() {
        return response == null || response.getStatusLine() == null ? 0 : response.getStatusLine().getStatusCode();
    }

    @Override
    public String getStatusMessage() {
        return response == null || response.getStatusLine() == null ? null : response.getStatusLine().getReasonPhrase();
    }

    @Override
    public String getContentEncoding() {
        return (response == null || response.getEntity() == null || response.getEntity().getContentEncoding() == null) ? null : response.getEntity().getContentEncoding().getValue();
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return response == null || response.getEntity() == null ? null : response.getEntity().getContent();
    }

    @Override
    public void close() throws IOException {
        HttpPost request = this.request;
        if (request != null) {
            request.abort();
        }
    }

    @Override
    public void destroy() throws IOException {
    }

}
```

- 基于 **Apache HttpClient** 封装。

#### 2.1 HttpClientConnectionFactory

`com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory` ，实现 HessianConnectionFactory 接口，创建 HttpClientConnection 的工厂。代码如下：

```
public class HttpClientConnectionFactory implements HessianConnectionFactory {

    /**
     * Apache HttpClient
     */
    private final HttpClient httpClient = new DefaultHttpClient();

    @Override
    public void setHessianProxyFactory(HessianProxyFactory factory) {
        HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), (int) factory.getConnectTimeout());
        HttpConnectionParams.setSoTimeout(httpClient.getParams(), (int) factory.getReadTimeout());
    }

    @Override
    public HessianConnection open(URL url) {
        return new HttpClientConnection(httpClient, url); // HttpClientConnection
    }

}
```

## 3. HessianProtocol

[`com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-hessian/src/main/java/com/alibaba/dubbo/rpc/protocol/hessian/HessianProtocol.java) ，实现 AbstractProxyProtocol 抽象类，`hessian://` 协议实现类。

#### 3.1 构造方法

```
/**
 * Http 服务器集合
 *
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * Spring HttpInvokerServiceExporter 集合
 *
 * key：path 服务名
 */
private final Map<String, HessianSkeleton> skeletonMap = new ConcurrentHashMap<String, HessianSkeleton>();
/**
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public HessianProtocol() {
    super(HessianException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` 属性，HttpServer 集合。键为 `ip:port` ，通过 `#getAddr(url)` 方法，计算。代码如下：

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` 属性，`com.caucho.hessian.server.HessianSkeleton` 集合。请求处理过程为 `HttpServer => DispatcherServlet => HessianHandler => HessianSkeleton` 。

- `httpBinder` 属性，HttpBinder$Adaptive 对象，通过 `#setHttpBinder(httpBinder)` 方法，Dubbo SPI 调用设置。

- `rpcExceptions = HessianException.class` 。

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // 获得服务器地址
 4:     String addr = getAddr(url);
 5:     // 获得 HttpServer 对象。若不存在，进行创建。
 6:     HttpServer server = serverMap.get(addr);
 7:     if (server == null) {
 8:         server = httpBinder.bind(url, new HessianHandler()); // HessianHandler
 9:         serverMap.put(addr, server);
10:     }
11:     // 添加到 skeletonMap 中
12:     final String path = url.getAbsolutePath();
13:     HessianSkeleton skeleton = new HessianSkeleton(impl, type);
14:     skeletonMap.put(path, skeleton);
15:     // 返回取消暴露的回调 Runnable
16:     return new Runnable() {
17:         public void run() {
18:             skeletonMap.remove(path);
19:         }
20:     };
21: }
```

- 基于 `dubbo-remoting-http` 项目，作为**通信服务器**。
- 第 4 行：调用 `#getAddr(url)` 方法，获得服务器地址。
- 第 5 至 10 行：从 `serverMap` 中，获得 HttpServer 对象。若不存在，调用 `HttpBinder#bind(url, handler)` 方法，创建 HttpServer 对象。此处使用的 HessianHandler ，下文详细解析。
- 第 11 至 14 行：创建 HessianSkeleton 对象，添加到 `skeletonMap` 集合中。
- 第 15 至 20 行：返回取消暴露的回调 Runnable 对象。

###### 3.2.1 HessianHandler

```
private class HessianHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response)
            throws IOException, ServletException {
        String uri = request.getRequestURI();
        // 获得 HessianSkeleton 对象
        HessianSkeleton skeleton = skeletonMap.get(uri);
        // 必须是 POST 请求
        if (!request.getMethod().equalsIgnoreCase("POST")) {
            response.setStatus(500);
        // 执行调用
        } else {
            RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
            try {
                skeleton.invoke(request.getInputStream(), response.getOutputStream());
            } catch (Throwable e) {
                throw new ServletException(e);
            }
        }
    }

}
```

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {
 4:     // 创建 HessianProxyFactory 对象
 5:     HessianProxyFactory hessianProxyFactory = new HessianProxyFactory();
 6:     // 创建连接器工厂为 HttpClientConnectionFactory 对象，即 Apache HttpClient
 7:     String client = url.getParameter(Constants.CLIENT_KEY, Constants.DEFAULT_HTTP_CLIENT);
 8:     if ("httpclient".equals(client)) {
 9:         hessianProxyFactory.setConnectionFactory(new HttpClientConnectionFactory());
10:     } else if (client != null && client.length() > 0 && !Constants.DEFAULT_HTTP_CLIENT.equals(client)) {
11:         throw new IllegalStateException("Unsupported http protocol client=\"" + client + "\"!");
12:     }
13:     // 设置超时时间
14:     int timeout = url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);
15:     hessianProxyFactory.setConnectTimeout(timeout);
16:     hessianProxyFactory.setReadTimeout(timeout);
17:     // 创建 Service Proxy 对象
18:     return (T) hessianProxyFactory.create(serviceType, url.setProtocol("http").toJavaURL(), Thread.currentThread().getContextClassLoader());
19: }
```

- 基于 HttpClient ，作为**通信客户端**。
- 第 5 行：创建 `com.caucho.hessian.client.HessianProxyFactory` 对象。
- 第 6 至 12 行：创建**连接器工厂**为 `com.alibaba.dubbo.rpc.protocol.hessian.HttpClientConnectionFactory` 。
- 第 13 至 16 行：设置超时时间。
- 第 18 行：调用 `HessianProxyFactory#create(Class<?> api, URL url, ClassLoader loader)` 方法，生成 Service Proxy 对象。

###### 3.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof HessianConnectionException) {
        if (e.getCause() != null) {
            Class<?> cls = e.getCause().getClass();
            if (SocketTimeoutException.class.equals(cls)) {
                return RpcException.TIMEOUT_EXCEPTION;
            }
        }
        return RpcException.NETWORK_EXCEPTION;
    } else if (e instanceof HessianMethodSerializationException) {
        return RpcException.SERIALIZATION_EXCEPTION;
    }
    return super.getErrorCode(e);
}
```

- 将异常，翻译成 Dubbo 异常码。

#### 3.4 destroy

```
@Override
public void destroy() {
    // 销毁
    super.destroy();
    // 销毁 HttpServer
    for (String key : new ArrayList<String>(serverMap.keySet())) {
        HttpServer server = serverMap.remove(key);
        if (server != null) {
            try {
                if (logger.isInfoEnabled()) {
                    logger.info("Close hessian server " + server.getUrl());
                }
                server.close();
            } catch (Throwable t) {
                logger.warn(t.getMessage(), t);
            }
        }
    }
}
```

- 这部分是 `dubbo-rpc-http` 所缺失的。

# 远程调用-WebService

## 1. 概述

本文，我们分享 `webservice://` 协议的远程调用，主要分成**三个部分**：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-webservice` 。

对应文档为 [《Dubbo 用户指南 —— webservice://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/webservice.html) 。定义如下：

> 基于 WebService 的远程调用协议，基于 [Apache CXF](http://cxf.apache.org/) 的 frontend-simple 和 transports-http 实现。

> 可以和原生 WebService 服务互操作，即：
>
> - 提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，
> - 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。

本文涉及类图（红圈部分）如下：

![类图](http://static.iocoder.cn/images/Dubbo/2018_10_16/01.png)

> 旁白君：整体实现和 `dubbo-rpc-http` 一致，所以内容上和 [《精尽 Dubbo 源码分析 —— 服务调用（三）之远程调用（HTTP）》](http://svip.iocoder.cn/Dubbo/rpc-http/?self) 差不多。

## 2. WebServiceProtocol

[`com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-webservice/src/main/java/com/alibaba/dubbo/rpc/protocol/webservice/WebServiceProtocol.java) ，实现 AbstractProxyProtocol 抽象类，`webservice://` 协议实现类。

#### 2.1 构造方法

```
/**
 * 默认服务器端口
 */
public static final int DEFAULT_PORT = 80;
/**
 * Http 服务器集合
 *
 * key：ip:port
 */
private final Map<String, HttpServer> serverMap = new ConcurrentHashMap<String, HttpServer>();
/**
 * 《我眼中的CXF之Bus》http://jnn.iteye.com/blog/94746
 * 《CXF BUS》https://blog.csdn.net/chen_fly2011/article/details/56664908
 */
private final ExtensionManagerBus bus = new ExtensionManagerBus();
/**
 *
 */
private final HTTPTransportFactory transportFactory = new HTTPTransportFactory();
/**
 * HttpBinder$Adaptive 对象
 */
private HttpBinder httpBinder;

public WebServiceProtocol() {
    super(Fault.class);
    bus.setExtension(new ServletDestinationFactory(), HttpDestinationFactory.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- `serverMap` 属性，HttpServer 集合。键为 `ip:port` ，通过 `#getAddr(url)` 方法，计算。代码如下：

  ```
  // AbstractProxyProtocol.java
  protected String getAddr(URL url) {
      String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
      if (url.getParameter(Constants.ANYHOST_KEY, false)) {
          bindIp = Constants.ANYHOST_VALUE;
      }
      return NetUtils.getIpByHost(bindIp) + ":" + url.getParameter(Constants.BIND_PORT_KEY, url.getPort());
  }
  ```

- `skeletonMap` 属性，`com.caucho.hessian.server.HessianSkeleton` 集合。请求处理过程为 `HttpServer => DispatcherServlet => WebServiceHandler => ServletController` 。

- `httpBinder` 属性，HttpBinder$Adaptive 对象，通过 `#setHttpBinder(httpBinder)` 方法，Dubbo SPI 调用设置。

- `rpcExceptions = Fault.class` 。

- ```
  bus
  ```

   

  和

   

  ```
  transportFactory
  ```

   

  属性，可以参看如下文章：

  - [《我眼中的CXF之Bus》](http://jnn.iteye.com/blog/94746)
  - [《CXF BUS》](https://blog.csdn.net/chen_fly2011/article/details/56664908)

- 🙂 艿艿对 Apache CXF 了解不多，所以本文更多梳理好整体脉络。

#### 2.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // 获得服务器地址
 4:     String addr = getAddr(url);
 5:     // 获得 HttpServer 对象。若不存在，进行创建。
 6:     HttpServer httpServer = serverMap.get(addr);
 7:     if (httpServer == null) {
 8:         httpServer = httpBinder.bind(url, new WebServiceHandler()); // WebServiceHandler
 9:         serverMap.put(addr, httpServer);
10:     }
11:     // 创建 ServerFactoryBean 对象
12:     final ServerFactoryBean serverFactoryBean = new ServerFactoryBean();
13:     serverFactoryBean.setAddress(url.getAbsolutePath());
14:     serverFactoryBean.setServiceClass(type);
15:     serverFactoryBean.setServiceBean(impl);
16:     serverFactoryBean.setBus(bus);
17:     serverFactoryBean.setDestinationFactory(transportFactory);
18:     serverFactoryBean.create();
19:     // 返回取消暴露的回调 Runnable
20:     return new Runnable() {
21:         public void run() {
22:             serverFactoryBean.destroy();
23:         }
24:     };
25: }
```

- 基于 `dubbo-remoting-http` 项目，作为**通信服务器**。
- 第 4 行：调用 `#getAddr(url)` 方法，获得服务器地址。
- 第 5 至 10 行：从 `serverMap` 中，获得 HttpServer 对象。若不存在，调用 `HttpBinder#bind(url, handler)` 方法，创建 HttpServer 对象。此处使用的 WebServiceHandler ，下文详细解析。
- 第 11 至 18 行：创建 ServerFactoryBean 对象。
- 第 19 至 24 行：返回取消暴露的回调 Runnable 对象。

###### 2.2.1 WebServiceHandler

```
private class WebServiceHandler implements HttpHandler {

    private volatile ServletController servletController;

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        // 创建 ServletController 对象，设置使用 DispatcherServlet 。
        if (servletController == null) {
            HttpServlet httpServlet = DispatcherServlet.getInstance();
            if (httpServlet == null) {
                response.sendError(500, "No such DispatcherServlet instance.");
                return;
            }
            synchronized (this) {
                if (servletController == null) {
                    servletController = new ServletController(transportFactory.getRegistry(), httpServlet.getServletConfig(), httpServlet);
                }
            }
        }
        // 设置调用方地址
        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
        // 执行调用
        servletController.invoke(request, response);
    }

}
```

#### 2.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // 创建 ClientProxyFactoryBean 对象
 5:     ClientProxyFactoryBean proxyFactoryBean = new ClientProxyFactoryBean();
 6:     proxyFactoryBean.setAddress(url.setProtocol("http").toIdentityString());
 7:     proxyFactoryBean.setServiceClass(serviceType);
 8:     proxyFactoryBean.setBus(bus);
 9:     // 创建 Service Proxy 对象
10:     T ref = (T) proxyFactoryBean.create();
11:     // 设置超时相关属性
12:     Client proxy = ClientProxy.getClient(ref);
13:     HTTPConduit conduit = (HTTPConduit) proxy.getConduit();
14:     HTTPClientPolicy policy = new HTTPClientPolicy();
15:     policy.setConnectionTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));
16:     policy.setReceiveTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
17:     conduit.setClient(policy);
18:     return ref;
19: }
```

- 第 4 至 8 行：创建 ClientProxyFactoryBean 对象。
- 第 10 行：创建 Service Proxy 对象。
- 第 11 至 17 行：设置**超时相关**属性。

###### 2.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof Fault) {
        e = e.getCause();
    }
    if (e instanceof SocketTimeoutException) {
        return RpcException.TIMEOUT_EXCEPTION;
    } else if (e instanceof IOException) {
        return RpcException.NETWORK_EXCEPTION;
    }
    return super.getErrorCode(e);
}
```

- 将异常，翻译成 Dubbo 异常码。

# 远程调用-REST

## 1. 概述

本文，我们分享 `rest://` 协议的远程调用，主要分成**三个部分**：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-rest` 。

对应文档为 [《在Dubbo中开发REST风格的远程调用（RESTful Remoting）》](https://dangdangdotcom.github.io/dubbox/rest.html) 。

> 我们基于标准的 Java REST API——JAX-RS 2.0（Java API for RESTful Web Services s的简写），为 dubbo 提供了接近透明的 REST 调用支持。由于完全兼容 Java 标准 AP I，所以为 dubbo 开发的所有REST服务，未来脱离 dubbo 或者任何特定的 REST 底层实现一般也可以正常运行。

下面，我们来看看 JAX-RS 的简介：

> JAX-RS 是标准的 Java REST API ，得到了业界的广泛支持和应用，其著名的开源实现就有很多，包括 Oracle 的 Jersey ，RedHat 的 Resteasy ，Apache 的 CXF 和 Wink ，以及restlet 等等。另外，所有支持 JavaEE 6.0 以上规范的商用 JavaEE 应用服务器都对 JAX-RS 提供了支持。因此，JAX-RS 是一种已经非常成熟的解决方案，并且采用它没有任何所谓 vendor lock-in 的问题。

在 `dubbo-rpc-rest` 项目中，目前使用使用的是 RedHat 的 **Resteasy** 。在 `pom.xml` 引入如下：

```
<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-jaxrs</artifactId>
</dependency>

<dependency>
    <groupId>org.jboss.resteasy</groupId>
    <artifactId>resteasy-client</artifactId>
</dependency>

// 还有其他可选的 resteasy 相关的引用，此处暂时省略。
```

因为本文会涉及到大量的 Resteasy 的原理，艿艿看了 [《RESTEASY ,从学会使用到了解原理》](http://www.cnblogs.com/langtianya/p/7624647.html) ，觉得非常不错，胖友一定要看噢。😈 也就是说，本文不会重复详细分享 Resteasy 的原理，哈哈哈。

本文涉及的类，如下图：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_10_19/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_19/01.png)类图

我们先来看看 RestProtocol 的实现代码，然后再看其他层的实现。

## 2. RestProtocol

[`com.alibaba.dubbo.rpc.protocol.rest.RestProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestProtocol.java) ，实现 AbstractProxyProtocol 抽象类，`rest://` 协议实现类。

#### 2.1 构造方法

```
/**
 * 服务器默认端口
 */
private static final int DEFAULT_PORT = 80;

/**
 * 服务器集合
 *
 * key：ip:port
 */
private final Map<String, RestServer> servers = new ConcurrentHashMap<String, RestServer>();
/**
 * 服务器工厂，负责创建服务器
 */
private final RestServerFactory serverFactory = new RestServerFactory();
/**
 * 客户端数组
 */
// TODO in the future maybe we can just use a single rest client and connection manager
private final List<ResteasyClient> clients = Collections.synchronizedList(new LinkedList<ResteasyClient>());
/**
 * 连接监控器
 */
private volatile ConnectionMonitor connectionMonitor;

public RestProtocol() {
    super(WebApplicationException.class, ProcessingException.class);
}

public void setHttpBinder(HttpBinder httpBinder) {
    serverFactory.setHttpBinder(httpBinder);
}

public int getDefaultPort() {
    return DEFAULT_PORT;
}
```

- 服务暴露相关属性：`servers` `serverFactory` 。
- 服务引用相关属性：`clients` `connectionMonitor` 。
- `rpcExceptions = WebApplicationException.class 和 ProcessingException.class` 。
- `#setHttpBinder(httpBinder)` 方法，在 RestProtocol 对象创建时，被 Dubbo SPI 机制调用，向 `serverFactory` 注入 `httpBinder` 属性。为什么这么做？在 RestServerFactory 的实现代码中，我们会看到原因。

#### 2.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(T impl, Class<T> type, URL url) throws RpcException {
 3:     // 获得服务器地址
 4:     String addr = getAddr(url);
 5:     // 获得服务的真实类名，例如 DemoServiceImpl
 6:     Class implClass = ServiceClassHolder.getInstance().popServiceClass();
 7:     // 获得 RestServer 对象。若不存在，进行创建。
 8:     RestServer server = servers.get(addr);
 9:     if (server == null) {
10:         server = serverFactory.createServer(url.getParameter(Constants.SERVER_KEY, "jetty"));
11:         server.start(url); // 启动
12:         servers.put(addr, server);
13:     }
14: 
15:     // 获得 ContextPath 路径。
16:     String contextPath = getContextPath(url);
17:     if ("servlet".equalsIgnoreCase(url.getParameter(Constants.SERVER_KEY, "jetty"))) { // 外部的容器，需要从 ServletContext 中获得。
18:         ServletContext servletContext = ServletManager.getInstance().getServletContext(ServletManager.EXTERNAL_SERVER_PORT);
19:         if (servletContext == null) {
20:             throw new RpcException("No servlet context found. Since you are using server='servlet', " +
21:                     "make sure that you've configured " + BootstrapListener.class.getName() + " in web.xml");
22:         }
23:         String webappPath = servletContext.getContextPath();
24:         if (StringUtils.isNotEmpty(webappPath)) {
25:             // 去掉 `/` 起始
26:             webappPath = webappPath.substring(1);
27:             // 校验 URL 中配置的 `contextPath` 是外部容器的 `contextPath` 起始。
28:             if (!contextPath.startsWith(webappPath)) {
29:                 throw new RpcException("Since you are using server='servlet', " +
30:                         "make sure that the 'contextpath' property starts with the path of external webapp");
31:             }
32:             // 截取掉起始部分
33:             contextPath = contextPath.substring(webappPath.length());
34:             // 去掉 `/` 起始
35:             if (contextPath.startsWith("/")) {
36:                 contextPath = contextPath.substring(1);
37:             }
38:         }
39:     }
40:     // 获得以 `@Path` 为注解的基础类，一般情况下，我们直接在 `implClass` 上添加了该注解，即就是 `implClass` 类。
41:     final Class resourceDef = GetRestful.getRootResourceClass(implClass) != null ? implClass : type;
42:     // 部署到服务器上
43:     server.deploy(resourceDef, impl, contextPath);
44:     // 返回取消暴露的回调 Runnable
45:     final RestServer s = server;
46:     return new Runnable() {
47:         public void run() {
48:             // TODO due to dubbo's current architecture,
49:             // it will be called from registry protocol in the shutdown process and won't appear in logs
50:             s.undeploy(resourceDef);
51:         }
52:     };
53: }
```

- 第 4 行：调用 `#getAddr(url)` 方法，获得服务器地址 `ip:port` 。

- 第 6 行：调用 `ServiceClassHolder#popServiceClass()` 方法，获得服务的真实类名，例如：DemoServiceImpl 。在 ServiceConfig 初始化时，会调用如下代码：

  ```
  ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));
  ```

  - 当然，这不是一个优雅的实现，未来可能会重构优化这块的代码。

- 第 7 至 13 行：从 `servers` 中，获得 RestServer 对象。若不存在，调用 `RestServerFactory#createServer(url)` 方法进行创建，并且，调用 `RestServer#start(url)` 方法，进行启动。

- 第 15 至 39 行：调用 `#getContextPath(url)` 方法，获得 ContextPath 路径。代码如下：

  ```
  protected String getContextPath(URL url) {
      int pos = url.getPath().lastIndexOf("/"); // 尾部 / 之后
      return pos > 0 ? url.getPath().substring(0, pos) : "";
  }
  ```

- 第 41 行：获得以 `@Path` 为注解的基础类，一般情况下，我们直接在 `implClass` 上添加了该注解，即就是 `implClass` 类。当然，官方有一段话非常关键，如下：

  > **Annotation放在接口类还是实现类**

  > 在Dubbo 中开发 REST 服务主要都是通过 JAX-RS 的 annotation 来完成配置的，在上面的示例中，我们都是将 annotation 放在服务的实现类中。但其实，我们完全也可以将 annotation 放到服务的接口上，这两种方式是完全等价的。
  >
  > 在一般应用中，我们建议将 annotation 放到服务实现类，这样 annotation 和 java 实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。
  >
  > 【关键】
  > *但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。*
  >
  > 如果接口和实现类都同时添加了annotation，则实现类的 annotation 配置会生效，接口上的 annotation 被直接忽略。

- 第 43 行：调用 `RestServer#deploy(resourceDef, impl, contextPath)` 方法，部署 Service 到服务器上。到了此处，服务暴露就已经完成，那么**请求是如何调度到 Service 的呢**？在 [「3. RestServer」](http://svip.iocoder.cn/Dubbo/rpc-rest/#) 详细解析。

- 第 44 至 52 行：返回取消暴露的回调 Runnable 。

#### 2.3 doRefer

```
 1: @Override
 2: protected <T> T doRefer(Class<T> serviceType, URL url) throws RpcException {
 3:     // 创建 ConnectionMonitor 对象。
 4:     if (connectionMonitor == null) {
 5:         connectionMonitor = new ConnectionMonitor();
 6:     }
 7: 
 8:     // 创建 HttpClient 连接池管理器
 9:     // TODO more configs to add
10:     PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
11:     // 20 is the default maxTotal of current PoolingClientConnectionManager
12:     connectionManager.setMaxTotal(url.getParameter(Constants.CONNECTIONS_KEY, 20)); // 最大请求数
13:     connectionManager.setDefaultMaxPerRoute(url.getParameter(Constants.CONNECTIONS_KEY, 20)); // 每个路由，最大请求数
14:     // 添加到 ConnectionMonitor 中。
15:     connectionMonitor.addConnectionManager(connectionManager);
16: 
17:     // 创建 RequestConfig 对象
18:     RequestConfig requestConfig = RequestConfig.custom()
19:             .setConnectTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)) // 连接超时
20:             .setSocketTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)) // 请求超时
21:             .build();
22:     // 创建 SocketConfig 对象
23:     SocketConfig socketConfig = SocketConfig.custom()
24:             .setSoKeepAlive(true) // 保持连接
25:             .setTcpNoDelay(true)
26:             .build();
27:     // 创建 HttpClient 对象 【Apache】
28:     CloseableHttpClient httpClient = HttpClientBuilder.create()
29:             .setKeepAliveStrategy(new ConnectionKeepAliveStrategy() { // 优先以服务器返回的为准，缺省为 30 秒。
30:                 public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
31:                     HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE));
32:                     while (it.hasNext()) {
33:                         HeaderElement he = it.nextElement();
34:                         String param = he.getName();
35:                         String value = he.getValue();
36:                         if (value != null && param.equalsIgnoreCase("timeout")) {
37:                             return Long.parseLong(value) * 1000;
38:                         }
39:                     }
40:                     // TODO constant
41:                     return 30 * 1000;
42:                 }
43:             })
44:             .setDefaultRequestConfig(requestConfig)
45:             .setDefaultSocketConfig(socketConfig)
46:             .build();
47: 
48:     // 创建 ApacheHttpClient4Engine 对象 【Resteasy】
49:     ApacheHttpClient4Engine engine = new ApacheHttpClient4Engine(httpClient/*, localContext*/);
50:     // 创建 ResteasyClient 对象 【Resteasy】
51:     ResteasyClient client = new ResteasyClientBuilder().httpEngine(engine).build();
52:     // 添加到客户端集合
53:     clients.add(client);
54: 
55:     // 设置 RpcContextFilter 过滤器
56:     client.register(RpcContextFilter.class);
57:     // 从 `extension` 配置项，设置对应的组件（过滤器 Filter 、拦截器 Interceptor 、异常匹配器 ExceptionMapper 等等）。
58:     for (String clazz : Constants.COMMA_SPLIT_PATTERN.split(url.getParameter(Constants.EXTENSION_KEY, ""))) {
59:         if (!StringUtils.isEmpty(clazz)) {
60:             try {
61:                 client.register(Thread.currentThread().getContextClassLoader().loadClass(clazz.trim()));
62:             } catch (ClassNotFoundException e) {
63:                 throw new RpcException("Error loading JAX-RS extension class: " + clazz.trim(), e);
64:             }
65:         }
66:     }
67: 
68:     // 创建 Service Proxy 对象。
69:     // TODO protocol
70:     ResteasyWebTarget target = client.target("http://" + url.getHost() + ":" + url.getPort() + "/" + getContextPath(url));
71:     return target.proxy(serviceType);
72: }
```

- 第 3 至 6 行：创建 ConnectionMonitor 对象。

- 第 8 至 15 行：创建 HttpClient 连接池管理器，设置**请求数**相关配置，并且添加到 ConnectionMonitor 中。

- 第 17 至 46 行：创建 **Apache** HttpClient 对象。

  - 第 17 至 21 行：创建 RequestConfig 对象，设置**超时**相关配置。

  - 第 22 至 26 行：创建 SocketConfig 对象，设置**连接**相关配置。

  - 第 29 至 43 行：创建 ConnectionKeepAliveStrategy 对象，优先以服务器返回 `Keep-Alive` 为准，缺省为 30 秒。参见文章 [《HttpClient4.5.2 连接管理》](http://study121007.iteye.com/blog/2304274) 的 **[2.6. 连接存活策略](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** ：

    > Http 规范没有规定一个持久连接应该保持存活多久。有些 Http 服务器使用非标准的 Keep-Alive 头消息和客户端进行交互，服务器端会保持数秒时间内保持连接。HttpClient 也会利用这个头消息。如果服务器返回的响应中没有包含 Keep-Alive 头消息，HttpClient会认为这个连接可以永远保持。然而，很多服务器都会在不通知客户端的情况下，关闭一定时间内不活动的连接，来节省服务器资源。在某些情况下默认的策略显得太乐观，我们可能需要自定义连接存活策略。

- 第 48 至 53 行：创建 **Resteasy** ResteasyClient 对象，并且添加到客户端集合 `clients` 中。

- 第 55 行：调用 `ResteasyClient#register(Class<?> componentClass)` 方法，注册 RpcContextFilter 到 ResteasyClient 中。

- 第 57 至 66 行：从 `extension` 配置项，设置对应的组件（过滤器 Filter 、拦截器 Interceptor 、异常匹配器 ExceptionMapper 等等）。详细说明，参见 [《在Dubbo中开发REST风格的远程调用（RESTful Remoting）》](https://dangdangdotcom.github.io/dubbox/rest.html) 的 **[添加自定义的Filter、Interceptor等](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** 。

- 第 68 至 71 行：创建 ResteasyWebTarget 对象，并调用 `ResteasyWebTarget#proxy(serviceType)` 方法，创建 **Service Proxy** 对象。

- **注意**，上文也提到了，如果使用 Dubbo `rest://` Consumer ，需要将 JAX-RS 的**注解** 到 Service 接口类中，否则，请求的参数和方法的参数，无法映射上。

###### 2.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    // TODO
    return super.getErrorCode(e);
}
```

- 目前，暂未实现异常翻译成 Dubbo 的错误码。
- 🙂 一般情况下，我们不使用 Dubbo `rest://` Consumer ，而是让 Dubbo 暴露 `dubbo://` 服务，使用 Dubbo `dubbo://` Consumer 。

###### 2.3.2 ConnectionMonitor

```
protected class ConnectionMonitor extends Thread {

    /**
     * 是否关闭
     */
    private volatile boolean shutdown;
    /**
     * HttpClient 连接池管理器集合
     */
    private final List<PoolingHttpClientConnectionManager> connectionManagers = Collections.synchronizedList(new LinkedList<PoolingHttpClientConnectionManager>());

    public void addConnectionManager(PoolingHttpClientConnectionManager connectionManager) {
        connectionManagers.add(connectionManager);
    }

    @Override
    public void run() {
        try {
            while (!shutdown) {
                synchronized (this) {
                    // 等待 1000 ms
                    wait(1000); // 可被下面 shutdown() 方法，强行关闭
                    for (PoolingHttpClientConnectionManager connectionManager : connectionManagers) {
                        connectionManager.closeExpiredConnections();
                        // TODO constant
                        connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                    }
                }
            }
        } catch (InterruptedException ex) {
            shutdown();
        }
    }

    public void shutdown() {
        // 标记关闭
        shutdown = true;
        // 清除管理器集合
        connectionManagers.clear();
        // 唤醒等待线程
        synchronized (this) {
            notifyAll();
        }
    }

}
```

- 为什么有了**连接池**，还需要有这样一个 Monitor 呢？参见文章 [《HttpClient4.5.2 连接管理》](http://study121007.iteye.com/blog/2304274) 的 **[2.5. 连接回收策略](http://svip.iocoder.cn/Dubbo/rpc-rest/#)** ：

  > 经典阻塞 I/O 模型的一个主要缺点就是只有当组侧 I/O 时，socket 才能对 I/O 事件做出反应。当连接被管理器收回后，这个连接仍然存活，但是却无法监控socket的状态，也无法对I/O事件做出反馈。如果连接被服务器端关闭了，客户端监测不到连接的状态变化（也就无法根据连接状态的变化，关闭本地的 socket ）。
  >
  > HttpClient为了缓解这一问题造成的影响，会在使用某个连接前，监测这个连接是否已经过时，如果服务器端关闭了连接，那么连接就会失效。这种过时检查并不是 100% 有效，并且会给每个请求增加 10 到 30 毫秒额外开销。唯一一个可行的，且 does not involve a one thread per socket model for idle connections 的解决办法，是建立一个监控线程，来专门回收由于长时间不活动而被判定为失效的连接。这个监控线程可以周期性的调用ClientConnectionManager 类的 closeExpiredConnections() 方法来关闭过期的连接，回收连接池中被关闭的连接。它也可以选择性的调用 ClientConnectionManager 类的 closeIdleConnections() 方法来关闭一段时间内不活动的连接。

#### 2.4 destroy

```
@Override
public void destroy() {
    // 父类销毁
    super.destroy();

    // 关闭 ConnectionMonitor
    if (connectionMonitor != null) {
        connectionMonitor.shutdown();
    }

    // 关闭服务器
    for (Map.Entry<String, RestServer> entry : servers.entrySet()) {
        try {
            if (logger.isInfoEnabled()) {
                logger.info("Closing the rest server at " + entry.getKey());
            }
            entry.getValue().stop();
        } catch (Throwable t) {
            logger.warn("Error closing rest server", t);
        }
    }
    servers.clear();

    // 关闭客户端
    if (logger.isInfoEnabled()) {
        logger.info("Closing rest clients");
    }
    for (ResteasyClient client : clients) {
        try {
            client.close();
        } catch (Throwable t) {
            logger.warn("Error closing rest client", t);
        }
    }
    clients.clear();
}
```

## 3. Server

#### 3.1 RestServer

[`com.alibaba.dubbo.rpc.protocol.rest.RestServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestServer.java) ，Rest Server 接口。方法如下：

```
public interface RestServer {

    /**
     * 启动服务器
     *
     * @param url URL 对象
     */
    void start(URL url);

    /**
     * 停止服务器
     */
    void stop();

    /**
     * 部署服务
     *
     * @param resourceDef 服务类
     * @param resourceInstance 服务对象
     * @param contextPath ContextPath
     */
    void deploy(Class resourceDef, Object resourceInstance, String contextPath);

    /**
     * 取消服务
     *
     * @param resourceDef 服务类
     */
    void undeploy(Class resourceDef);

}
```

- 两对方法：`start(...)` 和 `stop()` 方法，`#deploy(...)` 和 `undeploy(...)` 方法。

#### 3.2 BaseRestServer

[`com.alibaba.dubbo.rpc.protocol.rest.BaseRestServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/BaseRestServer.java) ，实现 RestServer 接口，Rest Server **抽象基类**。

###### 3.2.1 抽象方法

```
protected abstract ResteasyDeployment getDeployment();

protected abstract void doStart(URL url);
```

###### 3.2.2 start

```
 1: @Override
 2: public void start(URL url) {
 3:     // 添加 MediaType
 4:     getDeployment().getMediaTypeMappings().put("json", "application/json");
 5:     getDeployment().getMediaTypeMappings().put("xml", "text/xml");
 6: //    server.getDeployment().getMediaTypeMappings().put("xml", "application/xml");
 7:     // 添加过滤器 RpcContextFilter
 8:     getDeployment().getProviderClasses().add(RpcContextFilter.class.getName());
 9:     // TODO users can override this mapper, but we just rely on the current priority strategy of resteasy
10:     // 添加异常匹配 RpcExceptionMapper
11:     getDeployment().getProviderClasses().add(RpcExceptionMapper.class.getName());
12:     // 从 `extension` 配置项，添加对应的组件（过滤器 Filter 、拦截器 Interceptor 、异常匹配器 ExceptionMapper 等等）
13:     loadProviders(url.getParameter(Constants.EXTENSION_KEY, ""));
14: 
15:     // 启动服务器
16:     doStart(url);
17: }
```

- 第 3 至 5 行：添加 `json` `xml` 两个 MediaType 。

- 第 8 行：添加过滤器 RpcContextFilter 。这个过滤器，我们在 ResteasyClient 的初始化时，也看到了。

- 第 9 行：添加异常匹配 RpcExceptionMapper 。

- 第 13 行：调用 `#loadProviders(value)` 方法，从 `extension` 配置项，添加对应的组件（过滤器 Filter 、拦截器 Interceptor 、异常匹配器 ExceptionMapper 等等）。这块代码，们在 ResteasyClient 的初始化时，也看到了。代码如下：

  ```
  protected void loadProviders(String value) {
      for (String clazz : Constants.COMMA_SPLIT_PATTERN.split(value)) {
          if (!StringUtils.isEmpty(clazz)) {
              getDeployment().getProviderClasses().add(clazz.trim());
          }
      }
  }
  ```

- 第 16 行：调用 `#doStart(url)` **抽象**方法，启动服务器。

###### 3.2.3 deploy

```
@Override
public void deploy(Class resourceDef, Object resourceInstance, String contextPath) {
    if (StringUtils.isEmpty(contextPath)) {
        getDeployment().getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef));
    } else {
        getDeployment().getRegistry().addResourceFactory(new DubboResourceFactory(resourceInstance, resourceDef), contextPath);
    }
}
```

- 调用 `ResteasyDeployment#addResourceFactory(ResourceFactory)` 方法，部署 Service 服务。这里，如果类比 SpringMVC ，就是添加 `@RestController` 注解的类。
- [`com.alibaba.dubbo.rpc.protocol.rest.DubboResourceFactory`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboResourceFactory.java) ，比较易懂，胖友自己看哈。
- 到了此处，我们就可以看一下 Resteasy 的请求处理过程，如下图所示：

> FROM [《RESTEASY ,从学会使用到了解原理》](http://www.cnblogs.com/langtianya/p/7624647.html) *基础上修改*
>
> [![流程](http://static.iocoder.cn/images/Dubbo/2018_10_19/02.png)](http://static.iocoder.cn/images/Dubbo/2018_10_19/02.png)流程
>
> - HttpServletDispatcher ：接受并分发客户端 http 请求
> - ResourceFactory ：负责处理客户端请求的对象由谁来负责处理
> - Registry ：
>   - 服务器启动时加载用户自定义Rest资源时，会解析上面的注解，并将注解相对路径和该类中执行的方法建立对应关系注册到 Registry 中。
>   - 当客户端请求过来时会根据请求中的相对路径去 Registry 中查找对应的 Invoker 对象，然后执行并将处理结果返回。

🙂 是不是一下子就清晰了，世界又明亮了？！

###### 3.2.4 undeploy

```
@Override
public void undeploy(Class resourceDef) {
    getDeployment().getRegistry().removeRegistrations(resourceDef);
}
```

#### 3.3 NettyHttpServer

[`com.alibaba.dubbo.rpc.protocol.rest.NettyHttpServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/NettyHttpServer.java) ，实现 BaseRestServer 抽象基类，基于 Netty 的 HTTP 服务器实现类。

**注意**，NettyHttpServer 不是 Servlet Container ，所以不能使用 `@Context` 注解。

###### 3.3.1 doStart

```
private final NettyJaxrsServer server = new NettyJaxrsServer();

  1: @Override
  2: protected void doStart(URL url) {
  3:     // 设置 NettyJaxrsServer 的属性
  4:     String bindIp = url.getParameter(Constants.BIND_IP_KEY, url.getHost());
  5:     if (!url.isAnyHost() && NetUtils.isValidLocalHost(bindIp)) {
  6:         server.setHostname(bindIp); // Hostname
  7:     }
  8:     server.setPort(url.getParameter(Constants.BIND_PORT_KEY, url.getPort())); // Port
  9:     Map<ChannelOption, Object> channelOption = new HashMap<ChannelOption, Object>();
 10:     channelOption.put(ChannelOption.SO_KEEPALIVE, url.getParameter(Constants.KEEP_ALIVE_KEY, Constants.DEFAULT_KEEP_ALIVE)); // Keep-Alive
 11:     server.setChildChannelOptions(channelOption);
 12:     server.setExecutorThreadCount(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)); // 执行线程数
 13:     server.setIoWorkerCount(url.getParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS)); // IO 线程数
 14:     server.setMaxRequestSize(url.getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD)); // 请求最大长度
 15:     // 启动 NettyJaxrsServer
 16:     server.start();
 17: }
```

- `server` 属性， **Netty4** 对 Resteasy Server 的实现。
- 第 3 至 14 行：设置 NettyJaxrsServer 的属性。
- 第 16 行：调用 `NettyJarxrsServer#start()` 方法，启动服务器。

###### 3.3.2 stop

```
@Override
public void stop() {
    server.stop();
}
```

###### 3.3.3 getDeployment

```
@Override
protected ResteasyDeployment getDeployment() {
    return server.getDeployment();
}
```

#### 3.4 DubboHttpServer

[`com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboHttpServer.java) ，实现 BaseRestServer 抽象基类，基于 `dubbo-remoting-http` 的 HTTP 服务器实现类。

###### 3.4.1 构造方法

```
/**
 * Resteasy HttpServletDispatcher
 */
private final HttpServletDispatcher dispatcher = new HttpServletDispatcher();
/**
 * Resteasy ResteasyDeployment
 */
private final ResteasyDeployment deployment = new ResteasyDeployment();
/**
 * Dubbo HttpBinder$Adaptive
 */
private HttpBinder httpBinder;
/**
 * HttpServer 对象
 */
private HttpServer httpServer;

public DubboHttpServer(HttpBinder httpBinder) {
    this.httpBinder = httpBinder;
}
```

- DubboHttpServer 相比 NettyHttpServer 的请求流程会**复杂**一些，`Dubbo DispatcherServlet => Dubbo RestHandler => Resteasy HttpServletDispatcher => ...` 。

###### 3.4.2 doStart

```
 1: @Override
 2: protected void doStart(URL url) {
 3:     // 创建 HttpServer 对象，使用 RestHandler 作为处理器。
 4:     // TODO jetty will by default enable keepAlive so the xml config has no effect now
 5:     httpServer = httpBinder.bind(url, new RestHandler());
 6: 
 7:     // 获得 ServletContext 对象
 8:     ServletContext servletContext = ServletManager.getInstance().getServletContext(url.getPort());
 9:     if (servletContext == null) {
10:         servletContext = ServletManager.getInstance().getServletContext(ServletManager.EXTERNAL_SERVER_PORT);
11:     }
12:     if (servletContext == null) {
13:         throw new RpcException("No servlet context found. If you are using server='servlet', " +
14:                 "make sure that you've configured " + BootstrapListener.class.getName() + " in web.xml");
15:     }
16:     // 设置 ResteasyDeployment
17:     servletContext.setAttribute(ResteasyDeployment.class.getName(), deployment); // https://github.com/resteasy/Resteasy/blob/master/server-adapters/resteasy-undertow/src/main/java/org/jboss/resteasy/plugins/server/undertow/UndertowJaxrsServer.java#L74
18: 
19:     // 初始化 Resteasy HttpServletDispatcher
20:     try {
21:         dispatcher.init(new SimpleServletConfig(servletContext));
22:     } catch (ServletException e) {
23:         throw new RpcException(e);
24:     }
25: }
```

- 第 5 行：调用 `HttpBinder#bind(url, handler)` 方法，创建 HttpServer 对象，使用 RestHandler 作为处理器。

- 第 7 至 17 行：获得 ServletContext 对象，设置 ResteasyDeployment 到属性 。

  - 为什么是 `ResteasyDeployment.class.getName()` 呢？参见 [UndertowJaxrsServer](https://github.com/resteasy/Resteasy/blob/master/server-adapters/resteasy-undertow/src/main/java/org/jboss/resteasy/plugins/server/undertow/UndertowJaxrsServer.java#L74) 的代码。

- 第 19 至 24 行：调用

   

  ```
  HttpServletDispatcher#init(ServletConfig)
  ```

   

  方法，初始化 Resteasy 调度器。

  - [SimpleServletConfig](https://github.com/YunaiV/dubbo/blob/f83e70b53389a064e49babe32e61a5648002a44a/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/DubboHttpServer.java#L89-L120) ，主要是实现 ServletName 为 `"DispatcherServlet"` 。

###### 3.4.3 stop

```
@Override
public void stop() {
    httpServer.close();
}
```

###### 3.4.4 getDeployment

```
@Override
protected ResteasyDeployment getDeployment() {
    return deployment;
}
```

###### 3.4.5 RestHandler

```
private class RestHandler implements HttpHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        // 设置
        RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());
        // 调度请求
        dispatcher.service(request, response);
    }

}
```

- 实现 HttpHandler 接口。
- 调用 `HttpServletDispatcher#service(request, response)` 方法，调度请求，给 Resteasy HttpServletDispatcher 。

#### 3.5 RestServerFactory

[`com.alibaba.dubbo.rpc.protocol.rest.RestServerFactory`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestServerFactory.java) ，创建 RestServer 的工厂。

🙂 代码比较简单，胖友自己看看。

## 4. Filter

😈 这是 JAX-RS 中的 Filter ，而不是 Dubbo 的 Filter 。

#### 4.1 RpcContextFilter

[`com.alibaba.dubbo.rpc.protocol.rest.RpcContextFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RpcContextFilter.java) ，实现 ContainerRequestFilter 和 ClientRequestFilter 接口，**处理 RpcContext** 的 Filter 实现类。

- Client Filter ：通过将 Dubbo RpcContext Attachment ，设置到 Http Header 的 `Dubbo-Attachments` 中，请求传递给 Server 。
- Server Filter ：解析 Http Header 的 `Dubbo-Attachments` ，设置到 RpcContext Attachment 中。

🙂 代码比较简单，胖友自己看看。

#### 4.2 LoggingFilter

[`com.alibaba.dubbo.rpc.protocol.rest.support.LoggingFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/support/LoggingFilter.java) ，实现 ContainerRequestFilter 和 ClientRequestFilter **等等**接口，打印日志的 Filter 。**目前仅打印请求和响应的 Header** 。

默认未使用，需要配置。

🙂 代码比较简单，胖友自己看看。

## 5. ExceptionMapper

[`com.alibaba.dubbo.rpc.protocol.rest.ExceptionMapper`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ExceptionMapper.java) ，实现 `javax.ws.rs.ext.ExceptionMapper` 接口，RPC 异常匹配实现类。代码如下：

```
 1: @Override
 2: public Response toResponse(RpcException e) {
 3:     // 参数不合法，拼接返回 Response
 4:     // TODO do more sophisticated exception handling and output
 5:     if (e.getCause() instanceof ConstraintViolationException) { // java validation 异常
 6:         return handleConstraintViolationException((ConstraintViolationException) e.getCause());
 7:     }
 8:     // 普通 Response 返回
 9:     // we may want to avoid exposing the dubbo exception details to certain clients
10:     // TODO for now just do plain text output
11:     return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity("Internal server error: " + e.getMessage()).type(ContentType.TEXT_PLAIN_UTF_8).build();
12: }
```

- 第 3 至 7 行：当 Java Validation 校验发现参数不合法时，调用 `#handleConstraintViolationException(ConstraintViolationException)` 方法，处理参数不合法的异常，拼接返回 Response 。代码如下：

  ```
  protected Response handleConstraintViolationException(ConstraintViolationException cve) {
      ViolationReport report = new ViolationReport();
      for (ConstraintViolation cv : cve.getConstraintViolations()) {
          report.addConstraintViolation(new RestConstraintViolation(
                  cv.getPropertyPath().toString(),
                  cv.getMessage(),
                  cv.getInvalidValue() == null ? "null" : cv.getInvalidValue().toString()));
      }
      // TODO for now just do xml output
      return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(report).type(ContentType.TEXT_XML_UTF_8).build();
  }
  ```

  - 我们知道，一个请求可以有多个参数，因此，可以有多个约束条件，所以可以违反多个。
  - [`com.alibaba.dubbo.rpc.protocol.rest.ViolationReport`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ViolationReport.java) ，RestConstraintViolation 的集合。
  - [`com.alibaba.dubbo.rpc.protocol.rest.RestConstraintViolation`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/RestConstraintViolation.java) ，**一条**不符合约束 。
  - 目前，仅返回 XML 格式。如果胖友需要 JSON 格式，可以自己拓展设置。

- 第 11 行：普通 Response 返回。

## 6. ContentType

[`com.alibaba.dubbo.rpc.protocol.rest.ContentType`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rest/src/main/java/com/alibaba/dubbo/rpc/protocol/rest/ContentType.java) ，ContentType 枚举类。代码如下：

```
public class ContentType {

    public static final String APPLICATION_JSON_UTF_8 = MediaType.APPLICATION_JSON + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";
    public static final String TEXT_XML_UTF_8 = MediaType.TEXT_XML + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";
    public static final String TEXT_PLAIN_UTF_8 = MediaType.TEXT_PLAIN + "; " + MediaType.CHARSET_PARAMETER + "=UTF-8";

}
```

# 远程调用-WebService(rmi)

## 1. 概述

本文，我们分享 `rmi://` 协议的远程调用，主要分成**三个部分**：

- 服务暴露
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-rmi` 。

对应文档为 [《Dubbo 用户指南 —— rmi://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html) 。定义如下：

> RMI 协议采用 JDK 标准的 `java.rmi.*` 实现，采用阻塞式短连接和 JDK 标准序列化方式。

本文涉及类图（红圈部分）如下：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_10_22/01.png)](http://static.iocoder.cn/images/Dubbo/2018_10_22/01.png)类图

> 旁白君：整体实现和 `dubbo-rpc-http` 一致，所以内容上和 [《精尽 Dubbo 源码分析 —— 服务调用（三）之远程调用（HTTP）》](http://svip.iocoder.cn/Dubbo/rpc-http/?self) 差不多。

## 2. RmiRemoteInvocation

```
public class RmiRemoteInvocation extends RemoteInvocation {

    private static final long serialVersionUID = 1L;

    private static final String dubboAttachmentsAttrName = "dubbo.attachments";

    /**
     * executed on consumer side
     *
     * 构造将在消费端执行
     */
    public RmiRemoteInvocation(MethodInvocation methodInvocation) {
        super(methodInvocation);
        addAttribute(dubboAttachmentsAttrName, new HashMap<String, String>(RpcContext.getContext().getAttachments()));
    }

    /**
     * Need to restore context on provider side (Though context will be overridden by Invocation's attachment
     * when ContextFilter gets executed, we will restore the attachment when Invocation is constructed, check more
     * from {@link com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler}
     *
     * 服务端执行时，重新放入上下文（虽然这时上下文在ContextFilter执行时将被Invocation的attachments覆盖，我们在Invocation构造时还原attachments, see InvokerInvocationHandler）
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object invoke(Object targetObject) throws NoSuchMethodException, IllegalAccessException,
            InvocationTargetException {
        RpcContext context = RpcContext.getContext();
        context.setAttachments((Map<String, String>) getAttribute(dubboAttachmentsAttrName));
        try {
            return super.invoke(targetObject);
        } finally {
            context.setAttachments(null);
        }
    }
}
```

## 3. RmiProtocol

[`com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-rmi/src/main/java/com/alibaba/dubbo/rpc/protocol/rmi/RmiProtocol.java) ，实现 AbstractProxyProtocol 抽象类，`rmi://` 协议实现类。

#### 3.1 构造方法

```
/**
 * 默认端口
 */
public static final int DEFAULT_PORT = 1099;

public RmiProtocol() {
    super(RemoteAccessException.class, RemoteException.class);
}

public int getDefaultPort() {
    return DEFAULT_PORT;
}
```

- `rpcExceptions = RemoteAccessException.class, RemoteException.class` 。
- 🙂 艿艿对 RMI了解不多，所以本文更多梳理好整体脉络。

#### 3.2 doExport

```
 1: @Override
 2: protected <T> Runnable doExport(final T impl, Class<T> type, URL url) throws RpcException {
 3:     // 创建 RmiServiceExporter 对象
 4:     final RmiServiceExporter rmiServiceExporter = new RmiServiceExporter();
 5:     rmiServiceExporter.setRegistryPort(url.getPort());
 6:     rmiServiceExporter.setServiceName(url.getPath());
 7:     rmiServiceExporter.setServiceInterface(type);
 8:     rmiServiceExporter.setService(impl);
 9:     try {
10:         rmiServiceExporter.afterPropertiesSet();
11:     } catch (RemoteException e) {
12:         throw new RpcException(e.getMessage(), e);
13:     }
14:     // 返回取消暴露的回调 Runnable
15:     return new Runnable() {
16:         public void run() {
17:             try {
18:                 rmiServiceExporter.destroy();
19:             } catch (Throwable e) {
20:                 logger.warn(e.getMessage(), e);
21:             }
22:         }
23:     };
24: }
```

- 第 3 至 13 行：创建 RmiServiceExporter 对象。
- 第 14 至 23 行：返回取消暴露的回调 Runnable。

#### 3.3 doRefer

```
 1: @Override
 2: @SuppressWarnings("unchecked")
 3: protected <T> T doRefer(final Class<T> serviceType, final URL url) throws RpcException {
 4:     // 创建 RmiProxyFactoryBean 对象
 5:     final RmiProxyFactoryBean rmiProxyFactoryBean = new RmiProxyFactoryBean();
 6:     // RMI needs extra parameter since it uses customized remote invocation object
 7:     // RMI传输时使用自定义的远程执行对象，从而传递额外的参数
 8:     if (url.getParameter(Constants.DUBBO_VERSION_KEY, Version.getVersion()).equals(Version.getVersion())) {
 9:         // Check dubbo version on provider, this feature only support
10:         rmiProxyFactoryBean.setRemoteInvocationFactory(new RemoteInvocationFactory() {
11:             public RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {
12:                 return new RmiRemoteInvocation(methodInvocation);
13:             }
14:         });
15:     }
16:     // 设置相关参数
17:     rmiProxyFactoryBean.setServiceUrl(url.toIdentityString());
18:     rmiProxyFactoryBean.setServiceInterface(serviceType);
19:     rmiProxyFactoryBean.setCacheStub(true);
20:     rmiProxyFactoryBean.setLookupStubOnStartup(true);
21:     rmiProxyFactoryBean.setRefreshStubOnConnectFailure(true);
22:     rmiProxyFactoryBean.afterPropertiesSet();
23:     // 创建 Service Proxy 对象
24:     return (T) rmiProxyFactoryBean.getObject();
25: }
```

- 第 5 行：创建 RmiProxyFactoryBean 对象。
- 第 8 至 15 行：若远程服务是 Dubbo RMI 服务时，RMI 传输时使用自定义的远程执行对象，从而传递额外的参数。
- 第 16 至 22 行：设置相关参数。另外，dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置 `-Dsun.rmi.transport.tcp.responseTimeout=3000` ，参见下面的 RMI 配置
- 第 24 行：创建 Service Proxy 对象。

###### 3.3.1 getErrorCode

```
@Override
protected int getErrorCode(Throwable e) {
    if (e instanceof RemoteAccessException) {
        e = e.getCause();
    }
    if (e != null && e.getCause() != null) {
        Class<?> cls = e.getCause().getClass();
        if (SocketTimeoutException.class.equals(cls)) {
            return RpcException.TIMEOUT_EXCEPTION;
        } else if (IOException.class.isAssignableFrom(cls)) {
            return RpcException.NETWORK_EXCEPTION;
        } else if (ClassNotFoundException.class.isAssignableFrom(cls)) {
            return RpcException.SERIALIZATION_EXCEPTION;
        }
    }
    return super.getErrorCode(e);
}
```

- 将异常，翻译成 Dubbo 异常码。

# 远程调用-Redis

## 1. 概述

本文，我们分享 `redis://` 协议的远程调用，主要分成**两个个部分**：

- ~~服务暴露~~
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-redis` 。

对应文档为 [《Dubbo 用户指南 —— redis://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/redis.html) 。定义如下：

> 基于 Redis 实现的 RPC 协议。

简单的说，通过 Dubbo Service 的调用方式，**透明化**对 Redis 的访问。
这样，如果未来希望，修改缓存的解决方案，不用修改代码，而只要修改 Dubbo Service 的配置。
就好像，Java JDBC API 有 MySQL JDBC 、Oracle JDBC 等多种实现，只需要修改对应的 JDBC 驱动实现类，就可以连接上不同的数据库。

另外，Dubbo 提供 `memcached://` 协议，和 `redis://` 对等，差别点在前者使用 Memcached ，后者使用 Redis 。

## 2. RedisProtocol

[`com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-redis/src/main/java/com/alibaba/dubbo/rpc/protocol/redis/RedisProtocol.java) ，实现 AbstractProtocol 抽象类，`redis://` 协议实现类。

#### 2.1 export

```
@Override
public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
    throw new UnsupportedOperationException("Unsupported export redis service. url: " + invoker.getUrl());
}
```

实际访问的就是 Redis Server 实例，因此无需进行 Dubbo 服务暴露。客户端配置引用方式如下：

> 在客户端使用，注册中心读取：
> `<dubbo:reference id="store" interface="java.util.Map" group="member" />`
>
> 或者，点对点直连：
> `<dubbo:reference id="store" interface="java.util.Map" url="redis://10.20.153.10:6379"`

#### 2.2 refer

```
  1: @Override
  2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
  3:     try {
  4:         // 创建 GenericObjectPoolConfig 对象，设置配置
  5:         GenericObjectPoolConfig config = new GenericObjectPoolConfig();
  6:         config.setTestOnBorrow(url.getParameter("test.on.borrow", true));
  7:         config.setTestOnReturn(url.getParameter("test.on.return", false));
  8:         config.setTestWhileIdle(url.getParameter("test.while.idle", false));
  9:         if (url.getParameter("max.idle", 0) > 0)
 10:             config.setMaxIdle(url.getParameter("max.idle", 0));
 11:         if (url.getParameter("min.idle", 0) > 0)
 12:             config.setMinIdle(url.getParameter("min.idle", 0));
 13:         if (url.getParameter("max.active", 0) > 0)
 14:             config.setMaxTotal(url.getParameter("max.active", 0));
 15:         if (url.getParameter("max.total", 0) > 0)
 16:             config.setMaxTotal(url.getParameter("max.total", 0));
 17:         if (url.getParameter("max.wait", 0) > 0)
 18:             config.setMaxWaitMillis(url.getParameter("max.wait", 0));
 19:         if (url.getParameter("num.tests.per.eviction.run", 0) > 0)
 20:             config.setNumTestsPerEvictionRun(url.getParameter("num.tests.per.eviction.run", 0));
 21:         if (url.getParameter("time.between.eviction.runs.millis", 0) > 0)
 22:             config.setTimeBetweenEvictionRunsMillis(url.getParameter("time.between.eviction.runs.millis", 0));
 23:         if (url.getParameter("min.evictable.idle.time.millis", 0) > 0)
 24:             config.setMinEvictableIdleTimeMillis(url.getParameter("min.evictable.idle.time.millis", 0));
 25:         // 创建 JedisPool 对象
 26:         final JedisPool jedisPool = new JedisPool(config, url.getHost(), url.getPort(DEFAULT_PORT),
 27:                 url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
 28: 
 29:         // 处理方法名的映射
 30:         final int expiry = url.getParameter("expiry", 0);
 31:         final String get = url.getParameter("get", "get");
 32:         final String set = url.getParameter("set", Map.class.equals(type) ? "put" : "set");
 33:         final String delete = url.getParameter("delete", Map.class.equals(type) ? "remove" : "delete");
 34: 
 35:         // 创建 Invoker 对象
 36:         return new AbstractInvoker<T>(type, url) {
 37: 
 38:             @Override
 39:             protected Result doInvoke(Invocation invocation) {
 40:                 Jedis resource = null;
 41:                 try {
 42:                     // 获得 Redis Resource
 43:                     resource = jedisPool.getResource();
 44:                     // Redis get 指令
 45:                     if (get.equals(invocation.getMethodName())) {
 46:                         if (invocation.getArguments().length != 1) {
 47:                             throw new IllegalArgumentException("The redis get method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 48:                         }
 49:                         // 获得值
 50:                         byte[] value = resource.get(String.valueOf(invocation.getArguments()[0]).getBytes());
 51:                         if (value == null) {
 52:                             return new RpcResult();
 53:                         }
 54:                         // 反序列化
 55:                         ObjectInput oin = getSerialization(url).deserialize(url, new ByteArrayInputStream(value));
 56:                         // 返回结果
 57:                         return new RpcResult(oin.readObject());
 58:                     // Redis set/put 指令
 59:                     } else if (set.equals(invocation.getMethodName())) {
 60:                         if (invocation.getArguments().length != 2) {
 61:                             throw new IllegalArgumentException("The redis set method arguments mismatch, must be two arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 62:                         }
 63:                         // 序列化
 64:                         byte[] key = String.valueOf(invocation.getArguments()[0]).getBytes();
 65:                         ByteArrayOutputStream output = new ByteArrayOutputStream();
 66:                         ObjectOutput value = getSerialization(url).serialize(url, output);
 67:                         value.writeObject(invocation.getArguments()[1]);
 68:                         // 设置值
 69:                         resource.set(key, output.toByteArray());
 70:                         if (expiry > 1000) {
 71:                             resource.expire(key, expiry / 1000);
 72:                         }
 73:                         // 返回结果
 74:                         return new RpcResult();
 75:                     } else if (delete.equals(invocation.getMethodName())) {
 76:                         if (invocation.getArguments().length != 1) {
 77:                             throw new IllegalArgumentException("The redis delete method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
 78:                         }
 79:                         // 删除值
 80:                         resource.del(String.valueOf(invocation.getArguments()[0]).getBytes());
 81:                         // 返回结果
 82:                         return new RpcResult();
 83:                     } else {
 84:                         throw new UnsupportedOperationException("Unsupported method " + invocation.getMethodName() + " in redis service.");
 85:                     }
 86:                 } catch (Throwable t) {
 87:                     RpcException re = new RpcException("Failed to invoke redis service method. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url + ", cause: " + t.getMessage(), t);
 88:                     if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {
 89:                         re.setCode(RpcException.TIMEOUT_EXCEPTION);
 90:                     } else if (t instanceof JedisConnectionException || t instanceof IOException) {
 91:                         re.setCode(RpcException.NETWORK_EXCEPTION);
 92:                     } else if (t instanceof JedisDataException) {
 93:                         re.setCode(RpcException.SERIALIZATION_EXCEPTION);
 94:                     }
 95:                     throw re;
 96:                 } finally {
 97:                     // 归还 Redis Resource
 98:                     if (resource != null) {
 99:                         try {
100:                             jedisPool.returnResource(resource);
101:                         } catch (Throwable t) {
102:                             logger.warn("returnResource error: " + t.getMessage(), t);
103:                         }
104:                     }
105:                 }
106:             }
107: 
108:             @Override
109:             public void destroy() {
110:                 // 标记销毁
111:                 super.destroy();
112:                 // 销毁 Redis Pool
113:                 try {
114:                     jedisPool.destroy();
115:                 } catch (Throwable e) {
116:                     logger.warn(e.getMessage(), e);
117:                 }
118:             }
119: 
120:         };
121:     } catch (Throwable t) {
122:         throw new RpcException("Failed to refer redis service. interface: " + type.getName() + ", url: " + url + ", cause: " + t.getMessage(), t);
123:     }
124: }
```

- 使用 Jedis 访问 Redis Server 。

- 第 4 至 24 行：创建 GenericObjectPoolConfig 对象，从 Dubbo URL 中读取相关配置。此时，我们可以看到，为什么 Dubbo 的配置类中，有 `arguments` 属性了。可以使用它，实现不同 Protocol 协议的自定义属性。

- 第 25 至 27 行：创建 JedisPool 对象。

- 第 29 至 33 行：处理方法名的映射。

  > 如果方法名和 redis 的标准方法名不相同，则需要配置映射关系：
  > `<dubbo:reference id="cache" interface="com.foo.CacheService" url="memcached://10.20.153.10:11211" p:set="putFoo" p:get="getFoo" p:delete="removeFoo" />`

  - 当对应的服务接口是 `java.util.Map` 时，对应的 Redis 数据结构为 **Map** 。

- 第 35 至 120 行：创建 Invoker 对象。

###### 2.2.1 doInvoke

- 第 43 行：获得 Redis Resource 对象。
- 第 44 至 57 行：Redis **get** 指令。
- 第 58 至 74 行：Redis **set/put** 指令。
- 第 75 至 83 行：Redis **delete/remove** 指令。
- 第 84 至 85 行：目前其他命令，暂时不支持。
- 第 86 至 95 行：翻译异常成 Dubbo 错误码。
- 第 97 至 105 行：归还 Redis Resource 对象。

###### 2.2.2 destroy

- 第 111 行：调用 `super#destroy()` 方法，标记销毁。
- 第 112 至 117 行：调用 `JedisPool#destroy()` 方法，销毁 Redis Pool 。

# 远程调用-Memcached

## 1. 概述

本文接 [《精尽 Dubbo 源码分析 —— 服务调用（八）之远程调用（Redis）》](http://svip.iocoder.cn/Dubbo/rpc-redis/?self) ，我们分享 `memcached://` 协议的远程调用，主要分成**两个个部分**：

- ~~服务暴露~~
- 服务引用
- 服务调用

对应项目为 `dubbo-rpc-memcached` 。

对应文档为 [《Dubbo 用户指南 —— memcached://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/memcached.html) 。定义如下：

> 基于 Memcached 实现的 RPC 协议。

## 2. MemcachedProtocol

[`com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-memcached/src/main/java/com/alibaba/dubbo/rpc/protocol/memcached/MemcachedProtocol.java) ，实现 AbstractProtocol 抽象类，`memcached://` 协议实现类。

#### 2.1 export

```
@Override
public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
    throw new UnsupportedOperationException("Unsupported export redis service. url: " + invoker.getUrl());
}
```

实际访问的就是 Memcached Server 实例，因此无需进行 Dubbo 服务暴露。客户端配置引用方式如下：

> 在客户端使用，注册中心读取：
> `<dubbo:reference id="store" interface="java.util.Map" group="member" />`
>
> 或者，点对点直连：
> `<dubbo:reference id="store" interface="java.util.Map" url="memcached://10.20.153.10:11211"`

#### 2.2 refer

```
 1: @Override
 2: public <T> Invoker<T> refer(final Class<T> type, final URL url) throws RpcException {
 3:     try {
 4:         // 创建 MemcachedClient 对象
 5:         String address = url.getAddress();
 6:         String backup = url.getParameter(Constants.BACKUP_KEY);
 7:         if (backup != null && backup.length() > 0) {
 8:             address += "," + backup;
 9:         }
10:         MemcachedClientBuilder builder = new XMemcachedClientBuilder(AddrUtil.getAddresses(address));
11:         final MemcachedClient memcachedClient = builder.build();
12: 
13:         // 处理方法名的映射
14:         final int expiry = url.getParameter("expiry", 0);
15:         final String get = url.getParameter("get", "get");
16:         final String set = url.getParameter("set", Map.class.equals(type) ? "put" : "set");
17:         final String delete = url.getParameter("delete", Map.class.equals(type) ? "remove" : "delete");
18:         return new AbstractInvoker<T>(type, url) {
19: 
20:             @Override
21:             protected Result doInvoke(Invocation invocation) throws Throwable {
22:                 try {
23:                     // Memcached get 指令
24:                     if (get.equals(invocation.getMethodName())) {
25:                         if (invocation.getArguments().length != 1) {
26:                             throw new IllegalArgumentException("The memcached get method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
27:                         }
28:                         return new RpcResult(memcachedClient.get(String.valueOf(invocation.getArguments()[0])));
29:                     // Memcached set 指令
30:                     } else if (set.equals(invocation.getMethodName())) {
31:                         if (invocation.getArguments().length != 2) {
32:                             throw new IllegalArgumentException("The memcached set method arguments mismatch, must be two arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
33:                         }
34:                         memcachedClient.set(String.valueOf(invocation.getArguments()[0]), expiry, invocation.getArguments()[1]);
35:                         return new RpcResult();
36:                     // Memcached delele 指令
37:                     } else if (delete.equals(invocation.getMethodName())) {
38:                         if (invocation.getArguments().length != 1) {
39:                             throw new IllegalArgumentException("The memcached delete method arguments mismatch, must only one arguments. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url);
40:                         }
41:                         memcachedClient.delete(String.valueOf(invocation.getArguments()[0]));
42:                         return new RpcResult();
43:                     // 不支持的指令，抛出异常
44:                     } else {
45:                         throw new UnsupportedOperationException("Unsupported method " + invocation.getMethodName() + " in memcached service.");
46:                     }
47:                 } catch (Throwable t) {
48:                     RpcException re = new RpcException("Failed to invoke memcached service method. interface: " + type.getName() + ", method: " + invocation.getMethodName() + ", url: " + url + ", cause: " + t.getMessage(), t);
49:                     if (t instanceof TimeoutException || t instanceof SocketTimeoutException) {
50:                         re.setCode(RpcException.TIMEOUT_EXCEPTION);
51:                     } else if (t instanceof MemcachedException || t instanceof IOException) {
52:                         re.setCode(RpcException.NETWORK_EXCEPTION);
53:                     }
54:                     throw re;
55:                 }
56:             }
57: 
58:             @Override
59:             public void destroy() {
60:                 // 标记销毁
61:                 super.destroy();
62:                 // 关闭 MemcachedClient
63:                 try {
64:                     memcachedClient.shutdown();
65:                 } catch (Throwable e) {
66:                     logger.warn(e.getMessage(), e);
67:                 }
68:             }
69: 
70:         };
71:     } catch (Throwable t) {
72:         throw new RpcException("Failed to refer memcached service. interface: " + type.getName() + ", url: " + url + ", cause: " + t.getMessage(), t);
73:     }
74: }
```

- 第 4 至 11 行：创建 MemcachedClient 对象。
- 第 13 至 17 行：处理方法名的映射。此处有个问题，Memcached 不存在 Map 数据结构，因此不存在 put 和 remove 指令。
- 第 18 至 73 行：创建 Invoker 对象。

###### 2.2.1 doInvoke

- 第 23 至 28 行：Memcached **get** 指令。
- 第 29 至 35 行：Memcached **set** 指令。
- 第 36 至 42 行：Memcached **delete** 指令。
- 第 43 至 46 行：目前其他命令，暂时不支持。
- 第 47 至 55 行：翻译异常成 Dubbo 错误码。

###### 2.2.2 destroy

- 第 61 行：调用 `super#destroy()` 方法，标记销毁。
- 第 63 至 67 行：调用 `Memcached#shutdown()` 方法，关闭 MemcachedClient 。