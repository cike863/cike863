# Javassist

## 1. 概述

在 Java 语言中，大多数情况下，我们已经编写好 Java 类，并编译成 Class 文件进行运行。但是在一些场景下，例如动态代理，需要运用到**动态编译**的技术。虽然我们也可以用反射的技术实现，但是相比来说，还是有一定的性能差距。

例如，在 [《精尽 Dubbo 源码分析 —— 拓展机制 SPI》](http://svip.iocoder.cn/Dubbo/spi/?self) 的 [「4.5.4 createAdaptiveExtensionClassCode」](http://svip.iocoder.cn/Dubbo/compiler-javassist/#) 小节中，我们可以看到如下代码：

```
 1: /**
 2:  * 自动生成自适应拓展的代码实现，并编译后返回该类。
 3:  *
 4:  * @return 类
 5:  */
 6: private Class<?> createAdaptiveExtensionClass() {
 7:     // 自动生成自适应拓展的代码实现的字符串
 8:     String code = createAdaptiveExtensionClassCode();
 9:     // 编译代码，并返回该类
10:     ClassLoader classLoader = findClassLoader();
11:     com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
12:     return compiler.compile(code, classLoader);
13: }
```

调用 `Compiler#compile(code, classLoader)` 方法，编译代码，并返回该类。Compiler 基于 Dubbo SPI 机制进行加载，目前有两种实现：

- JdkCompiler

  ```
  <dubbo:application compiler="jdk" />
  ```

- JavassistCompiler

  ```
  <dubbo:application compiler="javassist" />
  ```

**缺省**使用 JavassistCompiler 。

🙂 本文仅分享 JavassistCompiler 的实现。

------

动态编译，在 `dubbo-common` 模块的 [`compiler`](https://github.com/YunaiV/dubbo/tree/ded892cb2f31e2847c18f773e16b16a6fbaf53d2/dubbo-common/src/main/java/com/alibaba/dubbo/common/compiler) 包下实现，整体类结构如下图：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_09_01/01.png)](http://static.iocoder.cn/images/Dubbo/2018_09_01/01.png)类图

## 2. Compiler

`com.alibaba.dubbo.common.compiler.Compiler` ，编辑器接口。代码如下：

```
@SPI("javassist")
public interface Compiler {

    /**
     * Compile java source code.
     *
     * 编译 Java 代码字符串
     *
     * @param code        Java source code
     *                    Java 代码字符串
     * @param classLoader classloader
     *                    类加载器
     * @return Compiled class
     *                    编译后的类
     */
    Class<?> compile(String code, ClassLoader classLoader);

}
```

- `@SPI("javassist")` 注解，使用 Dubbo SPI 机制，默认拓展为 Javassist 。
- `code` 参数，Java 代码字符串。如下是 ProxyFactory$Adaptive 的自适应拓展的代码实现的字符串生成**例子**：[![自适应拓展的代码实现的字符串生成例子](http://static.iocoder.cn/images/Dubbo/2018_03_04/05.png)](http://static.iocoder.cn/images/Dubbo/2018_03_04/05.png)自适应拓展的代码实现的字符串生成例子

## 3. AdaptiveCompiler

`com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler` ，实现 Compiler 接口，自适应 Compiler 实现类。

```
 1: @Adaptive
 2: public class AdaptiveCompiler implements Compiler {
 3: 
 4:     /**
 5:      * 默认编辑器的拓展名
 6:      */
 7:     private static volatile String DEFAULT_COMPILER;
 8: 
 9:     public static void setDefaultCompiler(String compiler) {
10:         DEFAULT_COMPILER = compiler;
11:     }
12: 
13:     @Override public Class<?> compile(String code, ClassLoader classLoader) {
14:         Compiler compiler;
15:         // 获得 Compiler 的 ExtensionLoader 对象。
16:         ExtensionLoader<Compiler> loader = ExtensionLoader.getExtensionLoader(Compiler.class);
17:         String name = DEFAULT_COMPILER; // copy reference
18:         // 使用设置的拓展名，获得 Compiler 拓展对象
19:         if (name != null && name.length() > 0) {
20:             compiler = loader.getExtension(name);
21:         // 获得默认的 Compiler 拓展对象
22:         } else {
23:             compiler = loader.getDefaultExtension();
24:         }
25:         //
26:         return compiler.compile(code, classLoader);
27:     }
28: 
29: }
```

- `#setDefaultCompiler(compiler)` **静态**方法，设置默认编辑器的拓展名( `DEFAULT_COMPILER` )。该方法被 `ApplicationConfig#setCompiler(compiler)` 方法调用，代码如下：

  ```
  // ApplicationConfig.java
  public void setCompiler(String compiler) {
      this.compiler = compiler;
      AdaptiveCompiler.setDefaultCompiler(compiler);
  }
  ```

  - 在 `<dubbo:application compiler="" />` 配置下，可触发该方法。

- `#compile(code, classLoader)` **实现**方法：

  - 第 16 行：调用 `ExtensionLoader#getExtensionLoader(Class<?> type)` 方法，获得 Compiler 的 ExtensionLoader 对象。
  - 第 17 行：声明 `name` 变量，引用 `DEFAULT_COMPILER` 的值。避免在【第 19 至 20 行】的代码过程中，值变了。
  - 第 19 至 20 行：使用**设置**的拓展名，获得 Compiler 拓展对象。
  - 第 22 至 24 行：获得默认的 Compiler 拓展对象。
  - 第 26 行：调用真正的 Compiler 对象，动态编译代码。

## 4. AbstractCompiler

`com.alibaba.dubbo.common.compiler.support.AbstractCompiler` ，实现 Compiler 接口，Compiler **抽象类**。代码如下：

```
public abstract class AbstractCompiler implements Compiler {

    /**
     * 正则 - 包名
     */
    private static final Pattern PACKAGE_PATTERN = Pattern.compile("package\\s+([$_a-zA-Z][$_a-zA-Z0-9\\.]*);");
    /**
     * 正则 - 类名
     */
    private static final Pattern CLASS_PATTERN = Pattern.compile("class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s+");

    public Class<?> compile(String code, ClassLoader classLoader) {
        // 获得包名
        code = code.trim();
        Matcher matcher = PACKAGE_PATTERN.matcher(code);
        String pkg;
        if (matcher.find()) {
            pkg = matcher.group(1);
        } else {
            pkg = "";
        }
        // 获得类名
        matcher = CLASS_PATTERN.matcher(code);
        String cls;
        if (matcher.find()) {
            cls = matcher.group(1);
        } else {
            throw new IllegalArgumentException("No such class name in " + code);
        }
        // 获得完整类名
        String className = pkg != null && pkg.length() > 0 ? pkg + "." + cls : cls;
        // 加载类，若已经存在
        try {
            // 加载成功，说明已存在
            return Class.forName(className, true, ClassHelper.getCallerClassLoader(getClass())); // classloader 为调用方的
        } catch (ClassNotFoundException e) { // 类不存在，说明可能未编译过，进行编译
            // 代码格式不正确
            if (!code.endsWith("}")) {
                throw new IllegalStateException("The java code not endsWith \"}\", code: \n" + code + "\n");
            }
            // 编译代码
            try {
                return doCompile(className, code);
            } catch (RuntimeException t) {
                throw t;
            } catch (Throwable t) {
                throw new IllegalStateException("Failed to compile class, cause: " + t.getMessage() + ", class: " + className + ", code: \n" + code + "\n, stack: " + ClassUtils.toString(t));
            }
        }
    }

    /**
     * 编译代码
     *
     * @param name 类名
     * @param source 代码
     * @return 编译后的类
     * @throws Throwable 发生异常
     */
    protected abstract Class<?> doCompile(String name, String source) throws Throwable;

}
```

- 首先获得完整类名，后使用类加载器加载该类：
  - 若成功，说明已经存在（可能已经编译过）。
  - 若失败，进行编译。
- 🙂 代码比较简单，胖友可以在看下注释。

## 5. JavassistCompiler

> Javassist 是一个开源的分析、编辑和创建 Java 字节码的类库。通过使用Javassist 对字节码操作可以实现动态 ”AOP” 框架。
>
> 关于 Java 字节码的处理，目前有很多工具，如 bcel，asm( cglib只是对asm又封装了一层 )。不过这些都需要直接跟虚拟机指令打交道。
>
> Javassist 的主要的优点，在于简单，而且快速，直接使用 Java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。

- 粗略一看，可能不够形象，下面我们通过看 JavassistCompiler 如何使用来理解理解。
- [《Java学习之javassist》](http://www.cnblogs.com/sunfie/p/5154246.html)
- [《Javassist 字节码操作》](http://blog.csdn.net/qbg19881206/article/details/8993562)

`com.alibaba.dubbo.common.compiler.support.JavassistCompiler` ，实现 AbstractCompiler 抽象类，基于 Javassist 实现的 Compiler 。代码如下：

```
  1: public class JavassistCompiler extends AbstractCompiler {
  2: 
  3:     /**
  4:      * 正则 - 匹配 import
  5:      */
  6:     private static final Pattern IMPORT_PATTERN = Pattern.compile("import\\s+([\\w\\.\\*]+);\n");
  7:     /**
  8:      * 正则 - 匹配 extends
  9:      */
 10:     private static final Pattern EXTENDS_PATTERN = Pattern.compile("\\s+extends\\s+([\\w\\.]+)[^\\{]*\\{\n");
 11:     /**
 12:      * 正则 - 匹配 implements
 13:      */
 14:     private static final Pattern IMPLEMENTS_PATTERN = Pattern.compile("\\s+implements\\s+([\\w\\.]+)\\s*\\{\n");
 15:     /**
 16:      * 正则 - 匹配方法
 17:      */
 18:     private static final Pattern METHODS_PATTERN = Pattern.compile("\n(private|public|protected)\\s+");
 19:     /**
 20:      * 正则 - 匹配变量
 21:      */
 22:     private static final Pattern FIELD_PATTERN = Pattern.compile("[^\n]+=[^\n]+;");
 23: 
 24:     @Override
 25:     public Class<?> doCompile(String name, String source) throws Throwable {
 26:         // 获得类名
 27:         int i = name.lastIndexOf('.');
 28:         String className = i < 0 ? name : name.substring(i + 1);
 29:         // 创建 ClassPool 对象
 30:         ClassPool pool = new ClassPool(true);
 31:         // 设置类搜索路径
 32:         pool.appendClassPath(new LoaderClassPath(ClassHelper.getCallerClassLoader(getClass())));
 33:         // 匹配 import
 34:         Matcher matcher = IMPORT_PATTERN.matcher(source);
 35:         List<String> importPackages = new ArrayList<String>(); // 引用的包名
 36:         Map<String, String> fullNames = new HashMap<String, String>(); // 引用的类名
 37:         while (matcher.find()) {
 38:             String pkg = matcher.group(1);
 39:             if (pkg.endsWith(".*")) { // 引用整个包下的类/接口
 40:                 String pkgName = pkg.substring(0, pkg.length() - 2);
 41:                 pool.importPackage(pkgName);
 42:                 importPackages.add(pkgName);
 43:             } else { // 引用指定类/接口
 44:                 int pi = pkg.lastIndexOf('.');
 45:                 if (pi > 0) {
 46:                     String pkgName = pkg.substring(0, pi);
 47:                     pool.importPackage(pkgName);
 48:                     importPackages.add(pkgName);
 49:                     fullNames.put(pkg.substring(pi + 1), pkg); // 类名
 50:                 }
 51:             }
 52:         }
 53:         String[] packages = importPackages.toArray(new String[0]);
 54:         // 匹配 extends
 55:         matcher = EXTENDS_PATTERN.matcher(source);
 56:         CtClass cls;
 57:         if (matcher.find()) {
 58:             String extend = matcher.group(1).trim();
 59:             String extendClass;
 60:             if (extend.contains(".")) { // 内嵌的类，例如：extends A.B
 61:                 extendClass = extend;
 62:             } else if (fullNames.containsKey(extend)) { // 指定引用的类
 63:                 extendClass = fullNames.get(extend);
 64:             } else { // 引用整个包下的类
 65:                 extendClass = ClassUtils.forName(packages, extend).getName();
 66:             }
 67:             // 创建 CtClass 对象
 68:             cls = pool.makeClass(name, pool.get(extendClass));
 69:         } else {
 70:             // 创建 CtClass 对象
 71:             cls = pool.makeClass(name);
 72:         }
 73:         // 匹配 implements
 74:         matcher = IMPLEMENTS_PATTERN.matcher(source);
 75:         if (matcher.find()) {
 76:             String[] ifaces = matcher.group(1).trim().split("\\,");
 77:             for (String iface : ifaces) {
 78:                 iface = iface.trim();
 79:                 String ifaceClass;
 80:                 if (iface.contains(".")) { // 内嵌的接口，例如：extends A.B
 81:                     ifaceClass = iface;
 82:                 } else if (fullNames.containsKey(iface)) { // 指定引用的接口
 83:                     ifaceClass = fullNames.get(iface);
 84:                 } else { // 引用整个包下的接口
 85:                     ifaceClass = ClassUtils.forName(packages, iface).getName();
 86:                 }
 87:                 // 添加接口
 88:                 cls.addInterface(pool.get(ifaceClass));
 89:             }
 90:         }
 91:         // 获得类中的内容，即首末 {} 的内容。
 92:         String body = source.substring(source.indexOf("{") + 1, source.length() - 1);
 93:         // 匹配 method 。使用分隔的方式，实际上，分隔出来的不仅仅有方法。
 94:         String[] methods = METHODS_PATTERN.split(body);
 95:         for (String method : methods) {
 96:             method = method.trim();
 97:             if (method.length() > 0) {
 98:                 if (method.startsWith(className)) { // 构造方法
 99:                     cls.addConstructor(CtNewConstructor.make("public " + method, cls));
100:                 } else if (FIELD_PATTERN.matcher(method).matches()) { // 变量
101:                     cls.addField(CtField.make("private " + method, cls));
102:                 } else { // 方法
103:                     cls.addMethod(CtNewMethod.make("public " + method, cls));
104:                 }
105:             }
106:         }
107:         // 生成类
108:         // JavassistCompiler.class.getProtectionDomain() =》 设置保护域和 JavassistCompiler 一致，即 `#getClass()` 方法。深入见 《Java安全——安全管理器、访问控制器和类装载器》https://www.zybuluo.com/changedi/note/417132
109:         return cls.toClass(ClassHelper.getCallerClassLoader(getClass()), JavassistCompiler.class.getProtectionDomain());
110:     }
111: 
112: }
```

- 因为传入的是 Java 源代码 `source` ，需要通过正则匹配出 `import`、`extends`、`implements`、方法、变量，传递给 Javassist API ，进行类生成。🙂 如果胖友对 Javassist 的 API 不是很了解，可以看完整体逻辑，回看下上面提供的文档。挺有趣的。

- 第 27 至 28 行：获得类名。

- 第 30 行：创建 ClassPool 对象。**ClassPool** 是一个 CtClass 对象的 hash 表，类名做为 key 。ClassPool 的 `#get(key)` 搜索 hash 表找到与指定 key 关联的 CtClass 对象。如果没有找到 CtClass 对象，`#get(key)` 读一个类文件构建新的 CtClass 对象，它是被记录在 hash 表中然后返回这个对象。

- 第 32 行：调用 `ClassPool#appendClassPath(ClassPath)` 方法，设置类搜索路径。

- 第 33 至 52 行：匹配

   

  ```
  import
  ```

   

  。

  - `ClassPool#importPackage(packageName)` 方法，引用包。

- 第 54 至 72 行：匹配

   

  ```
  extends
  ```

   

  。

  - `ClassPool#makeClass(name, extendClass)` 方法，创建**带继承的**类。
  - `ClassPool#makeClass(name)` 方法，创建类。

- 第 74 至 90 行：匹配

   

  ```
  implements
  ```

   

  ，整体逻辑和

   

  ```
  extends
  ```

   

  类似。

  - `CtClass#addInterface(anInterface)` 方法，添加类的接口。

- 第 92 行：获得类中的内容，即首末 `{` `}` 中的内容体。

- 第 94 至 106 行：匹配方法和变量。使用

   

  ```
  METHODS_PATTERN
  ```

   

  分隔的方式。

  - `CtClass#addConstructor(CtConstructor)` 方法，添加类的构造方法。
  - `CtClass#addMethod(CtMethod)` 方法，添加类的方法。
  - `CtClass#addField(CtField)` 方法，添加类的属性。

- 第 109 行：调用 `CtClass#toClass(ClassLoader, ProtectionDomain)` 方法，生成类。

# JDK-Javassist

## 1. 概述

本文分享 Dubbo **动态代理**的实现。

在 [《Dubbo 用户指南 —— schema 配置参考手册》](http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html) 中，我们可以看到 `<dubbo:service />` 和 `<dubbo:reference />` 标签中，可以通过 `"proxy"` 属性，可以配置动态代理的生成方式：

> 生成动态代理方式，可选：jdk / javassist

从说明中，我们可以看到，Dubbo 实现了**两种**方式生成代理：

- Javassit
- JDK

🙂 本文分享 Javassist 实现动态代理的源码；涉及代码如下：

- `dubbo-common` 模块的 `bytecode` 包。
- `dubbo-rpc-api` 模块的 `proxy` 包。

下一篇文章分享 JDK 实现动态代理的源码。

## 2. 性能

在分享具体实现之前，可能有胖友对性能方面感兴趣，可以看看如下的内容：

- [《动态代理方案性能对比》](http://javatar.iteye.com/blog/814426)

- 来自老徐的某篇文章

  > [![菜逼老徐](http://static.iocoder.cn/images/Dubbo/2018_09_13/01.png)](http://static.iocoder.cn/images/Dubbo/2018_09_13/01.png)菜逼老徐

## 3. 整体流程

😈 瞎比比了这么多，我们开始进入正题了。相信很多胖友对**动态代理**的概念已经理解（如果暂时不理解，请 Google 下），那么 Dubbo 对它们使用在哪呢？见下图：

[![菜逼老王](http://static.iocoder.cn/images/Dubbo/2018_09_13/02.png)](http://static.iocoder.cn/images/Dubbo/2018_09_13/02.png)菜逼老王

> 旁白君：本图暂不考虑集群容错、网络调用、序列化反序列等。

- 在 Dubbo 中，我们使用 **Service 接口**，作为服务 API 的契约。

- 在 Consumer 中，我们调用 Service 接口的方法时，实际调用的是 Dubbo 动态代理。下面先一起来看一个生成的 **proxy** 代码的示例：

  ```
   1: package com.alibaba.dubbo.common.bytecode;
   2: 
   3: import com.alibaba.dubbo.demo.DemoService;
   4: import com.alibaba.dubbo.rpc.service.EchoService;
   5: import java.lang.reflect.InvocationHandler;
   6: import java.lang.reflect.Method;
   7: 
   8: public class proxy0
   9:   implements ClassGenerator.DC, EchoService, DemoService
  10: {
  11:   public static Method[] methods;
  12:   private InvocationHandler handler;
  13:   
  14:   public void bye(Object paramObject)
  15:   {
  16:     Object[] arrayOfObject = new Object[1];
  17:     arrayOfObject[0] = paramObject;
  18:     Object localObject = this.handler.invoke(this, methods[0], arrayOfObject);
  19:   }
  20:   
  21:   public String sayHello(String paramString)
  22:   {
  23:     Object[] arrayOfObject = new Object[1];
  24:     arrayOfObject[0] = paramString;
  25:     Object localObject = this.handler.invoke(this, methods[1], arrayOfObject);
  26:     return (String)localObject;
  27:   }
  28:   
  29:   public Object $echo(Object paramObject)
  30:   {
  31:     Object[] arrayOfObject = new Object[1];
  32:     arrayOfObject[0] = paramObject;
  33:     Object localObject = this.handler.invoke(this, methods[2], arrayOfObject);
  34:     return (Object)localObject;
  35:   }
  36:   
  37:   public proxy0() {}
  38:   
  39:   public proxy0(InvocationHandler paramInvocationHandler)
  40:   {
  41:     this.handler = paramInvocationHandler;
  42:   }
  43: }
  ```

  - 该类通过 `dubbo-common` 模块的 `bytecode` 模块的 **Proxy** 类，**自动生成**，使用 Javassist 技术。
  - 生成的 **proxy** 类会**实现**我们定义的 Service 接口( 例如，此处是 DemoService )。
  - `#bye(Object)` 和 `#sayHello(Object)` 方法，是我们定义在 DemoService 的**接口方法**，在生成的 **proxy** 类中，实现这些定义在接口中的方法，收拢统一调用 `java.lang.reflect.InvocationHandler#invoke(proxy, method, args)` 方法。通过这样的方式，可以调用到最终的 `Invoker#invoke(Invocation)` 方法，实现 RPC 调用。
  - 注意，此处我们一直用的 **proxy** 一直是小写的，这是为什么呢？请见下文大写的 **Proxy** 类。

- 在 Provider 中，XXXProtocol 会获得被调用的 Exporter 对象，从而获得到 Invoker 对象。但是呢，Invoker 对象实际和 Service 实现对象，是无法直接调用，需要有中间的一层 Wrapper 来**代理分发**到 Service 对应的方法。下面我们来看一个生成的 Wrapper 代码的示例：

  ```
    1: package com.alibaba.dubbo.common.bytecode;
    2: 
    3: import com.alibaba.dubbo.demo.provider.DemoDAO;
    4: import com.alibaba.dubbo.demo.provider.DemoServiceImpl;
    5: import java.lang.reflect.InvocationTargetException;
    6: import java.util.Map;
    7: 
    8: public class Wrapper1
    9:   extends Wrapper
   10:   implements ClassGenerator.DC
   11: {
   12:   public static String[] pns;
   13:   public static Map pts;
   14:   public static String[] mns;
   15:   public static String[] dmns;
   16:   public static Class[] mts0;
   17:   public static Class[] mts1;
   18:   public static Class[] mts2;
   19:   
   20:   public String[] getPropertyNames()
   21:   {
   22:     return pns;
   23:   }
   24:   
   25:   public boolean hasProperty(String paramString)
   26:   {
   27:     return pts.containsKey(paramString);
   28:   }
   29:   
   30:   public Class getPropertyType(String paramString)
   31:   {
   32:     return (Class)pts.get(paramString);
   33:   }
   34:   
   35:   public String[] getMethodNames()
   36:   {
   37:     return mns;
   38:   }
   39:   
   40:   public String[] getDeclaredMethodNames()
   41:   {
   42:     return dmns;
   43:   }
   44:   
   45:   public void setPropertyValue(Object paramObject1, String paramString, Object paramObject2)
   46:   {
   47:     DemoServiceImpl w;
   48:     try
   49:     {
   50:       w = (DemoServiceImpl)paramObject1;
   51:     }
   52:     catch (Throwable localThrowable)
   53:     {
   54:       throw new IllegalArgumentException(localThrowable);
   55:     }
   56:     if (paramString.equals("test01"))
   57:     {
   58:       w.test01 = ((String)paramObject2);
   59:       return;
   60:     }
   61:     if (paramString.equals("demoDAO"))
   62:     {
   63:       localDemoServiceImpl.setDemoDAO((DemoDAO)paramObject2);
   64:       return;
   65:     }
   66:     throw new NoSuchPropertyException("Not found property \"" + paramString + "\" filed or setter method in class com.alibaba.dubbo.demo.provider.DemoServiceImpl.");
   67:   }
   68:   
   69:   public Object getPropertyValue(Object paramObject, String paramString)
   70:   {
   71:     DemoServiceImpl w;
   72:     try
   73:     {
   74:       w = (DemoServiceImpl)paramObject;
   75:     }
   76:     catch (Throwable localThrowable)
   77:     {
   78:       throw new IllegalArgumentException(localThrowable);
   79:     }
   80:     if (paramString.equals("test01")) {
   81:       return localDemoServiceImpl.test01;
   82:     }
   83:     throw new NoSuchPropertyException("Not found property \"" + paramString + "\" filed or setter method in class com.alibaba.dubbo.demo.provider.DemoServiceImpl.");
   84:   }
   85:   
   86:   public Object invokeMethod(Object paramObject, String paramString, Class[] paramArrayOfClass, Object[] paramArrayOfObject)
   87:     throws InvocationTargetException
   88:   {
   89:     DemoServiceImpl w;
   90:     try
   91:     {
   92:       w = (DemoServiceImpl)paramObject;
   93:     }
   94:     catch (Throwable localThrowable1)
   95:     {
   96:       throw new IllegalArgumentException(localThrowable1);
   97:     }
   98:     try
   99:     {
  100:       if ("sayHello".equals(paramString) && paramArrayOfClass.length == 1) {
  101:         return w.sayHello((String)paramArrayOfObject[0]);
  102:       }
  103:       if ("bye".equals(paramString) && paramArrayOfClass.length == 1)
  104:       {
  105:         w.bye((Object)paramArrayOfObject[0]);
  106:         return null;
  107:       }
  108:       if ("setDemoDAO".equals(paramString) && paramArrayOfClass.length == 1)
  109:       {
  110:         w.setDemoDAO((DemoDAO)paramArrayOfObject[0]);
  111:         return null;
  112:       }
  113:     }
  114:     catch (Throwable localThrowable2)
  115:     {
  116:       throw new InvocationTargetException(localThrowable2);
  117:     }
  118:     throw new NoSuchMethodException("Not found method \"" + paramString + "\" in class com.alibaba.dubbo.demo.provider.DemoServiceImpl.");
  119:   }
  120: }
  ```

  - 该类通过 `dubbo-common` 模块的 `bytecode` 模块的 Wrapper 类，**自动生成**，使用 Javassist 技术。
  - 不同于生成的 **proxy**类，不实现 Service 接口类，而是在 `#invokeMethod(paramObject, paramString, paramArrayOfClass, paramArrayOfObject)` 方法，提供给 `Invoker#invoke(invocation)` 中调用，统一分发请求到 Service 对应的方法。从职能上来看，有一点像硬编码的 Controller 。
  - 一个生成的 **Wrapper**类，只对应一个 Service ，从第 75 行的代码，我们也可以看出。

## 4. ProxyFactory

[`com.alibaba.dubbo.rpc.ProxyFactory`](https://github.com/YunaiV/dubbo/blob/6de0a069fcc870894e64ffd54a24e334b19dcb36/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/ProxyFactory.java) ，代理工厂接口。

在 [《精尽 Dubbo 源码分析 —— 核心流程一览》](http://svip.iocoder.cn/Dubbo/implementation-intro/) 的 [「4.5 ProxyFactory」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#)，已经分享，胖友点击查看。

[![ProxyFactory 子类](http://static.iocoder.cn/images/Dubbo/2018_03_01/13.png)](http://static.iocoder.cn/images/Dubbo/2018_03_01/13.png)ProxyFactory 子类

#### 4.1 AbstractProxyFactory

`com.alibaba.dubbo.rpc.proxy.AbstractProxyFactory` ，实现 ProxyFactory 接口，代理工厂抽象类。代码如下：

```
 1: public abstract class AbstractProxyFactory implements ProxyFactory {
 2: 
 3:     public <T> T getProxy(Invoker<T> invoker) throws RpcException {
 4:         Class<?>[] interfaces = null;
 5:         // TODO 8022 芋艿
 6:         String config = invoker.getUrl().getParameter("interfaces");
 7:         if (config != null && config.length() > 0) {
 8:             String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);
 9:             if (types != null && types.length > 0) {
10:                 interfaces = new Class<?>[types.length + 2];
11:                 interfaces[0] = invoker.getInterface();
12:                 interfaces[1] = EchoService.class;
13:                 for (int i = 0; i < types.length; i++) {
14:                     interfaces[i + 1] = ReflectUtils.forName(types[i]);
15:                 }
16:             }
17:         }
18:         // 增加 EchoService 接口，用于回生测试。参见文档《回声测试》http://dubbo.apache.org/zh-cn/docs/user/demos/echo-service.html
19:         if (interfaces == null) {
20:             interfaces = new Class<?>[]{invoker.getInterface(), EchoService.class};
21:         }
22:         return getProxy(invoker, interfaces);
23:     }
24: 
25:     public abstract <T> T getProxy(Invoker<T> invoker, Class<?>[] types);
26: 
27: }
```

- 可以看到，该抽象类，主要是实现了 `#getProxy(invoker)` 方法，获得需要生成代理的接口们。

  - 第 5 至 17 行： TODO 8022 芋艿

  - 第 18 至 21 行：在原有 Invoker 对应**关联**的 Service 接口之上，增加 EchoService 接口。

    > FROM [《Dubbo 用户指南 —— 回声测试》](http://dubbo.apache.org/zh-cn/docs/user/demos/echo-service.html)
    >
    > 回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。
    > 所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。

  - 第 22 行：调用 `#getProxy(invoker, types)` **抽象**方法，获得 Proxy 对象。

#### 4.2 StubProxyFactoryWrapper

[`com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper`](https://github.com/YunaiV/dubbo/blob/afb312f7dce997f5f90ba686345f4354e786534d/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/wrapper/StubProxyFactoryWrapper.java) ，实现 ProxyFactory 接口，Stub 代理工厂 Wrapper 实现类，基于 Dubbo SPI Wrapper 机制加载。

🙂 该类，不在本文的范畴内，感兴趣的胖友可以先看下 [《Dubbo 用户指南 —— 本地存根》](http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html) 。后续，我们单独开文章分享。

#### 4.3 JavassistProxyFactory

`com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory` ，实现 AbstractProxyFactory 抽象类，基于 Javassist 代理工厂实现类。代码如下：

```
 1: public class JavassistProxyFactory extends AbstractProxyFactory {
 2: 
 3:     @SuppressWarnings("unchecked")
 4:     public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
 5:         return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
 6:     }
 7: 
 8:     public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
 9:         // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
10:         // TODO Wrapper类不能正确处理带$的类名
11:         final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
12:         return new AbstractProxyInvoker<T>(proxy, type, url) {
13:             @Override
14:             protected Object doInvoke(T proxy, String methodName,
15:                                       Class<?>[] parameterTypes,
16:                                       Object[] arguments) throws Throwable {
17:                 return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
18:             }
19:         };
20:     }
21: 
22: }
```

- ```
  #getProxy(invoker, interfaces)
  ```

   

  方法

  - 第 5 行：调用 `Proxy#getProxy(interface)` 方法，获得 **Proxy** 对象。

  - 第 5 行：调用

     

    ```
    Proxy#newInstance(InvocationHandler)
    ```

     

    方法，获得

     

    proxy

     

    对象。其中传入的参数是 InvokerInvocationHandler 类，通过这样的方式，让 proxy 和真正的逻辑代码解耦。

    - Proxy 和 proxy ，在 [「7.3 Proxy」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 中，详细解析。
    - InvokerInvocationHandler ，在 [「5. InvokerInvocationHandler」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 中，详细解析。

- ```
  #getInvoker(proxy, type, url)
  ```

   

  方法

  - 第 11 行：调用

     

    ```
    Wrapper#getWrapper(Class<?>)
    ```

     

    方法，获得

     

    Wrapper

     

    对象。

    - Wrapper ，在 [「7.4 Wrapper」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 中，详细解析。

  - 第 12 至 19 行：创建 AbstractProxyInvoker 对象，实现

     

    ```
    #doInvoke(...)
    ```

     

    方法。在该方法中，调用

     

    ```
    Wrapper#invokeMethod(...)
    ```

     

    方法，从而调用 Service 的方法。

    - AbstractProxyInvoker ，在 [「6. AbstractProxyInvoker」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 中，详细解析。

## 5. InvokerInvocationHandler

`com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler` ，实现 [`java.lang.reflect.InvocationHandler`](https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html) 接口，代码如下：

```
 1: public class InvokerInvocationHandler implements InvocationHandler {
 2: 
 3:     /**
 4:      * Invoker 对象
 5:      */
 6:     private final Invoker<?> invoker;
 7: 
 8:     public InvokerInvocationHandler(Invoker<?> handler) {
 9:         this.invoker = handler;
10:     }
11: 
12:     @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
13:         String methodName = method.getName();
14:         Class<?>[] parameterTypes = method.getParameterTypes();
15:         // wait 等方法，直接反射调用
16:         if (method.getDeclaringClass() == Object.class) {
17:             return method.invoke(invoker, args);
18:         }
19:         // 基础方法，不使用 RPC 调用
20:         if ("toString".equals(methodName) && parameterTypes.length == 0) {
21:             return invoker.toString();
22:         }
23:         if ("hashCode".equals(methodName) && parameterTypes.length == 0) {
24:             return invoker.hashCode();
25:         }
26:         if ("equals".equals(methodName) && parameterTypes.length == 1) {
27:             return invoker.equals(args[0]);
28:         }
29:         // RPC 调用
30:         return invoker.invoke(new RpcInvocation(method, args)).recreate();
31:     }
32: 
33: }
```

- `invoker` 属性，Invoker 对象，用于在 `#invoke()` 方法调用。

- `#invoke(proxy, method, args)` **实现**方法，核心逻辑是调用 `Invoker#invoke(invocation)` 方法，进行 RPC 调用。

  - 第 16 至 18 行：处理 `#wait()` `#notify()` 等方法，进行反射调用。

  - 第 20 至 28 行：处理 `#toString()` `#hashCode()` 等方法，使用 Invoker 对象的方法，不进行 RPC 调用。

  - 第 30 行：调用 `Invoker#invoke(invocation)` 方法，**核心逻辑**，进行 RPC 调用。

  - 第 30 行：调用 `Result#recreate()` 方法，回放调用结果。代码如下：

    ```
    // RpcResult.java
    public Object recreate() throws Throwable {
        // 有异常，抛出异常
        if (exception != null) {
            throw exception;
        }
        // 无异常，返回结果
        return result;
    }
    ```

    - x

🙂 通过 InvokerInvocationHandler ，可以实现 Proxy 和真正的逻辑解耦。

## 6. AbstractProxyInvoker

`com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker` ，实现 Invoker 接口，**代理** Invoker 对象的抽象类。

#### 6.1 属性

```
/**
 * 代理的对象，一般是 Service 实现对象
 */
private final T proxy;
/**
 * 接口类型，一般是 Service 接口
 */
private final Class<T> type;
/**
 * URL 对象，一般是暴露服务的 URL 对象
 */
private final URL url;

public AbstractProxyInvoker(T proxy, Class<T> type, URL url) {
    if (proxy == null) {
        throw new IllegalArgumentException("proxy == null");
    }
    if (type == null) {
        throw new IllegalArgumentException("interface == null");
    }
    if (!type.isInstance(proxy)) { //
        throw new IllegalArgumentException(proxy.getClass().getName() + " not implement interface " + type);
    }
    this.proxy = proxy;
    this.type = type;
    this.url = url;
}
```

🙂 胖友，请看代码上的注释。

#### 6.2 invoke

```
1: public Result invoke(Invocation invocation) throws RpcException {
2:     try {
3:         return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
4:     } catch (InvocationTargetException e) {
5:         return new RpcResult(e.getTargetException());
6:     } catch (Throwable e) {
7:         throw new RpcException("Failed to invoke remote proxy method " + invocation.getMethodName() + " to " + getUrl() + ", cause: " + e.getMessage(), e);
8:     }
9: }
```

- 第 3 行：调用 `#doInvoke(..)` **抽象**方法，执行调用，返回调用结果。`#doInvoke(...)` 方法，代码如下：

  ```
  /**
   * 执行调用
   *
   * @param proxy 代理的对象
   * @param methodName 方法名
   * @param parameterTypes 方法参数类型数组
   * @param arguments 方法参数数组
   * @return 调用结果
   * @throws Throwable 发生异常
   */
  protected abstract Object doInvoke(T proxy, String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Throwable;
  ```

- 第 3 行：创建 RpcResult 对象，将结果包装返回。

- 第 5 行：发生 InvocationTargetException 异常，创建 RpcResult 对象包装。

  - [《 Java反射异常处理之InvocationTargetException》](https://blog.csdn.net/zhangzeyuaaa/article/details/39611467)

## 7. bytecode

在 `dubbo-common` 模块的 `bytecode` 包，基于 Javassit 库，**动态编译**，实现提供了**通用的**的动态代理实现。所以本小节，从**动态编译**的角度上来看，在内容上，和 [《精尽 Dubbo 源码分析 —— 动态编译（一）之 Javassist》](http://svip.iocoder.cn/Dubbo/compiler-javassist/?self) 有一定的相似。

#### 7.1 ClassGenerator

[`com.alibaba.dubbo.common.bytecode.ClassGenerator`](https://github.com/YunaiV/dubbo/blob/b5a5adcd965393b374a4f58ecea90264251c3cdb/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/ClassGenerator.java) ，类生成器，基于 **Javassist** 实现。

笔者在 [《TCC-Transaction 源码分析 —— Dubbo 支持》](http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self) 的 [「2.1.3 TccProxy & TccClassGenerator」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 已经详细分享，基本类似，胖友瞅瞅噢。

#### 7.3 Proxy

[`com.alibaba.dubbo.common.bytecode.Proxy`](https://github.com/YunaiV/dubbo/blob/b5a5adcd965393b374a4f58ecea90264251c3cdb/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Proxy.java) ，代理抽象类，用于创建 Proxy 和 proxy 对象。

笔者在 [《TCC-Transaction 源码分析 —— Dubbo 支持》](http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self) 的 [「2.1.3 TccProxy & TccClassGenerator」](http://svip.iocoder.cn/Dubbo/proxy-javassist/#) 已经详细分享，基本类似，胖友瞅瞅噢。

------

如下是一个生成的 **Proxy** 代码的示例，代码如下：

```
public class Proxy0 extends Proxy implements ClassGenerator.DC {
    
    public Object newInstance(InvocationHandler paramInvocationHandler) {
        return new proxy0(paramInvocationHandler);
    }
    
}
```

- **生成的Proxy** 实现 Proxy 抽象类，是创建 **生成的proxy** 的工厂（一一对应）。例如，Proxy0 创建 proxy0 对象。
- `#newInstance(InvocationHandler)` 方法，创建 **生成的proxy** 的方法。

#### 7.4 Wrapper

[`com.alibaba.dubbo.common.bytecode.Wrapper`](http://svip.iocoder.cn/Dubbo/proxy-javassist/TODO) ，Wrapper 抽象类，用于**创建某个对象的方法调用**的包装器，以避免**反射**调用，提高性能。即：

```
// 反射
Method#invoke(Object instance, Object[] args)

// 优化成===>

// Wrapper
Wrapper#invokeMethod(Object instance, String mn, Class<?>[] types, Object[] args)
```

- 为什么会提高性能呢？看到上文的 Wrapper 代理的示例，相信胖友已经明白。

###### 7.4.1 抽象方法

在自动生成 Wrapper 类时，需要实现如下**抽象**方法：

```
abstract public String[] getPropertyNames();
abstract public Class<?> getPropertyType(String pn);

abstract public boolean hasProperty(String name);
abstract public Object getPropertyValue(Object instance, String pn) throws NoSuchPropertyException, IllegalArgumentException;
abstract public void setPropertyValue(Object instance, String pn, Object pv) throws NoSuchPropertyException, IllegalArgumentException;

abstract public String[] getMethodNames();
abstract public String[] getDeclaredMethodNames();

/**
 * invoke method.
 *
 * 调用方法
 *
 * @param instance instance.
 *                 被调用的对象
 * @param mn       method name.
 *                 方法名
 * @param types 参数类型数组
 * @param args     argument array.
 *                 参数数组
 * @return return value.
 *                  返回值
 */
abstract public Object invokeMethod(Object instance, String mn, Class<?>[] types, Object[] args) throws NoSuchMethodException, InvocationTargetException;
```

###### 7.4.2 getWrapper

`#getWrapper(c)` 方法，根据指定类，获得 Wrapper 对象。代码如下：

```
 1: public static Wrapper getWrapper(Class<?> c) {
 2:     // 判断是否继承 ClassGenerator.DC.class ，如果是，拿到父类，避免重复包装
 3:     while (ClassGenerator.isDynamicClass(c)) // can not wrapper on dynamic class.
 4:         c = c.getSuperclass();
 5: 
 6:     // 指定类为 Object.class
 7:     if (c == Object.class)
 8:         return OBJECT_WRAPPER;
 9: 
10:     // 从缓存中获得 Wrapper 对象
11:     Wrapper ret = WRAPPER_MAP.get(c);
12:     // 创建 Wrapper 对象，并添加到缓存
13:     if (ret == null) {
14:         ret = makeWrapper(c);
15:         WRAPPER_MAP.put(c, ret);
16:     }
17:     return ret;
18: }
```

- 第 3 至 4 行：判断是否已经继承了 [ClassGenerator.DC.class](https://github.com/YunaiV/dubbo/blob/91b4862d4aed0f984015b132c3cb426f9c3b0c76/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/ClassGenerator.java#L382-L386) ，如果是，拿到父类，避免**重复包装**。

- 第 7 至 8 行：若指定类为 Object.class ，返回 [OBJECT_WRAPPER](https://github.com/YunaiV/dubbo/blob/91b4862d4aed0f984015b132c3cb426f9c3b0c76/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Wrapper.java#L43-L95) 对象。

- 第 11 行：从缓存 `WRAPPER_MAP` 中，获得 Wrapper 对象。`WRAPPER_MAP` 代码如下：

  ```
  /**
   * Wrapper 对象缓存
   * key ：Wrapper 类。
   * value ：Proxy 对象
   */
  private static final Map<Class<?>, Wrapper> WRAPPER_MAP = new ConcurrentHashMap<Class<?>, Wrapper>(); //class wrapper map
  ```

- 第 13 至 16 行：调用 `#makeWrapper(Class<?>)` 方法，创建 Wrapper 对象，并添加到缓存。

###### 7.4.3 makeWrapper

`#makeWrapper(Class<?>)` 方法，创建 Wrapper 对象。代码如下：

> 旁白君：实现上，和 Proxy 差不过的，只生成**一个** Wrapper 类。

```
  1: private static Wrapper makeWrapper(Class<?> c) {
  2:     // 非私有类
  3:     if (c.isPrimitive())
  4:         throw new IllegalArgumentException("Can not create wrapper for primitive type: " + c);
  5: 
  6:     // 类名
  7:     String name = c.getName();
  8:     // 类加载器
  9:     ClassLoader cl = ClassHelper.getClassLoader(c);
 10: 
 11:     // 设置属性方法 `#setPropertyValue(o, n, v)` 的开头的代码
 12:     StringBuilder c1 = new StringBuilder("public void setPropertyValue(Object o, String n, Object v){ ");
 13:     // 获得属性方法 `#getPropertyValue(o, n)` 的开头的代码
 14:     StringBuilder c2 = new StringBuilder("public Object getPropertyValue(Object o, String n){ ");
 15:     // 调用方法 `#invokeMethod(o, n, p, v)` 的开头的代码
 16:     StringBuilder c3 = new StringBuilder("public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws " + InvocationTargetException.class.getName() + "{ ");
 17: 
 18:     // 添加每个方法的，被调用对象的类型转换的代码
 19:     c1.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
 20:     c2.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
 21:     c3.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
 22: 
 23:     // 属性名与属性名的集合，用于 `#hasProperty(...)` `#setPropertyValue(...)` `getPropertyValue(...)` 方法。
 24:     Map<String, Class<?>> pts = new HashMap<String, Class<?>>(); // <property name, property types>
 25:     // 方法签名与方法对象的集合，用于 `#invokeMethod(..)` 方法。
 26:     Map<String, Method> ms = new LinkedHashMap<String, Method>(); // <method desc, Method instance>
 27:     // 方法名数组用于 `#getMethodNames()` 方法。
 28:     List<String> mns = new ArrayList<String>(); // method names.
 29:     // 定义的方法名数组，用于 `#getDeclaredMethodNames()` 方法。
 30:     List<String> dmns = new ArrayList<String>(); // declaring method names.
 31: 
 32:     // 循环 public 属性，添加每个属性的设置和获得分别到 `#setPropertyValue(o, n, v)` 和 `#getPropertyValue(o, n)` 的代码
 33:     // get all public field.
 34:     for (Field f : c.getFields()) {
 35:         String fn = f.getName();
 36:         Class<?> ft = f.getType();
 37:         if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) // 排除 static 和 transient
 38:             continue;
 39: 
 40:         c1.append(" if( $2.equals(\"").append(fn).append("\") ){ w.").append(fn).append("=").append(arg(ft, "$3")).append("; return; }");
 41:         c2.append(" if( $2.equals(\"").append(fn).append("\") ){ return ($w)w.").append(fn).append("; }");
 42:         // 添加到 `pts` 中
 43:         pts.put(fn, ft);
 44:     }
 45: 
 46:     Method[] methods = c.getMethods();
 47:     // 如果有方法，添加 `#invokeMethod(o, n, p, v)` 的 try 的代码
 48:     // get all public method.
 49:     boolean hasMethod = hasMethods(methods);
 50:     if (hasMethod) {
 51:         c3.append(" try{");
 52:     }
 53:     for (Method m : methods) {
 54:         // 跳过来自 Object 的内置方法
 55:         if (m.getDeclaringClass() == Object.class) //ignore Object's method.
 56:             continue;
 57: 
 58:         String mn = m.getName(); // 方法名
 59:         // 使用方法名 + 方法参数长度来判断
 60:         c3.append(" if( \"").append(mn).append("\".equals( $2 ) ");
 61:         int len = m.getParameterTypes().length;
 62:         c3.append(" && ").append(" $3.length == ").append(len);
 63: 
 64:         // 若相同方法名存在多个，增加参数类型数组的比较判断
 65:         boolean override = false;
 66:         for (Method m2 : methods) {
 67:             if (m != m2 && m.getName().equals(m2.getName())) {
 68:                 override = true;
 69:                 break;
 70:             }
 71:         }
 72:         if (override) {
 73:             if (len > 0) {
 74:                 for (int l = 0; l < len; l++) {
 75:                     c3.append(" && ").append(" $3[").append(l).append("].getName().equals(\"")
 76:                             .append(m.getParameterTypes()[l].getName()).append("\")");
 77:                 }
 78:             }
 79:         }
 80: 
 81:         c3.append(" ) { ");
 82: 
 83:         // 添加调用对象的对应方法的代码
 84:         if (m.getReturnType() == Void.TYPE)
 85:             c3.append(" w.").append(mn).append('(').append(args(m.getParameterTypes(), "$4")).append(");").append(" return null;");
 86:         else
 87:             c3.append(" return ($w)w.").append(mn).append('(').append(args(m.getParameterTypes(), "$4")).append(");");
 88: 
 89:         c3.append(" }");
 90: 
 91:         // 添加到 `mns` 中
 92:         mns.add(mn);
 93:         // 添加到 `dmns` 中
 94:         if (m.getDeclaringClass() == c)
 95:             dmns.add(mn);
 96:         // 添加到 `ms` 中
 97:         ms.put(ReflectUtils.getDesc(m), m);
 98:     }
 99:     // 如果有方法，添加 `#invokeMethod(o, n, p, v)` 的 catch 的代码
100:     if (hasMethod) {
101:         c3.append(" } catch(Throwable e) { ");
102:         c3.append("     throw new java.lang.reflect.InvocationTargetException(e); ");
103:         c3.append(" }");
104:     }
105:     // 添加 `#invokeMethod(o, n, p, v)` 的未匹配到方法的代码
106:     c3.append(" throw new " + NoSuchMethodException.class.getName() + "(\"Not found method \\\"\"+$2+\"\\\" in class " + c.getName() + ".\"); }");
107: 
108:     // 循环 setting/getting 方法，添加每个属性的设置和获得分别到 `#setPropertyValue(o, n, v)` 和 `#getPropertyValue(o, n)` 的代码
109:     // deal with get/set method.
110:     Matcher matcher;
111:     for (Map.Entry<String, Method> entry : ms.entrySet()) {
112:         String md = entry.getKey();
113:         Method method = entry.getValue();
114:         if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
115:             String pn = propertyName(matcher.group(1));
116:             c2.append(" if( $2.equals(\"").append(pn).append("\") ){ return ($w)w.").append(method.getName()).append("(); }");
117:             // 添加到 `pts` 中
118:             pts.put(pn, method.getReturnType());
119:         } else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) {
120:             String pn = propertyName(matcher.group(1));
121:             c2.append(" if( $2.equals(\"").append(pn).append("\") ){ return ($w)w.").append(method.getName()).append("(); }");
122:             // 添加到 `pts` 中
123:             pts.put(pn, method.getReturnType());
124:         } else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) { // 不支持 public T setName(String name) { this.name = name; return this;} 这种返回 this 的形式。
125:             Class<?> pt = method.getParameterTypes()[0];
126:             String pn = propertyName(matcher.group(1));
127:             c1.append(" if( $2.equals(\"").append(pn).append("\") ){ w.").append(method.getName()).append("(").append(arg(pt, "$3")).append("); return; }");
128:             // 添加到 `pts` 中
129:             pts.put(pn, pt);
130:         }
131:     }
132:     c1.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class " + c.getName() + ".\"); }");
133:     c2.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class " + c.getName() + ".\"); }");
134: 
135:     // make class
136:     long id = WRAPPER_CLASS_COUNTER.getAndIncrement();
137:     // 创建 ClassGenerator 对象
138:     ClassGenerator cc = ClassGenerator.newInstance(cl);
139:     // 设置类名
140:     cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + "$sw") + id);
141:     // 设置父类为 Wrapper.class
142:     cc.setSuperClass(Wrapper.class);
143: 
144:     // 添加构造方法，参数 空
145:     cc.addDefaultConstructor();
146:     // 添加静态属性 `pns` 的代码
147:     cc.addField("public static String[] pns;"); // property name array.
148:     // 添加静态属性 `pts` 的代码
149:     cc.addField("public static " + Map.class.getName() + " pts;"); // property type map.
150:     // 添加静态属性 `pts` 的代码
151:     cc.addField("public static String[] mns;"); // all method name array.
152:     // 添加静态属性 `dmns` 的代码
153:     cc.addField("public static String[] dmns;"); // declared method name array.
154:     // 添加静态属性 `mts` 的代码。每个方法的参数数组。
155:     for (int i = 0, len = ms.size(); i < len; i++)
156:         cc.addField("public static Class[] mts" + i + ";");
157: 
158:     // ======= 添加抽象方法的实现，到 `cc` 中
159:     // 添加 `#getPropertyNames()` 的代码到 `cc`
160:     cc.addMethod("public String[] getPropertyNames(){ return pns; }");
161:     // 添加 `#hasProperty(n)` 的代码到 `cc`
162:     cc.addMethod("public boolean hasProperty(String n){ return pts.containsKey($1); }");
163:     // 添加 `#getPropertyType(n)` 的代码到 `cc`
164:     cc.addMethod("public Class getPropertyType(String n){ return (Class)pts.get($1); }");
165:     // 添加 `#getMethodNames()` 的代码到 `cc`
166:     cc.addMethod("public String[] getMethodNames(){ return mns; }");
167:     // 添加 `#getDeclaredMethodNames()` 的代码到 `cc`
168:     cc.addMethod("public String[] getDeclaredMethodNames(){ return dmns; }");
169:     // 添加 `#setPropertyValue(o, n, v)` 的代码到 `cc`
170:     cc.addMethod(c1.toString());
171:     // 添加 `#getPropertyValue(o, n)` 的代码到 `cc`
172:     cc.addMethod(c2.toString());
173:     // 添加 `#invokeMethod(o, n, p, v)` 的代码到 `cc`
174:     cc.addMethod(c3.toString());
175: 
176:     try {
177:         // 生成类
178:         Class<?> wc = cc.toClass();
179:         // 反射，设置静态变量的值
180:         // setup static field.
181:         wc.getField("pts").set(null, pts);
182:         wc.getField("pns").set(null, pts.keySet().toArray(new String[0]));
183:         wc.getField("mns").set(null, mns.toArray(new String[0]));
184:         wc.getField("dmns").set(null, dmns.toArray(new String[0]));
185:         int ix = 0;
186:         for (Method m : ms.values())
187:             wc.getField("mts" + ix++).set(null, m.getParameterTypes());
188:         // 创建对象
189:         return (Wrapper) wc.newInstance();
190:     } catch (RuntimeException e) {
191:         throw e;
192:     } catch (Throwable e) {
193:         throw new RuntimeException(e.getMessage(), e);
194:     } finally {
195:         // 释放资源
196:         cc.release();
197:         ms.clear();
198:         mns.clear();
199:         dmns.clear();
200:     }
201: }
```

- 上文生成的 Wrapper1 的代码，对应的 DempServiceImpl 的代码如下：

  ```
   1: public class DemoServiceImpl implements DemoService {
   2: 
   3:     /**
   4:      * 测试属性，{@link com.alibaba.dubbo.common.bytecode.Wrapper}
   5:      */
   6:     public String test01;
   7: 
   8:     private DemoDAO demoDAO;
   9: 
  10:     public String sayHello(String name) {
  11:         System.out.println("[" + new SimpleDateFormat("HH:mm:ss").format(new Date()) + "] Hello " + name + ", request from consumer: " + RpcContext.getContext().getRemoteAddress());
  12:         return "Hello " + name + ", response form provider: " + RpcContext.getContext().getLocalAddress();
  13:     }
  14: 
  15:     @Override
  16:     public void bye(Object o) {
  17:         System.out.println(JSON.toJSONString(o));
  18:         System.out.println(o.getClass());
  19:     }
  20: 
  21:     public void setDemoDAO(DemoDAO demoDAO) {
  22:         this.demoDAO = demoDAO;
  23:     }
  24: 
  25: }
  ```

  - 下面，我们的解析，会结合这个类一起讲。

  - ========== 生成代码 ==========

- 第 11 至 16 行：创建方法的

  开头

  的代码：

  - `#setPropertyValue(o, n, v)` 的【Wrapper1 第 45 至 46 行】
  - `#getPropertyValue(o, n)` 的【Wrapper1 第 69 至 70 行】
  - `#invokeMethod(o, n, p, v)` 的【Wrapper1 第 86 至 88 行】

- 第 19 至 21 行：设置方法的

  被调用对象的类型转换

  的代码：

  - ```
    #setPropertyValue(o, n, v)
    ```

     

    的【Wrapper1 第 47 至 55 行】

    - `#getPropertyValue(o, n)` 的【Wrapper1 第 71 至 79 行】
    - `#invokeMethod(o, n, p, v)` 的【Wrapper1 第 89 至 97 行】

- 第 23 至 30 行：声明 `pts` `ms` `mn` `dmns` 变量。🙂 每个变量的用途，已经添加到代码的注释上。

- 第 32 至 44 行：循环

   

  public

   

  属性，添加每个属性的设置和获得分别代码：

  - 【DemoServiceImpl 第 6 行】
  - `#setPropertyValue(o, n, v)` 的【Wrapper1 第 56 至 60 行】
  - `#getPropertyValue(o, n)` 的【Wrapper1 第 80 至 62 行】

- 第 46 至 106 行：设置方法

   

  ```
  #invokeMethod(o, n, p, v)
  ```

   

  的调用代码：

  - 【DemoServiceImpl 第 10 至 23 行】
  - 【Wrapper1 第 98 至 119 行】

- 第 108 至 131 行：循环

   

  setting / getting

   

  属性，添加每个属性的设置和获得分别代码：

  - ```
    #setPropertyValue(o, n, v)
    ```

    - 【DemoServiceImpl 第 21 至 23 行】【DemoServiceImpl 第 8 行】
    - 【Wrapper1 第 61 至 62 行】

  - 🙂 `#getPropertyValue(o, n)` 没举例子，胖友自己看代码脑补。

- ========== 生成类 ==========

- 第 138 行：创建 ClassGenerator 对象。

- 第 140 行：设置类名。

- 第 142 行：设置父类为 Wrapper.class

- 第 145 行：添加构造方法，参数为空

- 第 146 至 156 行：添加**静态属性** `pns` `pts` `mns` `dmns` `mts` 。

- 第 158 至 174 行：添加**抽象方法**的实现。

- 第 178 行：生成类。

- ========== 创建对象 ==========

- 第 179 至 187 行：反射，设置**静态属性**的值。

- 第 189 行：创建 Wrapper 对象。

- ========== 释放 ==========

- 第 195 至 199 行：释放资源。

# JDK

## 1. 概述

本文接 [《精尽 Dubbo 源码分析 —— 动态代理（一）之 Javassist》](http://svip.iocoder.cn/Dubbo/proxy-javassist/?self) 一文，分享使用 **JDK** 生成动态代理的代码实现。

如果 JDK Proxy 不熟悉的胖友，可以看下 [《 Java JDK 动态代理（AOP）使用及实现原理分析》](http://blog.csdn.net/jiankunking/article/details/52143504#) 学习下。🙂 学无止境呀。

另外，如果使用 JDK 生成代理，配置方式如下：

```
// 服务引用
<dubbo:reference proxy="jdk" />

// 服务暴露
<dubbo:service proxy="jdk" />
```

## 2. JdkProxyFactory

`com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory` ，实现 AbstractProxyInvoker 抽象类，代码如下：

```
 1: public class JdkProxyFactory extends AbstractProxyFactory {
 2: 
 3:     @SuppressWarnings("unchecked")
 4:     public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
 5:         return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));
 6:     }
 7: 
 8:     public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
 9:         return new AbstractProxyInvoker<T>(proxy, type, url) {
10:             @Override
11:             protected Object doInvoke(T proxy, String methodName,
12:                                       Class<?>[] parameterTypes,
13:                                       Object[] arguments) throws Throwable {
14:                 // 获得方法
15:                 Method method = proxy.getClass().getMethod(methodName, parameterTypes);
16:                 // 调用方法
17:                 return method.invoke(proxy, arguments);
18:             }
19:         };
20:     }
21: 
22: }
```

- ```
  #getProxy(invoker, interfaces)
  ```

   

  方法

  - 第 5 行：创建 InvokerInvocationHandler 对象，传入 `invoker` 对象。
  - 第 5 行：调用 `java.lang.reflect.Proxy#getProxy(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)` 方法，创建 Proxy 对象。
  - 🙂 相比 Javassist 精简很多，期待 JDK Proxy 的不断性能优化。

- ```
  #getInvoker(proxy, type, url)
  ```

   

  方法

  - 第 9 至 19 行：创建 AbstractProxyInvoker 对象，实现

     

    ```
    #doInvoker(...)
    ```

     

    方法。

    - 第 15 行：调用 `Class#getMethod(String name, Class<?>... parameterTypes)` 方法，反射获得方法。
    - 第 17 行：调用 `Method#invoke(proxy, arguments)` 方法，执行方法。
    - 推荐阅读：[《Java反射原理简析》](http://www.fanyilun.me/2015/10/29/Java反射原理/)

# 本地存根 Stub

## 1. 概述

本文接 [《精尽 Dubbo 源码分析 —— 动态代理（二）之 JDK》](http://svip.iocoder.cn/Dubbo/proxy-jdk/?self) 一文，分享使用 Dubbo **本地存根( Stub )**的特性。😁 当然，从标题我们就可以看出，实现的原理是基于**动态代理**的机制。

在 [《Dubbo 用户指南 —— 本地存根》](http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html) 中，已经非常详尽的分享了**本地存根**的概念和使用，本文就不重复介绍啦。😈 文档有一点点小小的错误，在 Spring 配置文件的配置方式应该是如下：

```
<dubbo:reference interface="com.alibaba.dubbo.demo.DemoService" stub="com.alibaba.dubbo.demo.consumer.DemoServiceStub">
```

- 是服务引用 `<dubbo:reference />` ，而不是服务暴露 `<dubbo:service />`

## 2. StubProxyFactoryWrapper

[`com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper`](http://svip.iocoder.cn/Dubbo/proxy-local-stub/TODO) ，实现 ProxyFactory 接口，存根代理工厂**包装器**实现类。

### 2.1 构造方法

```
/**
 * ProxyFactory$Adaptive 对象
 */
private final ProxyFactory proxyFactory;
/**
 * Protocol$Adaptive 对象
 */
private Protocol protocol;

public StubProxyFactoryWrapper(ProxyFactory proxyFactory) {
    this.proxyFactory = proxyFactory;
}

public void setProtocol(Protocol protocol) {
    this.protocol = protocol;
}
```

- `proxyFactory` 属性，ProxyFactory$Adaptive 对象。StubProxyFactoryWrapper 基于 Dubbo SPI Wrapper 机制，所以使用 ProxyFactory 创建代理的流程，实际变成如下：[![流程](http://static.iocoder.cn/images/Dubbo/2018_09_19/01.png)](http://static.iocoder.cn/images/Dubbo/2018_09_19/01.png)流程
- `protocol` 属性，Protocol$Adaptive 对象。

### 2.2 getProxy

```
 1: @Override
 2: @SuppressWarnings({"unchecked", "rawtypes"})
 3: public <T> T getProxy(Invoker<T> invoker) throws RpcException {
 4:     // 获得 Service Proxy 对象
 5:     T proxy = proxyFactory.getProxy(invoker);
 6:     if (GenericService.class != invoker.getInterface()) { // 非泛化引用
 7:         // 获得 `stub` 配置项
 8:         String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));
 9:         if (ConfigUtils.isNotEmpty(stub)) {
10:             Class<?> serviceType = invoker.getInterface();
11:             // `stub = true` 的情况，使用接口 + `Stub` 字符串。
12:             if (ConfigUtils.isDefault(stub)) {
13:                 if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) {
14:                     stub = serviceType.getName() + "Stub";
15:                 } else {
16:                     stub = serviceType.getName() + "Local";
17:                 }
18:             }
19:             try {
20:                 // 加载 Stub 类
21:                 Class<?> stubClass = ReflectUtils.forName(stub);
22:                 if (!serviceType.isAssignableFrom(stubClass)) {
23:                     throw new IllegalStateException("The stub implementation class " + stubClass.getName() + " not implement interface " + serviceType.getName());
24:                 }
25:                 try {
26:                     // 创建 Stub 对象，使用带 Service Proxy 对象的构造方法
27:                     Constructor<?> constructor = ReflectUtils.findConstructor(stubClass, serviceType);
28:                     proxy = (T) constructor.newInstance(new Object[]{proxy});
29: 
30:                     // 【TODO 8033】参数回调
31:                     //export stub service
32:                     URL url = invoker.getUrl();
33:                     if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) {
34:                         url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), ","));
35:                         url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());
36:                         try {
37:                             export(proxy, (Class) invoker.getInterface(), url);
38:                         } catch (Exception e) {
39:                             LOGGER.error("export a stub service error.", e);
40:                         }
41:                     }
42:                 } catch (NoSuchMethodException e) {
43:                     throw new IllegalStateException("No such constructor \"public " + stubClass.getSimpleName() + "(" + serviceType.getName() + ")\" in stub implementation class " + stubClass.getName(), e);
44:                 }
45:             } catch (Throwable t) {
46:                 LOGGER.error("Failed to create stub implementation class " + stub + " in consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", cause: " + t.getMessage(), t);
47:                 // ignore
48:             }
49:         }
50:     }
51:     return proxy;
52: }
```

- 【**第一步**】第 5 行：调用 `proxyFactory#getProxy(invoker)` 方法，获得 Service Proxy 对象。这个过程，就是我们在 [《精尽 Dubbo 源码解析 —— 动态代理》](http://svip.iocoder.cn/Dubbo/proxy-local-stub/#) 前两篇看到的内容。
- 第 6 行：若是泛化引用，不支持使用本地存根。
- 第 8 至 18 行：获得 `stub` 配置项。**注意**，`local` 配置项，和 `stub` 配置项是**等价**的，目前使用 `stub` 而不使用 `local` 。
- 第 20 至 24 行：调用 `ReflectUtils#forName(stub)` 方法，加载 Stub 类。
- 【**第二步**】第 26 至 28 行：创建 Stub 对象，**使用带 Service Proxy 对象作为参数的构造方法**。例如，`public DemoServiceStub(DemoService demoService)` 。通过这样的方式，我们的 Stub 对象，就将 Proxy Service 对象，**包装在内部**，可以实现各种 OOXX 啦。
- 第 30 至 41 行：【TODO 8033】参数回调。先无视。
- 第 51 行：返回最终的 `proxy` 。

### 2.3 getInvoker

```
@Override
public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException {
    return proxyFactory.getInvoker(proxy, type, url);
}
```

- 服务实现的 Service ，不支持 Stub 存根。所以，虽然 `<dubbo:service />` 有 `stub` 配置项，但是实际是没有效果的。

## 3. 校验 Stub 配置

在 `#checkStubAndMock(interfaceClass)` 方法中，有校验 `stub` 配置项的代码，如下：

```
// `local` 配置项的校验，和 `stub` 一样。
if (ConfigUtils.isNotEmpty(local)) {
    Class<?> localClass = ConfigUtils.isDefault(local) ? ReflectUtils.forName(interfaceClass.getName() + "Local") : ReflectUtils.forName(local);
    if (!interfaceClass.isAssignableFrom(localClass)) {
        throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceClass.getName());
    }
    try {
        ReflectUtils.findConstructor(localClass, interfaceClass);
    } catch (NoSuchMethodException e) {
        throw new IllegalStateException("No such constructor \"public " + localClass.getSimpleName() + "(" + interfaceClass.getName() + ")\" in local implementation class " + localClass.getName());
    }
}
// `stub` 配置项的校验
if (ConfigUtils.isNotEmpty(stub)) {
    // `stub = true` 的情况，使用接口 + `Stub` 字符串。
    Class<?> localClass = ConfigUtils.isDefault(stub) ? ReflectUtils.forName(interfaceClass.getName() + "Stub") : ReflectUtils.forName(stub);
    // Stub 类，必须实现服务接口
    if (!interfaceClass.isAssignableFrom(localClass)) {
        throw new IllegalStateException("The local implementation class " + localClass.getName() + " not implement interface " + interfaceClass.getName());
    }
    // Stub 类，必须带有服务接口的构造方法
    try {
        ReflectUtils.findConstructor(localClass, interfaceClass);
    } catch (NoSuchMethodException e) {
        throw new IllegalStateException("No such constructor \"public " + localClass.getSimpleName() + "(" + interfaceClass.getName() + ")\" in local implementation class " + localClass.getName());
    }
}
```