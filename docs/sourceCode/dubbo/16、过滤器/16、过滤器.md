# 1、ClassLoaderFilter

## 1. 概述

从本文开始，我们来分享 Dubbo 的**过滤器**们。在 ProtocolFilterWrapper 中，在服务引用和暴露时，`#buildInvokerChain(invoker, key, group)` 方法中，基于 Dubbo SPI **Active** 机制，加载**匹配**对应的过滤器数组，创建带有**过滤器链的 Invoker 对象**。代码如下：

```
/**
 * 创建带 Filter 链的 Invoker 对象
 *
 * @param invoker Invoker 对象
 * @param key 获取 URL 参数名
 * @param group 分组
 * @param <T> 泛型
 * @return Invoker 对象
 */
private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {
    Invoker<T> last = invoker;
    // 获得过滤器数组
    List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);
    // 倒序循环 Filter ，创建带 Filter 链的 Invoker 对象
    if (!filters.isEmpty()) {
        for (int i = filters.size() - 1; i >= 0; i--) {
            final Filter filter = filters.get(i);
            final Invoker<T> next = last;
            last = new Invoker<T>() {

                @Override
                public Class<T> getInterface() {
                    return invoker.getInterface();
                }

                @Override
                public URL getUrl() {
                    return invoker.getUrl();
                }

                @Override
                public boolean isAvailable() {
                    return invoker.isAvailable();
                }

                @Override
                public Result invoke(Invocation invocation) throws RpcException {
                    return filter.invoke(next, invocation);
                }

                @Override
                public void destroy() {
                    invoker.destroy();
                }

                @Override
                public String toString() {
                    return invoker.toString();
                }
            };
        }
    }
    return last;
}
```

- 具体的过滤器链的执行过程，在前面的 Dubbo RPC 调用，已经分享，这里就不重复解释啦。

我们把服务提供者和消费者的过滤器统一整理如下：

[![过滤器整理](http://static.iocoder.cn/images/Dubbo/2018_11_12/01.png)](http://static.iocoder.cn/images/Dubbo/2018_11_12/01.png)过滤器整理

- **黄色**部分，代表过滤器在服务提供者和消费者上的顺序。若为空，则表示无该过滤器。

- 蓝色

  部分，EchoFilter 等等，已经在其他文章里分享。

  - `dubbo-filter-cache` 的 CacheFilter, `dubbo-filter-validation` 的 ValidationFilter ，未罗列在表格中，也会在其他文章里分享。

- **绿色**部分 ，CompatibleFilter 等等，目前未开启 Dubbo SPI `@Adaptive` 注解，我们就不写了。

本文分享 ClassLoaderFilter 。后续的文章，也会是每篇文章分享 1-2 个过滤器，根据实际用途的情况。

## 2. Filter

在 [《精尽 Dubbo 源码分析 —— 核心流程一览》「4.4 Filter」](http://svip.iocoder.cn/Dubbo/implementation-intro/?self) 中，已经详细分享。

## 3. ClassLoaderFilter

[`com.alibaba.dubbo.rpc.filter.ClassLoaderFilter`](https://github.com/YunaiV/dubbo/blob/master/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/filter/ClassLoaderFilter.java) ，实现 Filter 接口，类加载器切换过滤器实现类。代码如下：

```
 1: @Activate(group = Constants.PROVIDER, order = -30000)
 2: public class ClassLoaderFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 6:         // 获得原来的类加载器
 7:         ClassLoader ocl = Thread.currentThread().getContextClassLoader();
 8:         // 切换当前线程的类加载器为服务接口的类加载器
 9:         Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader());
10:         // 服务调用
11:         try {
12:             return invoker.invoke(invocation);
13:         } finally {
14:             // 切换当前线程的类加载器为原来的类加载器
15:             Thread.currentThread().setContextClassLoader(ocl);
16:         }
17:     }
18: 
19: }
```

- 第 7 行：调用 `Thread#getContextClassLoader()` 方法，获得**原来的**类加载器。
- 第 9 行：调用 `Thread#setContextClassLoader(ClassLoader)` 方法，**切换**当前线程的类加载器为**服务接口的**类加载器。
- 第 12 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。
- 第 15 行：调用 `Thread#setContextClassLoader(ClassLoader)` 方法，**切换**当前线程的类加载器为**原来的**类加载器。

笔者看到这个过滤器，表示一脸懵逼，于是开始 Google 探索之路。

1、于是搜到 [《ISSUE#1406：classloaderFilter》](https://github.com/apache/incubator-dubbo/issues/1406) ，内容如下：[![ISSUE#1406](http://static.iocoder.cn/images/Dubbo/2018_11_12/02.png)](http://static.iocoder.cn/images/Dubbo/2018_11_12/02.png)ISSUE#1406

使用我大有道词典翻译：

> 在设计目的中，切换到加载了接口定义的类加载器，以便实现与相同的类加载器上下文一起工作。

2、那么什么情况下会有多个 ClassLoader 的情况呢？再于是搜到 [《ISSUE#178：项目有多个ClassLoad时使用dubbo出错；》](https://github.com/apache/incubator-dubbo/issues/178) ，内容如下：[![ISSUE#178](http://static.iocoder.cn/images/Dubbo/2018_11_12/03.png)](http://static.iocoder.cn/images/Dubbo/2018_11_12/03.png)ISSUE#178

开始检索 **pf4j** 是什么东东？

> FROM [《Java 的插件框架 PF4J》](https://www.oschina.net/p/pf4j)
>
> PF4J 是一个 Java 的插件框架，为第三方提供应用扩展的渠道。使用 PF4J 你可以轻松将一个普通的 Java 应用转成一个模块化的应用。PF4J 本身非常轻量级，只有 50KB 左右，目前只依赖了 slf4j。[Gitblit](https://www.oschina.net/p/gitblit) 项目使用的就是 PF4J 进行插件管理。

🙂 看到此处，笔者已经进入了云里和雾里。所以，我仅仅是抛个砖，暂时还没去测试。再所以，胖友如果感兴趣，可以自己去研究下下。我的猜测是，使用 PF4J 加载不同的服务实现类的 Jar ，不同的 Jar 的类加载器不同。

有熟悉这块的胖友，如果有错误，请立即斧正我。哈哈哈。

# 2、ContextFilter

## 1. 概述

本文分享 RpcContext 相关过滤器，包括两个：

- ConsumerContextFilter ：在服务**消费者**中使用，负责**发起**调用时，初始化 RpcContext 。
- ContextFilter ：在服务**提供者**中使用，负责**被**调用时，初始化 RpcContext 。

## 2. RpcContext

RpcContext，上下文信息。在 [《Dubbo 用户指南 —— 上下文信息》](http://dubbo.apache.org/zh-cn/docs/user/demos/context.html) ，定义如下：

> 上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 [schema 配置参考手册](http://dubbo.apache.org/zh-cn/docs/user/references/xml/introduction.html) 中的对应URL参数一列。
>
> RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，
>
> - 在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，
> - 在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。

- RpcContext 在调用时的状态变化，有点绕，下面我们看具体的 Filter 实现，就相对容易明白列。

[`com.alibaba.dubbo.rpc.RpcContext`](http://svip.iocoder.cn/Dubbo/filter-context-filter/TODO) ，代码如下：

```
/**
 * RpcContext 线程变量
 */
private static final ThreadLocal<RpcContext> LOCAL = new ThreadLocal<RpcContext>() {

    @Override
    protected RpcContext initialValue() {
        return new RpcContext();
    }

};

/**
 * 隐式参数集合
 */
private final Map<String, String> attachments = new HashMap<String, String>();
// 实际未使用
private final Map<String, Object> values = new HashMap<String, Object>();
/**
 * 异步调用 Future
 */
private Future<?> future;
/**
 * 可调用服务的 URL 对象集合
 */
private List<URL> urls;
/**
 * 调用服务的 URL 对象
 */
private URL url;
/**
 * 方法名
 */
private String methodName;
/**
 * 参数类型数组
 */
private Class<?>[] parameterTypes;
/**
 * 参数值数组
 */
private Object[] arguments;
/**
 * 服务消费者地址
 */
private InetSocketAddress localAddress;
/**
 * 服务提供者地址
 */
private InetSocketAddress remoteAddress;

@Deprecated // DUBBO-325 废弃的，使用 urls 属性替代
private List<Invoker<?>> invokers;
@Deprecated // DUBBO-325 废弃的，使用 url 属性替代
private Invoker<?> invoker;
@Deprecated // DUBBO-325 废弃的，使用 methodName、parameterTypes、arguments 属性替代
private Invocation invocation;

/**
 * 请求
 *
 * 例如，在 RestProtocol
 */
private Object request;
/**
 * 响应
 *
 * 例如，在 RestProtocol
 */
private Object response;
 
 // ... 省略一些
```

- `LOCAL` **静态**属性，RpcContext 线程变量。初始获得时，返回新的 RpcContext 对象。

- ```
  attachments
  ```

   

  属性，隐式参数集合。

  - 例如，我们在 PRC 调用前，可在业务代码里添加一些想要传递给服务的参数到该属性
  - 又例如，在分布式链路追踪时，添加链路追踪**编号**到该属性种。
  - [《Dubbo 用户指南 —— 隐式参数》](http://dubbo.apache.org/zh-cn/docs/user/demos/attachment.html)

- `future` 属性，异步调用 Future 对象，在 [《精尽 Dubbo 源码分析 —— 服务调用（三）之远程调用（Dubbo）【3】异步调用》](http://svip.iocoder.cn/Dubbo/rpc-dubbo-3-async/?self) 有详细使用的代码分享。

- 【替代

   

  ```
  invokers
  ```

   

  属性】

  - `urls` 属性，**可调用**的服务的 URL 对象集合，在集群容错模块实现。

- 【替代

   

  ```
  invoker
  ```

   

  属性】

  - `url` 属性，**调用**的服务的 URL 对象。

- 【替代

   

  ```
  invocation
  ```

   

  属性】

  - `methodName` 属性，**调用**的方法名。
  - `parameterTypes` 属性，**调用**的参数类型数组。
  - `arguments` 属性，**调用**的参数值数组。

- 地址

  - `localAddress` 属性， 服务消费者地址。
  - `remoteAddress` 属性，服务提供者地址。

- ```
  request
  ```

   

  ```
  response
  ```

   

  属性，请求和响应。例如，在 RestProtocol 中使用，代表 HTTP Request 和 Response 对象，在 RpcContextFilter 中设置，如下图所示：

  ![RpcContextFilter](http://static.iocoder.cn/images/Dubbo/2018_11_13/01.png)

  RpcContextFilter

  - 我们可以看到 `request` `response` 的类型是 Object 类。通过这种形式，可以不仅仅适用于 HTTP 的场景。

RpcContext 中，有很多方法，比较易懂，胖友自己查看噢。

## 3. ConsumerContextFilter

`com.alibaba.dubbo.rpc.filter.ConsumerContextFilter` ，实现 Filter 接口，**服务消费者**的 ContextFilter 实现类。

```
 1: @Activate(group = Constants.CONSUMER, order = -10000)
 2: public class ConsumerContextFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 6:         // 设置 RpcContext 对象
 7:         RpcContext.getContext()
 8:                 .setInvoker(invoker)
 9:                 .setInvocation(invocation)
10:                 .setLocalAddress(NetUtils.getLocalHost(), 0) // 本地地址
11:                 .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); // 远程地址
12:         // 设置 RpcInvocation 对象的 `invoker` 属性
13:         if (invocation instanceof RpcInvocation) {
14:             ((RpcInvocation) invocation).setInvoker(invoker);
15:         }
16:         // 服务调用
17:         try {
18:             return invoker.invoke(invocation);
19:         } finally {
20:             // 清理隐式参数集合
21:             RpcContext.getContext().clearAttachments();
22:         }
23:     }
24: 
25: }
```

- 第 6 至 11 行：设置 RpcContext 对象。

- 第 12 至 15 行：设置 RpcInvocation 对象的 `invoker` 属性。该属性，目前使用在如下图的场景：[![RpcInvocation](http://static.iocoder.cn/images/Dubbo/2018_11_13/02.png)](http://static.iocoder.cn/images/Dubbo/2018_11_13/02.png)RpcInvocation

- 第 18 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

- 第 19 至 22 行：调用 `RpcContext#clearAttachments()` 方法，清理隐式参数集合。所以，**每次**（注意，每次！！！）服务调用完成，RpcContext 设置的隐式参数**都会被清理**！代码如下：

  ```
  public void clearAttachments() {
      this.attachments.clear();
  }
  ```

😈 看到此处，`RpcContext.attachments` 属性，是如何传递给被调用的服务的呢？答案在下图：[![透传](http://static.iocoder.cn/images/Dubbo/2018_11_13/03.png)](http://static.iocoder.cn/images/Dubbo/2018_11_13/03.png)透传

## 4. ContextFilter

`com.alibaba.dubbo.rpc.filter.ContextFilter` ，实现 Filter 接口，**服务提供者**的 ContextFilter 实现类。

```
 1: @Activate(group = Constants.PROVIDER, order = -10000)
 2: public class ContextFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 6:         // 创建新的 `attachments` 集合，清理公用的隐式参数
 7:         Map<String, String> attachments = invocation.getAttachments();
 8:         if (attachments != null) {
 9:             attachments = new HashMap<String, String>(attachments);
10:             attachments.remove(Constants.PATH_KEY);
11:             attachments.remove(Constants.GROUP_KEY);
12:             attachments.remove(Constants.VERSION_KEY);
13:             attachments.remove(Constants.DUBBO_VERSION_KEY);
14:             attachments.remove(Constants.TOKEN_KEY);
15:             attachments.remove(Constants.TIMEOUT_KEY);
16:             attachments.remove(Constants.ASYNC_KEY); // Remove async property to avoid being passed to the following invoke chain.
17:                                                      // 清空消费端的异步参数
18:         }
19:         // 设置 RpcContext 对象
20:         RpcContext.getContext()
21:                 .setInvoker(invoker)
22:                 .setInvocation(invocation)
23: //                .setAttachments(attachments)  // merged from dubbox
24:                 .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort());
25:         // mreged from dubbox
26:         // we may already added some attachments into RpcContext before this filter (e.g. in rest protocol)
27:         // 在此过滤器(例如rest协议)之前，我们可能已经在RpcContext中添加了一些附件。
28:         if (attachments != null) {
29:             if (RpcContext.getContext().getAttachments() != null) {
30:                 RpcContext.getContext().getAttachments().putAll(attachments);
31:             } else {
32:                 RpcContext.getContext().setAttachments(attachments);
33:             }
34:         }
35:         // 设置 RpcInvocation 对象的 `invoker` 属性
36:         if (invocation instanceof RpcInvocation) {
37:             ((RpcInvocation) invocation).setInvoker(invoker);
38:         }
39:         // 服务调用
40:         try {
41:             return invoker.invoke(invocation);
42:         } finally {
43:             // 移除上下文
44:             RpcContext.removeContext();
45:         }
46:     }
47: 
48: }
```

- 第 6 至 18 行：创建新的 `attachments` 集合，因为要清理**公用**的隐式参数。该**公用**的隐式参数，设置的地方，如下图所示：[![RpcInvocation](http://static.iocoder.cn/images/Dubbo/2018_11_13/04.png)](http://static.iocoder.cn/images/Dubbo/2018_11_13/04.png)RpcInvocation

- 第 19 至 24 行：设置 RpcContext 对象。

- 第 25 至 34 行：在此过滤器( 例如 RestProtocol 的 RpcContextFilter )之前，我们可能已经在 RpcContext 中添加了一些隐式参数。

- 第 35 至 38 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

- 第 41 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

- 第 42 至 45 行：调用 `RpcContext#removeContext()` 方法，移除上下文。代码如下：

  ```
  public static void removeContext() {
      LOCAL.remove();
  }
  ```

## 5. RpcContext.values

我们在回过头来看 `RpcContext.values` 属性。目前 Dubbo 中，**并未使用它**。

从代码看下来，如果我们希望有**多次** Dubbo 调用，共享参数，并且不被 ConsumerContextFilter 清理隐式参数，笔者觉得可以使用该 `values` 属性。

和 `value` 属性相关的方法如下：

```
public Map<String, Object> get() {
    return values;
}

public RpcContext set(String key, Object value) {
    if (value == null) {
        values.remove(key);
    } else {
        values.put(key, value);
    }
    return this;
}   

public RpcContext remove(String key) {
    values.remove(key);
    return this;
} 

public Object get(String key) {
    return values.get(key);
}
```

当然，如果同时我们希望一些**通用**的 `values` 传递给被调用的服务，可以实现一个 Filter ，简化代码如下：

```
RpcContext.getContext().setAttachment("key1", RpcContext.getContext().get("key2").toString());
```

恩，还是当然，在业务代码里，也可以这么调用。🙂

# 3、AccessLogFilter

## 1. 概述

本文分享记录**访问日志**的过滤器 AccessLogFilter ，需要在 `<dubbo:protocol />` 或 `<dubbo:provider />` 或 `<dubbo:service />` 中，设置 `"accesslog"` 配置项**开启**。有两种配置项选择：

- 【配置方式一】 `true` ：将向日志组件 logger 中输出访问日志。
- 【配置方式二】访问日志文件路径：直接把访问日志输出到**指定**文件。

## 2. AccessLogFilter

`com.alibaba.dubbo.rpc.filter.AccessLogFilter` ，实现 Filter 接口，记录**服务**的访问日志的过滤器实现类。

#### 2.1 构造方法

```
/**
 * 访问日志在 {@link LoggerFactory} 中的日志名
 */
private static final String ACCESS_LOG_KEY = "dubbo.accesslog";

/**
 * 访问日志的文件后缀
 */
private static final String FILE_DATE_FORMAT = "yyyyMMdd";
/**
 * 日历的时间格式化
 */
private static final String MESSAGE_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
/**
 * 队列大小，即 {@link #logQueue} 值的大小
 */
private static final int LOG_MAX_BUFFER = 5000;
/**
 * 日志输出频率，单位：毫秒。仅适用于 {@link #logFuture}
 */
private static final long LOG_OUTPUT_INTERVAL = 5000;

/**
 * 日志队列
 *
 * key：访问日志名
 * value：日志集合
 */
private final ConcurrentMap<String, Set<String>> logQueue = new ConcurrentHashMap<String, Set<String>>();
/**
 * 定时任务线程池
 */
private final ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(2, new NamedThreadFactory("Dubbo-Access-Log", true));
/**
 * 记录日志任务
 */
private volatile ScheduledFuture<?> logFuture = null;
```

- 【配置方式一】
  - `ACCESS_LOG_KEY`
- 【配置方式二】
  - 文件相关：
    - `FILE_DATE_FORMAT`
    - `MESSAGE_DATE_FORMAT`
  - 队列相关：
    - `logQueue`
    - `LOG_MAX_BUFFER`
  - 任务相关：
    - `logScheduled`
    - `LOG_OUTPUT_INTERVAL`
    - `logFuture`
  - 日志流向为：**logMessage** => 队列 => 任务 => 文件。

#### 2.2 invoke

```
 1: @Override
 2: @SuppressWarnings("Duplicates")
 3: public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
 4:     try {
 5:         // 记录访问日志的文件名
 6:         String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
 7:         if (ConfigUtils.isNotEmpty(accesslog)) {
 8:             // 服务的名字、版本、分组信息
 9:             RpcContext context = RpcContext.getContext();
10:             String serviceName = invoker.getInterface().getName();
11:             String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);
12:             String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);
13:             // 拼接日志内容
14:             StringBuilder sn = new StringBuilder();
15:             sn.append("[").append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append("] ") // 时间
16:                     .append(context.getRemoteHost()).append(":").append(context.getRemotePort()) // 调用方地址
17:                     .append(" -> ").append(context.getLocalHost()).append(":").append(context.getLocalPort()) // 本地地址
18:                     .append(" - ");
19:             if (null != group && group.length() > 0) { // 分组
20:                 sn.append(group).append("/");
21:             }
22:             sn.append(serviceName); // 服务名
23:             if (null != version && version.length() > 0) { // 版本
24:                 sn.append(":").append(version);
25:             }
26:             sn.append(" ");
27:             sn.append(inv.getMethodName()); // 方法名
28:             sn.append("(");
29:             Class<?>[] types = inv.getParameterTypes(); // 参数类型
30:             if (types != null && types.length > 0) {
31:                 boolean first = true;
32:                 for (Class<?> type : types) {
33:                     if (first) {
34:                         first = false;
35:                     } else {
36:                         sn.append(",");
37:                     }
38:                     sn.append(type.getName());
39:                 }
40:             }
41:             sn.append(") ");
42:             Object[] args = inv.getArguments(); // 参数值
43:             if (args != null && args.length > 0) {
44:                 sn.append(JSON.toJSONString(args));
45:             }
46:             String msg = sn.toString();
47:             // 【方式一】使用日志组件，例如 Log4j 等写
48:             if (ConfigUtils.isDefault(accesslog)) {
49:                 LoggerFactory.getLogger(ACCESS_LOG_KEY + "." + invoker.getInterface().getName()).info(msg);
50:             // 【方式二】异步输出到指定文件
51:             } else {
52:                 log(accesslog, msg);
53:             }
54:         }
55:     } catch (Throwable t) {
56:         logger.warn("Exception in AcessLogFilter of service(" + invoker + " -> " + inv + ")", t);
57:     }
58:     // 服务调用
59:     return invoker.invoke(inv);
60: }
```

- 第 6 行：获得访问日志的**配置项**。

- 第 8 至 12 行：获得服务的名字、版本、分组信息。

- 第 13 至 46 行：拼接日志的内容。例子如下：

  ```
  [2018-04-14 11:57:58] 192.168.3.17:57207 -> 192.168.3.17:20880 - com.alibaba.dubbo.demo.DemoService say01(java.lang.String) [null]
  ```

- 第 47 至 49 行：调用 `ConfigUtils#isDefault(value)` 方法，判断是否使用日志组件记录日志。例如 Log4J 等等。详细参见 [《Dubbo 用户指南 —— 日志适配》](http://dubbo.apache.org/zh-cn/docs/user/demos/logger-strategy.html) 。

- 第 50 至 53 行：调用 `#log(accesslog, logMessage)` 方法，添加日志内容到日志队列。代码如下：

  ```
  /**
   * 初始化任务
   */
  private void init() {
      if (logFuture == null) {
          synchronized (logScheduled) {
              if (logFuture == null) { // 双重锁，避免重复初始化
                  logFuture = logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
              }
          }
      }
  }
  
  /**
   * 添加日志内容到日志队列
   *
   * @param accesslog 日志文件
   * @param logmessage 日志内容
   */
  private void log(String accesslog, String logmessage) {
      // 初始化
      init();
      // 获得队列，以文件名为 Key
      Set<String> logSet = logQueue.get(accesslog);
      if (logSet == null) {
          logQueue.putIfAbsent(accesslog, new ConcurrentHashSet<String>());
          logSet = logQueue.get(accesslog);
      }
      // 若未超过队列大小，添加到队列中
      if (logSet.size() < LOG_MAX_BUFFER) {
          logSet.add(logmessage);
      }
  }
  ```

#### 2.3 LogTask

> LogTask 是 AccessLogFilter 的内部类

```
 1: /**
 2:  * 日志任务
 3:  */
 4: private class LogTask implements Runnable {
 5: 
 6:     @Override
 7:     public void run() {
 8:         try {
 9:             if (logQueue.size() > 0) {
10:                 for (Map.Entry<String, Set<String>> entry : logQueue.entrySet()) {
11:                     try {
12:                         String accesslog = entry.getKey();
13:                         Set<String> logSet = entry.getValue();
14:                         // 获得日志文件
15:                         File file = new File(accesslog);
16:                         File dir = file.getParentFile();
17:                         if (null != dir && !dir.exists()) {
18:                             dir.mkdirs();
19:                         }
20:                         if (logger.isDebugEnabled()) {
21:                             logger.debug("Append log to " + accesslog);
22:                         }
23:                         // 归档历史日志文件，例如： `accesslog` => `access.20181023`
24:                         if (file.exists()) {
25:                             String now = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());
26:                             String last = new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified())); // 最后修改时间
27:                             if (!now.equals(last)) {
28:                                 File archive = new File(file.getAbsolutePath() + "." + last);
29:                                 file.renameTo(archive);
30:                             }
31:                         }
32:                         // 输出日志到指定文件
33:                         FileWriter writer = new FileWriter(file, true);
34:                         try {
35:                             for (Iterator<String> iterator = logSet.iterator(); iterator.hasNext(); iterator.remove()) {
36:                                 writer.write(iterator.next()); // 写入一行日志
37:                                 writer.write("\r\n"); // 换行
38:                             }
39:                             writer.flush(); // 刷盘
40:                         } finally {
41:                             writer.close(); // 关闭
42:                         }
43:                     } catch (Exception e) {
44:                         logger.error(e.getMessage(), e);
45:                     }
46:                 }
47:             }
48:         } catch (Exception e) {
49:             logger.error(e.getMessage(), e);
50:         }
51:     }
52: 
53: }
```

- 从 `#init()` 方法，我们可以看到，LogTask 每 5000 ( `LOG_OUTPUT_INTERVAL` ) 毫秒，执行一次。

- 第 9 至 10 行：循环日志队列 `logQueue` 。**注意**，日志集合使用了 ConcurrentHashSet ，所以会有一定的**乱序**，在最终输出到指定文件后。

- 第 14 至 22 行：获得日志文件。

- 第 23 至 31 行：归档历史日志文件，例如：

  ```
  accesslog
  ```

   

  =>

   

  ```
  access.20181023
  ```

   

  。

  - **注意**，因为是按照**文件最后修改时间**，所以极端情况（写着写着到了**第二天**），那么就不会归档了。

- 第 32 至 42 行：输出日志到指定文件。

# 4、ActiveLimitFilter && ExecuteLimitFilter

## 1. 概述

本文分享**服务方法**的**最大可并行调用**的**限制**过滤器，在服务**消费者**和**提供者**各有一个 LimitFilter ：

- ActiveLimitFilter ，在服务**消费者**，通过 `<dubbo:reference />` 的 `"actives"` **统一**配置项开启：

  > 每服务消费者，**每服务**的**每方法**最大并发调用数。

- ExecuteLimitFilter ，在服务**提供者**，通过 `<dubbo:service />` 的 `"executes"` **统一**配置项开启：

  > 服务提供者，**每服务**的**每方法**最大可并行执行请求数。

另外，在 `<dubbo:method />` 的 `"actives"` 和 `"executes"` 配置项，可以**自定义**每个方法的配置。

## 2. RpcStatus

`com.alibaba.dubbo.rpc.RpcStatus` ，RPC 状态。可以计入如下维度统计：

- 1. 基于服务 URL
- 1. 基于服务 URL + 方法

用于 ActiveLimitFilter 和 ExecuteLimitFilter 中。🙂 当然，Dubbo 中，也有其他类，也会调用到 RpcStatus 。

#### 2.1 构造方法

```
/**
 * 基于服务 URL 为维度的 RpcStatus 集合
 *
 * key：URL
 */
private static final ConcurrentMap<String, RpcStatus> SERVICE_STATISTICS = new ConcurrentHashMap<String, RpcStatus>();
/**
 * 基于服务 URL + 方法维度的 RpcStatus 集合
 *
 * key1：URL
 * key2：方法名
 */
private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS = new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>();

// 目前没有用到
private final ConcurrentMap<String, Object> values = new ConcurrentHashMap<String, Object>();
/**
 * 调用中的次数
 */
private final AtomicInteger active = new AtomicInteger();
/**
 * 总调用次数
 */
private final AtomicLong total = new AtomicLong();
/**
 * 总调用失败次数
 */
private final AtomicInteger failed = new AtomicInteger();
/**
 * 总调用时长，单位：毫秒
 */
private final AtomicLong totalElapsed = new AtomicLong();
/**
 * 总调用失败时长，单位：毫秒
 */
private final AtomicLong failedElapsed = new AtomicLong();
/**
 * 最大调用时长，单位：毫秒
 */
private final AtomicLong maxElapsed = new AtomicLong();
/**
 * 最大调用失败时长，单位：毫秒
 */
private final AtomicLong failedMaxElapsed = new AtomicLong();
/**
 * 最大调用成功时长，单位：毫秒
 */
private final AtomicLong succeededMaxElapsed = new AtomicLong();

/**
 * Semaphore used to control concurrency limit set by `executes`
 *
 * 服务执行信号量，在 {@link com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter} 中使用
 */
private volatile Semaphore executesLimit;
/**
 * 服务执行信号量大小
 */
private volatile int executesPermits;
```

- ========== 静态属性 ==========

- `SERVICE_STATISTICS` 属性，基于**服务 URL** 为维度的 **RpcStatus** 集合。`#getStatus(url)` **静态**方法，获得 RpcStatus 对象，代码如下：

  ```
  public static RpcStatus getStatus(URL url) {
      String uri = url.toIdentityString();
      // 获得
      RpcStatus status = SERVICE_STATISTICS.get(uri);
      // 不存在，则进行创建
      if (status == null) {
          SERVICE_STATISTICS.putIfAbsent(uri, new RpcStatus());
          status = SERVICE_STATISTICS.get(uri);
      }
      return status;
  }
  ```

- `METHOD_STATISTICS` 属性，基于**服务 URL** + **方法**为维度的 **RpcStatus** 集合。`#getStatus(url, methodName)` **静态**方法，获得 RpcStatus 对象，代码如下：

  ```
  public static RpcStatus getStatus(URL url, String methodName) {
      String uri = url.toIdentityString();
      // 获得方法集合
      ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.get(uri);
      // 不存在，创建方法集合
      if (map == null) {
          METHOD_STATISTICS.putIfAbsent(uri, new ConcurrentHashMap<String, RpcStatus>());
          map = METHOD_STATISTICS.get(uri);
      }
  
      // 获得 RpcStatus 对象
      RpcStatus status = map.get(methodName);
      // 不存在，创建 RpcStatus 对象
      if (status == null) {
          map.putIfAbsent(methodName, new RpcStatus());
          status = map.get(methodName);
      }
      return status;
  }
  ```

- ========== 对象属性 ==========

- 次数相关

  - `active` ，**调用中**的次数。这个属性在 ActiveLimitFilter 中**非常关键**。
  - `total` `failed`

- 时长相关

  - `totalElapsed` `failedElapsed`
  - `failedElapsed` `failedMaxElapsed` `succeededMaxElapsed`

- 信号量相关

  - `executesLimit` ，服务执行信号量。这个属性在 ExecuteLimitFilter 中**非常关键**。
  - `executesPermits` ，服务执行信号量大小。

#### 2.2 beginCount

```
/**
 * 服务调用开始的计数
 *
 * @param url URL 对象
 * @param methodName 方法名
 */
public static void beginCount(URL url, String methodName) {
    // `SERVICE_STATISTICS` 的计数
    beginCount(getStatus(url));
    // `METHOD_STATISTICS` 的计数
    beginCount(getStatus(url, methodName));
}
```

- **静态方法**，在其内部，会调用两次 `#beginCount(RpcStatus)` 方法，分别计数。代码如下：

  ```
  private static void beginCount(RpcStatus status) {
      // 调用中的次数
      status.active.incrementAndGet();
  }
  ```

#### 2.3 endCount

```
/**
 * 服务调用结束的计数
 *
 * @param url URL 对象
 * @param elapsed 时长，毫秒
 * @param succeeded 是否成功
 */
public static void endCount(URL url, String methodName, long elapsed, boolean succeeded) {
    // `SERVICE_STATISTICS` 的计数
    endCount(getStatus(url), elapsed, succeeded);
    // `METHOD_STATISTICS` 的计数
    endCount(getStatus(url, methodName), elapsed, succeeded);
}
```

- **静态方法**，在其内部，会调用两次 `#endCount(RpcStatus)` 方法，分别计数。代码如下：

  ```
  private static void endCount(RpcStatus status, long elapsed, boolean succeeded) {
      // 次数计数
      status.active.decrementAndGet();
      status.total.incrementAndGet();
      status.totalElapsed.addAndGet(elapsed);
      // 时长计数
      if (status.maxElapsed.get() < elapsed) {
          status.maxElapsed.set(elapsed);
      }
      if (succeeded) {
          if (status.succeededMaxElapsed.get() < elapsed) {
              status.succeededMaxElapsed.set(elapsed);
          }
      } else {
          status.failed.incrementAndGet(); // 失败次数
          status.failedElapsed.addAndGet(elapsed);
          if (status.failedMaxElapsed.get() < elapsed) {
              status.failedMaxElapsed.set(elapsed);
          }
      }
  }
  ```

#### 2.4 getSemaphore

```
public Semaphore getSemaphore(int maxThreadNum) {
    if(maxThreadNum <= 0) {
        return null;
    }
    // 若信号量不存在，或者信号量大小改变，创建新的信号量
    if (executesLimit == null || executesPermits != maxThreadNum) {
        synchronized (this) {
            if (executesLimit == null || executesPermits != maxThreadNum) {
                executesLimit = new Semaphore(maxThreadNum);
                executesPermits = maxThreadNum;
            }
        }
    }
    // 返回信号量
    return executesLimit;
}
```

- **对象**方法，获得信号量 `executesPermits` 属性。
- 创建信号量的**条件**，信号量 `executesPermits` 不存在，或者信号量大小 `executesLimit` 发生改变。我们会发生比较“神奇”的是，这个方法是**直接**返回 Semaphore 对象。考虑到有信号量大小改变的需求，但是信号量不支持**批量**修改大小，那么剩余的一种合适的方式，创建**新的**信号量对象。因此，这个方法就选择了直接返回 Semaphore 对象。
- 在 [《Dubbo源代码分析七：使用executes属性的一个问题》](http://manzhizhen.iteye.com/blog/2386408) 中，分享的很不错。

## 3. ActiveLimitFilter

`com.alibaba.dubbo.rpc.filter.ActiveLimitFilter` ，实现 Filter 接口，每服务消费者**每服务**、**每方法**的**最大可并行**调用数限制的过滤器实现类。

```
 1: @Activate(group = Constants.CONSUMER, value = Constants.ACTIVES_KEY)
 2: public class ActiveLimitFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 6:         URL url = invoker.getUrl();
 7:         String methodName = invocation.getMethodName();
 8:         // 获得服务提供者每服务每方法最大可并行执行请求数
 9:         int max = invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0);
10:         // 获得 RpcStatus 对象，基于服务 URL + 方法维度
11:         RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());
12:         if (max > 0) {
13:             // 获得超时值
14:             long timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, 0);
15:             long start = System.currentTimeMillis();
16:             long remain = timeout; // 剩余可等待时间
17:             int active = count.getActive();
18:             // 超过最大可并行执行请求数，等待
19:             if (active >= max) {
20:                 synchronized (count) { // 通过锁，有且仅有一个在等待。
21:                     // 循环，等待可并行执行请求数
22:                     while ((active = count.getActive()) >= max) {
23:                         // 等待，直到超时，或者被唤醒
24:                         try {
25:                             count.wait(remain);
26:                         } catch (InterruptedException e) {
27:                         }
28:                         // 判断是否没有剩余时长了，抛出 RpcException 异常
29:                         long elapsed = System.currentTimeMillis() - start; // 本地等待时长
30:                         remain = timeout - elapsed;
31:                         if (remain <= 0) {
32:                             throw new RpcException("Waiting concurrent invoke timeout in client-side for service:  "
33:                                     + invoker.getInterface().getName() + ", method: "
34:                                     + invocation.getMethodName() + ", elapsed: " + elapsed
35:                                     + ", timeout: " + timeout + ". concurrent invokes: " + active
36:                                     + ". max concurrent invoke limit: " + max);
37:                         }
38:                     }
39:                 }
40:             }
41:         }
42:         try {
43:             long begin = System.currentTimeMillis();
44:             // 调用开始的计数
45:             RpcStatus.beginCount(url, methodName);
46:             try {
47:                 // 服务调用
48:                 Result result = invoker.invoke(invocation);
49:                 // 调用结束的计数（成功）
50:                 RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);
51:                 return result;
52:             } catch (RuntimeException t) {
53:                 // 调用结束的计数（失败）
54:                 RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);
55:                 throw t;
56:             }
57:         } finally {
58:             // 唤醒等待的相同服务的相同方法的请求
59:             if (max > 0) {
60:                 synchronized (count) {
61:                     count.notify();
62:                 }
63:             }
64:         }
65:     }
66: 
67: }
```

- ActiveLimitFilter 基于 `RpcStatus.active` 属性，判断当前**正在调用中**的服务的方法的次数来判断。因为，需要有**等待超时**的特性，所以不使用 `RpcStatus.semaphore` **信号量**的方式来实现。
- 第 9 行：调用 `URL#getMethodParameter(methodName, key, defaultValue)` 方法，获得服务提供者每服务每方法最大可并行执行请求数。优先 `<dubbo: method />` ，其次 `<dubbo:reference />` 。
- 第 11 行：调用 `RpcStatus#getStatus(url, methodName)` 方法，获得 RpcStatus 对象，基于**服务 URL + 方法**为维度。
- 第 14 行：获得**超时值**。这里有一点需要注意，此处产生的**等待**时长，**不**占用调用服务的**超时**时长。所以，**极端情况**下的服务超时，约等于 2 * `timeout` 。
- 第 19 行：超过最大可并行执行请求数，**需要等待**。
- 第 20 行：通过**锁定** `synchronized` ，**有且仅有**一个在等待。同时，也保证先调用的可以先执行。
- 第 22 行：**循环**，等待可并行执行请求数。为什么需要循环呢？极端情况下，恰好有一个**新的**调用，在【第 61 行】执行的一瞬间，走到了【第 19 行】，“**抢**”走了正在锁定等待的请求机会。
- 第 23 至 27 行：等待，直到超时，或者被唤醒【第 61 行】。
- 第 28 至 37 行：判断若没有剩余时长了，抛出 RpcException 异常。
- 第 45 行：调用 `RpcStaus#beginCount(url, methodName)` 方法，调用开始的计数。
- 第 48 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。
- 第 50 行：调用 `RpcStaus#endCount(url, methodName, true)` 方法，调用开始的计数（成功）。
- 第 54 行：调用 `RpcStaus#endCount(url, methodName, false)` 方法，调用开始的计数（失败）。
- 第 59 至 63 行：唤醒等待的相同服务的相同方法的请求【第 25 行】。

## 4. ExecuteLimitFilter

`com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter` ，实现 Filter 接口，服务提供者**每服务**、**每方法**的**最大可并行**执行请求数的过滤器实现类。

```
 1: @Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY)
 2: public class ExecuteLimitFilter implements Filter {
 3: 
 4:     @Override
 5:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 6:         URL url = invoker.getUrl();
 7:         String methodName = invocation.getMethodName();
 8:         Semaphore executesLimit = null; // 信号量
 9:         boolean acquireResult = false; // 是否获得信号量
10:         // 获得服务提供者每服务每方法最大可并行执行请求数
11:         int max = url.getMethodParameter(methodName, Constants.EXECUTES_KEY, 0);
12:         if (max > 0) {
13:             // 获得 RpcStatus 对象，基于服务 URL + 方法维度
14:             RpcStatus count = RpcStatus.getStatus(url, invocation.getMethodName());
15:             // 获得信号量。若获得不到，抛出异常。
16: //            if (count.getActive() >= max) {
17:             /**
18:              * http://manzhizhen.iteye.com/blog/2386408
19:              * use semaphore for concurrency control (to limit thread number)
20:              */
21:             executesLimit = count.getSemaphore(max);
22:             if (executesLimit != null && !(acquireResult = executesLimit.tryAcquire())) {
23:                 throw new RpcException("Failed to invoke method " + invocation.getMethodName() + " in provider " + url + ", cause: The service using threads greater than <dubbo:service executes=\"" + max + "\" /> limited.");
24:             }
25:         }
26:         long begin = System.currentTimeMillis();
27:         boolean isSuccess = true;
28:         // 调用开始的计数
29:         RpcStatus.beginCount(url, methodName);
30:         try {
31:             // 服务调用
32:             return invoker.invoke(invocation);
33:         } catch (Throwable t) {
34:             isSuccess = false; // 标记失败
35:             if (t instanceof RuntimeException) {
36:                 throw (RuntimeException) t;
37:             } else {
38:                 throw new RpcException("unexpected exception when ExecuteLimitFilter", t);
39:             }
40:         } finally {
41:             // 调用结束的计数（成功）（失败）
42:             RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess);
43:             // 释放信号量
44:             if (acquireResult) {
45:                 executesLimit.release();
46:             }
47:         }
48:     }
49: 
50: }
```

- ActiveLimitFilter 基于 `RpcStatus.semaphore` **信号量**属性，判断若超过最大可并行，抛出 RpcException 异常。
- 第 11 行：调用 `URL#getMethodParameter(methodName, key, defaultValue)` 方法，获得服务提供者每服务每方法最大可并行执行请求数。优先 `<dubbo: method />` ，其次 `<dubbo:service />` 。
- 第 13 行：调用 `RpcStatus#getStatus(url, methodName)` 方法，获得 RpcStatus 对象，基于**服务 URL + 方法**为维度。
- 第 21 至 21 行：调用 `RpcStatus#getSemaphore(max)` 方法，获得 Semaphore 对象。
- 第 22 至 24 行：调用 `Semaphore#tryAcquire()` 方法，若获得不到信号量，抛出 RpcException 异常。
- 第 29 行：调用 `RpcStaus#beginCount(url, methodName)` 方法，调用开始的计数。
- 第 32 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。
- 第 34 行：若发生异常，标记 `isSuccess = false` ，表示调用失败。
- 第 42 行：调用 `RpcStaus#endCount(url, methodName, success)` 方法，调用开始的计数（成功）（失败）。
- 第 43 至 46 行：调用 `Semaphore#release()` 方法，释放信号量。

# 5、TimeoutFilter

## 1. 概述

本文分享过滤器 TimeoutFilter ，用于服务**提供者**中。

## 2. TimeoutFilter

`com.alibaba.dubbo.rpc.filter.TimeoutFilter` ，实现 Filter 接口，超时过滤器。如果服务调用**超时**，记录**告警**日志，**不干涉**服务的运行。代码如下：

```
 1: @Activate(group = Constants.PROVIDER)
 2: public class TimeoutFilter implements Filter {
 3: 
 4:     private static final Logger logger = LoggerFactory.getLogger(TimeoutFilter.class);
 5: 
 6:     @Override
 7:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 8:         long start = System.currentTimeMillis();
 9:         // 服务调用
10:         Result result = invoker.invoke(invocation);
11:         // 计算调用时长
12:         long elapsed = System.currentTimeMillis() - start;
13:         // 超过时长，打印告警日志
14:         if (invoker.getUrl() != null
15:                 && elapsed > invoker.getUrl().getMethodParameter(invocation.getMethodName(), "timeout", Integer.MAX_VALUE)) {
16:             if (logger.isWarnEnabled()) {
17:                 logger.warn("invoke time out. method: " + invocation.getMethodName()
18:                         + " arguments: " + Arrays.toString(invocation.getArguments()) + " , url is "
19:                         + invoker.getUrl() + ", invoke elapsed " + elapsed + " ms.");
20:             }
21:         }
22:         return result;
23:     }
24: 
25: }
```

- 第 10 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。
- 第 12 行：计算调用时长。
- 第 13 至 21 行：超过时长，打印**告警**日志。注意，此处的 `"timeout"` 取得的是服务**提供者**的配置，不同于服务**消费者**的配置。
- 第 22 行：返回调用结果。
- 🙂 再注意，在服务**提供者**，执行服务调用时，即使**超过了超时时间**，也不会取消执行。虽然，服务**消费者**，已经结束调用，返回调用超时。

# 6、DeprecatedFilter

## 1. 概述

本文分享过滤器 DeprecatedFilter ，用于服务**消费者**中，通过 `<dubbo: service />` 或 `<dubbo:reference />` 或 `<dubbo:method />` 的 `"deprecated"` 配置项为 `true` 来开启。

## 2. DeprecatedFilter

`com.alibaba.dubbo.rpc.filter.DeprecatedFilter` ，实现 Filter 接口，废弃调用的过滤器实现类。当调用废弃的服务方法时，打印错误日志提醒。代码如下：

```
 1: @Activate(group = Constants.CONSUMER, value = Constants.DEPRECATED_KEY)
 2: public class DeprecatedFilter implements Filter {
 3: 
 4:     private static final Logger LOGGER = LoggerFactory.getLogger(DeprecatedFilter.class);
 5: 
 6:     /**
 7:      * 已经打印日志的方法集合
 8:      */
 9:     private static final Set<String> logged = new ConcurrentHashSet<String>();
10: 
11:     @Override
12:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
13:         // 获得方法名
14:         String key = invoker.getInterface().getName() + "." + invocation.getMethodName();
15:         // 打印告警日志
16:         if (!logged.contains(key)) {
17:             logged.add(key);
18:             if (invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.DEPRECATED_KEY, false)) {
19:                 LOGGER.error("The service method " + invoker.getInterface().getName() + "." + getMethodSignature(invocation) + " is DEPRECATED! Declare from " + invoker.getUrl());
20:             }
21:         }
22:         return invoker.invoke(invocation);
23:     }
24: 
25:     
26:     // 省略 getMethodSignature 方法
27: 
28: }
```

- `logged` **静态**属性，已经打印日志的方法集合。

- 第 14 行：获得方法名。

- 第 16 至 21 行：打印告警日志。一个服务的方法，**有且仅有**打印一次。例如：

  ```
  [14/04/18 11:51:35:035 CST] main ERROR filter.DeprecatedFilter:  [DUBBO] The service method com.alibaba.dubbo.demo.DemoService.say01(String) is DEPRECATED! Declare from dubbo://192.168.3.17:20880/com.alibaba.dubbo.demo.DemoService?accesslog=true&anyhost=true&application=demo-consumer&callbacks=1000&check=false&client=netty4&default.delay=-1&default.retries=0&delay=-1&deprecated=false&dubbo=2.0.0&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello,callbackParam,say03,say04,say01,bye,say02&payload=1000&pid=16820&qos.port=33333&register.ip=192.168.3.17&remote.timestamp=1523720843597&say01.deprecated=true&sayHello.async=true&server=netty4&service.filter=demo&side=consumer&timeout=100000&timestamp=1523721049491, dubbo version: 2.0.0, current host: 192.168.3.17
  ```

  - 注意，【第 18 行】会根据方法在判断。因为，一个服务里，可能只有**部分**方法废弃。

- 第 22 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

## 3. DeprecatedInvokerListener

功能**类似**，在 [《精尽 Dubbo 源码分析 —— 服务引用（一）之本地引用（Injvm）》「5.2 DeprecatedInvokerListener」](http://svip.iocoder.cn/Dubbo/reference-refer-local/?self) 中，已经有详细解析。

# 7、ExceptionFilter

## 1. 概述

本文分享异常过滤器 ExceptionFilter ，用于服务**提供者**中。用途如下：

> FROM ExceptionFilter 上的注释：
>
> 1. 不期望的异常打 ERROR 日志( Provider端 )。不期望的日志即是，没有的接口上声明的Unchecked异常。
> 2. 异常不在 API 包中，则 Wrap 一层 RuntimeException 。RPC 对于第一层异常会直接序列化传输( Cause 异常会 String 化) ，避免异常在 Client 出不能**反序列化**问题。

🙂 和我们平时业务写的用于**捕捉异常**的过滤器或者拦截器**不太一样**，而是关注点在服务消费者会不会出现不存在该异常类，导致反序列化的问题。

## 2. ExceptionFilter

`com.alibaba.dubbo.rpc.filter.ExceptionFilter` ，实现 Filter 接口，异常过滤器实现类。代码如下：

```
 1: @Activate(group = Constants.PROVIDER)
 2: public class ExceptionFilter implements Filter {
 3: 
 4:     private final Logger logger;
 5: 
 6:     public ExceptionFilter() {
 7:         this(LoggerFactory.getLogger(ExceptionFilter.class));
 8:     }
 9: 
10:     public ExceptionFilter(Logger logger) {
11:         this.logger = logger;
12:     }
13: 
14:     @Override
15:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
16:         try {
17:             // 服务调用
18:             Result result = invoker.invoke(invocation);
19:             // 有异常，并且非泛化调用
20:             if (result.hasException() && GenericService.class != invoker.getInterface()) {
21:                 try {
22:                     Throwable exception = result.getException();
23: 
24:                     // directly throw if it's checked exception
25:                     // 如果是checked异常，直接抛出
26:                     if (!(exception instanceof RuntimeException) && (exception instanceof Exception)) {
27:                         return result;
28:                     }
29:                     // directly throw if the exception appears in the signature
30:                     // 在方法签名上有声明，直接抛出
31:                     try {
32:                         Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());
33:                         Class<?>[] exceptionClassses = method.getExceptionTypes();
34:                         for (Class<?> exceptionClass : exceptionClassses) {
35:                             if (exception.getClass().equals(exceptionClass)) {
36:                                 return result;
37:                             }
38:                         }
39:                     } catch (NoSuchMethodException e) {
40:                         return result;
41:                     }
42: 
43:                     // 未在方法签名上定义的异常，在服务器端打印 ERROR 日志
44:                     // for the exception not found in method's signature, print ERROR message in server's log.
45:                     logger.error("Got unchecked and undeclared exception which called by " + RpcContext.getContext().getRemoteHost()
46:                             + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName()
47:                             + ", exception: " + exception.getClass().getName() + ": " + exception.getMessage(), exception);
48: 
49:                     // 异常类和接口类在同一 jar 包里，直接抛出
50:                     // directly throw if exception class and interface class are in the same jar file.
51:                     String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());
52:                     String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());
53:                     if (serviceFile == null || exceptionFile == null || serviceFile.equals(exceptionFile)) {
54:                         return result;
55:                     }
56:                     // 是JDK自带的异常，直接抛出
57:                     // directly throw if it's JDK exception
58:                     String className = exception.getClass().getName();
59:                     if (className.startsWith("java.") || className.startsWith("javax.")) {
60:                         return result;
61:                     }
62:                     // 是Dubbo本身的异常，直接抛出
63:                     // directly throw if it's dubbo exception
64:                     if (exception instanceof RpcException) {
65:                         return result;
66:                     }
67: 
68:                     // 否则，包装成RuntimeException抛给客户端
69:                     // otherwise, wrap with RuntimeException and throw back to the client
70:                     return new RpcResult(new RuntimeException(StringUtils.toString(exception)));
71:                 } catch (Throwable e) {
72:                     logger.warn("Fail to ExceptionFilter when called by " + RpcContext.getContext().getRemoteHost()
73:                             + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName()
74:                             + ", exception: " + e.getClass().getName() + ": " + e.getMessage(), e);
75:                     return result;
76:                 }
77:             }
78:             // 返回
79:             return result;
80:         } catch (RuntimeException e) {
81:             logger.error("Got unchecked and undeclared exception which called by " + RpcContext.getContext().getRemoteHost()
82:                     + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName()
83:                     + ", exception: " + e.getClass().getName() + ": " + e.getMessage(), e);
84:             throw e;
85:         }
86:     }
87: 
88: }
```

- 第 18 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

- 第 21 行：调用结果有异常，并且非**泛化调用**。

- 第 24 至 28 行：如果是 checked 异常，直接返回。因为，checked 异常，肯定定义在接口上了。

- 第 29 至 41 行：在接口方法的签名有生命，直接返回结果。

- 第 45 至 47 行：未在方法签名上定义的异常，在服务器端打印 ERROR 日志。

- 第 49 至 55 行：异常类和接口类在同一 **jar** 包里，直接返回结果。因为，服务消费者可以反序列化该异常。代码如下：

  ```
  public static String getCodeBase(Class<?> cls) {
      if (cls == null) {
          return null;
      }
      ProtectionDomain domain = cls.getProtectionDomain();
      if (domain == null) {
          return null;
      }
      CodeSource source = domain.getCodeSource();
      if (source == null) {
          return null;
      }
      URL location = source.getLocation();
      if (location == null) {
          return null;
      }
      return location.getFile();
  }
  ```

- 第 56 至 61 行：是 JDK 自带的异常，直接返回结果。

- 第 62 至 66 行：是 Dubbo 本身的异常，直接返回结果。

- 第 70 行：否则，包装成 RuntimeException 异常返回给服务消费者，同时把异常堆栈给包进去。代码如下：

  ```
  public static String toString(Throwable e) {
      UnsafeStringWriter w = new UnsafeStringWriter();
      PrintWriter p = new PrintWriter(w);
      p.print(e.getClass().getName());
      if (e.getMessage() != null) {
          p.print(": " + e.getMessage());
      }
      p.println();
      try {
          e.printStackTrace(p);
          return w.toString();
      } finally {
          p.close();
      }
  }
  ```

- 墙裂推荐 [《Dubbo(四) 异常处理》](https://blog.csdn.net/qq315737546/article/details/53915067)

- [《浅谈 Dubbo 的 ExceptionFilter 异常处理》](https://blog.csdn.net/mj158518/article/details/51228649)

# 8、TokenFilter

## 1. 概述

本文分享 TokenFilter 过滤器，用于服务**提供者**中，提供 **令牌验证** 的功能。在 [《Dubbo 用户指南 —— 令牌验证》](http://dubbo.apache.org/zh-cn/docs/user/demos/token-authorization.html) 定义如下：

> 通过令牌验证在**注册中心**控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者。
>
> 另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。
>
> ![认证流程](http://static.iocoder.cn/images/Dubbo/2018_11_19/01.png)

- 官方文档写的很全，胖友请点击链接看完哈。

So ，可能和大多数胖友（包括我），一开始理解和期望的不太一样 🙂 。

## 2.【服务消费者】随机 Token

在 ServiceConfig 的 `#doExportUrlsFor1Protocol(protocolConfig, registryURLs)` 方法中，随机生成 Token ：

```
// token ，参见《令牌校验》http://dubbo.apache.org/zh-cn/docs/user/demos/token-authorization.html
if (!ConfigUtils.isEmpty(token)) {
    if (ConfigUtils.isDefault(token)) { // true || default 时，UUID 随机生成
        map.put("token", UUID.randomUUID().toString());
    } else {
        map.put("token", token);
    }
}
```

## 3.【服务消费者】接收 Token

服务**消费者**，从注册中心，获取服务提供者的 **URL** ，从而获得该服务着的 Token 。
所以，即使服务提供者随机生成 Token ，消费者一样可以拿到。

## 3.【服务消费者】发送 Token

RpcInvocation 在创建时，“**自动**”带上 Token ，如下图所示：

![RpcInvocation](http://static.iocoder.cn/images/Dubbo/2018_11_19/02.png)

## 4.【服务提供者】认证 Token

`com.alibaba.dubbo.rpc.filter.TokenFilter` ，实现 Filter 接口，**令牌验证** Filter 实现类。代码如下：

```
@Activate(group = Constants.PROVIDER, value = Constants.TOKEN_KEY)
public class TokenFilter implements Filter {

    @Override
    public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
        // 获得服务提供者配置的 Token 值
        String token = invoker.getUrl().getParameter(Constants.TOKEN_KEY);
        if (ConfigUtils.isNotEmpty(token)) {
            // 从隐式参数中，获得 Token 值。
            Class<?> serviceType = invoker.getInterface();
            Map<String, String> attachments = inv.getAttachments();
            String remoteToken = attachments == null ? null : attachments.get(Constants.TOKEN_KEY);
            // 对比，若不一致，抛出 RpcException 异常
            if (!token.equals(remoteToken)) {
                throw new RpcException("Invalid token! Forbid invoke remote service " + serviceType + " method " + inv.getMethodName() + "() from consumer " + RpcContext.getContext().getRemoteHost() + " to provider " + RpcContext.getContext().getLocalHost());
            }
        }
        // 服务调用
        return invoker.invoke(inv);
    }

}
```

# 9、TpsLimitFilter

## 1. 概述

本文分享 TpsLimitFilter 过滤器，用于服务**提供者**中，提供 **限流** 的功能。

**配置方式**

① 通过 `<dubbo:parameter key="tps" value="" />` 配置项，添加到 `<dubbo:service />` 或 `<dubbo:provider />` 或 `<dubbo:protocol />` 中开启，例如：

```
<dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoServiceImpl" protocol="injvm" >
    <dubbo:parameter key="tps" value="100" />
</dubbo:service>
```

② 通过 `<dubbo:parameter key="tps.interval" value="" />` 配置项，设置 TPS **周期**。

**注意**

笔者阅读的 Dubbo 版本，目前暂未配置 TpsLimitFilter 到 Dubbo SPI 文件里，所以我们需要添加到 `com.alibaba.dubbo.rpc.Filter` 中，例如：

```
tps=com.alibaba.dubbo.rpc.filter.TpsLimitFilter
```

## 2. TpsLimitFilter

`com.alibaba.dubbo.rpc.filter.TpsLimitFilter` ，实现 Filter 接口，TPS 限流过滤器实现类。代码如下：

```
 1: @Activate(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)
 2: public class TpsLimitFilter implements Filter {
 3: 
 4:     private final TPSLimiter tpsLimiter = new DefaultTPSLimiter();
 5: 
 6:     @Override
 7:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
 8:         if (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) {
 9:             throw new RpcException(
10:                     new StringBuilder(64)
11:                             .append("Failed to invoke service ")
12:                             .append(invoker.getInterface().getName())
13:                             .append(".")
14:                             .append(invocation.getMethodName())
15:                             .append(" because exceed max service tps.")
16:                             .toString());
17:         }
18:         // 服务调用
19:         return invoker.invoke(invocation);
20:     }
21: 
22: }
```

- 第 8 至 17 行：调用 `TPSLimiter#isAllowable(url, invocation)` 方法，根据 tps 限流规则判断是否限制此次调用。若是，抛出 RpcException 异常。目前使用 TPSLimiter 作为限流器的实现类。
- 第 19 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

## 3. TPSLimiter

`com.alibaba.dubbo.rpc.filter.tps.TPSLimiter` ，TPS 限制器接口。代码如下：

```
public interface TPSLimiter {

    /**
     * judge if the current invocation is allowed by TPS rule
     *
     * 根据 tps 限流规则判断是否限制此次调用.
     *
     * @param url        url
     * @param invocation invocation
     * @return true allow the current invocation, otherwise, return false
     */
    boolean isAllowable(URL url, Invocation invocation);

}
```

#### 3.1 DefaultTPSLimiter

`com.alibaba.dubbo.rpc.filter.tps.DefaultTPSLimiter` ，实现 TPSLimiter 接口，**默认** TPS 限制器实现类，**以服务为维度**。代码如下：

```
 1: public class DefaultTPSLimiter implements TPSLimiter {
 2: 
 3:     /**
 4:      * StatItem 集合
 5:      *
 6:      * key：服务名
 7:      */
 8:     private final ConcurrentMap<String, StatItem> stats = new ConcurrentHashMap<String, StatItem>();
 9: 
10:     @Override
11:     public boolean isAllowable(URL url, Invocation invocation) {
12:         // 获得 TPS 大小配置项
13:         int rate = url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -1);
14:         // 获得 TPS 周期配置项，默认 60 秒
15:         long interval = url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY, Constants.DEFAULT_TPS_LIMIT_INTERVAL);
16:         String serviceKey = url.getServiceKey();
17:         // 要限流
18:         if (rate > 0) {
19:             // 获得 StatItem 对象
20:             StatItem statItem = stats.get(serviceKey);
21:             // 不存在，则进行创建
22:             if (statItem == null) {
23:                 stats.putIfAbsent(serviceKey, new StatItem(serviceKey, rate, interval));
24:                 statItem = stats.get(serviceKey);
25:             }
26:             // 根据 TPS 限流规则判断是否限制此次调用.
27:             return statItem.isAllowable(url, invocation);
28:         // 不限流
29:         } else {
30:             // 移除 StatItem
31:             StatItem statItem = stats.get(serviceKey);
32:             if (statItem != null) {
33:                 stats.remove(serviceKey);
34:             }
35:             // 返回通过
36:             return true;
37:         }
38:     }
39: 
40: }
```

- `stats` 属性，StatItem 集合，Key 为 服务名，**即以服务为维度**。
- 第 13 行：获得 TPS 大小配置项 `"tps"`。
- 第 15 行：获得 TPS 周期配置项 `"tps.interval"`，默认 60 * 1000 毫秒。
- 第 17 至 27 行：若要限流，调用 `StatItem#isAllowable(url, invocation)` 方法，根据 TPS 限流规则判断是否限制此次调用。
- 第 28 至 37 行：若不限流，移除 StatItem 对象。

#### 3.2 StatItem

`com.alibaba.dubbo.rpc.filter.tps.StatItem` ，统计项。

###### 3.2.1 构造方法

```
/**
 * 统计名，目前使用服务名
 */
private String name;
/**
 * 周期
 */
private long interval;
/**
 * 限制大小
 */
private int rate;
/**
 * 最后重置时间
 */
private long lastResetTime;
/**
 * 当前周期，剩余种子数
 */
private AtomicInteger token;

StatItem(String name, int rate, long interval) {
    this.name = name;
    this.rate = rate;
    this.interval = interval;
    this.lastResetTime = System.currentTimeMillis();
    this.token = new AtomicInteger(rate);
}
```

###### 3.2.2 isAllowable

```
public boolean isAllowable(URL url, Invocation invocation) {
    // 若到达下一个周期，恢复可用种子数，设置最后重置时间。
    long now = System.currentTimeMillis();
    if (now > lastResetTime + interval) {
        token.set(rate); // 回复可用种子数
        lastResetTime = now; // 最后重置时间
    }

    // CAS ，直到或得到一个种子，或者没有足够种子
    int value = token.get();
    boolean flag = false;
    while (value > 0 && !flag) {
        flag = token.compareAndSet(value, value - 1);
        value = token.get();
    }

    // 是否成功
    return flag;
}
```

# 10、CacheFilter

## 1. 概述

本文分享 `dubbo-filter-cache` 项目的 CacheFilter 过滤器，用于服务**消费者**和**提供者**中，提供 **结果缓存** 的功能。在 [《Dubbo 用户指南 —— 结果缓存》](http://dubbo.apache.org/zh-cn/docs/user/demos/result-cache.html) 定义如下：

> 结果缓存 ，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。

Dubbo 提供了**三种**实现：

> - `lru` ：基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。
> - `threadlocal` ：当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。
> - `jcache` ：与 [JSR107](https://jcp.org/en/jsr/detail?id=107) 集成，可以桥接各种缓存实现。

- 具体的配置方式，在 [《Dubbo 用户指南 —— 结果缓存》](http://dubbo.apache.org/zh-cn/docs/user/demos/result-cache.html) 文档中，已经详细分享。

本文涉及的类，如下图所示：[![类图](http://static.iocoder.cn/images/Dubbo/2018_11_21/01.png)](http://static.iocoder.cn/images/Dubbo/2018_11_21/01.png)类图

## 2. CacheFilter

`com.alibaba.dubbo.cache.filter.CacheFilter` ，实现 Filter 接口，缓存过滤器实现类。代码如下：

```
 1: @Activate(group = {Constants.CONSUMER, Constants.PROVIDER}, value = Constants.CACHE_KEY)
 2: public class CacheFilter implements Filter {
 3: 
 4:     /**
 5:      * CacheFactory$Adaptive 对象。
 6:      *
 7:      * 通过 Dubbo SPI 机制，调用 {@link #setCacheFactory(CacheFactory)} 方法，进行注入
 8:      */
 9:     private CacheFactory cacheFactory;
10: 
11:     public void setCacheFactory(CacheFactory cacheFactory) {
12:         this.cacheFactory = cacheFactory;
13:     }
14: 
15:     @Override
16:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
17:         // 方法开启 Cache 功能
18:         if (cacheFactory != null && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.CACHE_KEY))) {
19:             // 基于 URL + Method 为维度，获得 Cache 对象。
20:             Cache cache = cacheFactory.getCache(invoker.getUrl().addParameter(Constants.METHOD_KEY, invocation.getMethodName())); // 添加 `method` 属性，是因为 JCache 需要。
21:             if (cache != null) {
22:                 // 获得 Cache Key
23:                 String key = StringUtils.toArgumentString(invocation.getArguments());
24:                 // 从缓存中获得结果。若存在，创建 RpcResult 对象。
25:                 Object value = cache.get(key);
26:                 if (value != null) {
27:                     return new RpcResult(value);
28:                 }
29:                 // 服务调用
30:                 Result result = invoker.invoke(invocation);
31:                 // 若非异常结果，缓存结果
32:                 if (!result.hasException()) {
33:                     cache.put(key, result.getValue());
34:                 }
35:                 return result;
36:             }
37:         }
38:         // 服务调用
39:         return invoker.invoke(invocation);
40:     }
41: 
42: }
```

- 第 18 行：判断方法**开启** Cache 功能。因为，一个服务里，可能只有**部分**方法开启了 Cache 功能。

- 第 20 行：调用 `CacheFactory$Adaptive#getCache(url)` 方法，基于 **URL + Method** 为维度，获得 Cache 对象。

- 第 23 行：调用 `StringUtils#toArgumentString(Object[] args)` 方法，获得 Cache Key 。代码如下：

  ```
  /**
   * 将参数数组，拼接成字符串。
   *
   * 1. 使用逗号分隔
   * 2. 使用 JSON 格式化对象
   *
   * @param args 参数数组
   * @return 字符串
   */
  public static String toArgumentString(Object[] args) {
      StringBuilder buf = new StringBuilder();
      for (Object arg : args) {
          if (buf.length() > 0) {
              buf.append(Constants.COMMA_SEPARATOR); // 分隔
          }
          // 拼接参数
          if (arg == null || ReflectUtils.isPrimitives(arg.getClass())) {
              buf.append(arg);
          } else {
              try {
                  buf.append(JSON.toJSONString(arg)); // 使用 JSON 格式化对象
              } catch (Exception e) {
                  logger.warn(e.getMessage(), e);
                  buf.append(arg);
              }
          }
      }
      return buf.toString();
  }
  ```

- 第 24 至 28 行：调用 `Cache#get(key)` 方法，从缓存中获得结果。若**存在**，创建 RpcResult 对象并返回。

- 第 30 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

- 第 31 至 34 行：若**非异常**，调用 `Cache#put(key, value)` 方法，缓存**正常的**结果。

- 第 35 行：返回调用结果。

- 第 39 行：若**不使用** Cache 功能，**直接**调用 `Invoker#invoke(invocation)` 方法，服务调用。

## 3. API 定义

#### 3.1 Cache

`com.alibaba.dubbo.cache.Cache` ，缓存**容器**接口。方法如下：

```
public interface Cache {

    /**
     * 添加键值
     *
     * @param key 键
     * @param value 值
     */
    void put(Object key, Object value);

    /**
     * 获得值
     *
     * @param key 键
     * @return 值
     */
    Object get(Object key);

}
```

- Cache 是个缓存**容器**，内部可以**管理**缓存的键值。

#### 3.2 CacheFactory

`com.alibaba.dubbo.cache.CacheFactory` ，Cache 工厂**接口**。方法如下：

```
@SPI("lru")
public interface CacheFactory {

    /**
     * 获得缓存对象
     *
     * @param url URL 对象
     * @return 缓存对象
     */
    @Adaptive("cache")
    Cache getCache(URL url);

}
```

- `@SPI("lru")` 注解，Dubbo SPI **拓展点**，默认为 `"lru"` 。
- `@Adaptive("cache")` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Cache 实现，使用 `URL.cache` 属性。

###### 3.2.1 AbstractCacheFactory

`com.alibaba.dubbo.cache.support.AbstractCacheFactory` ，Cache 工厂**抽象类**。代码如下：

```
public abstract class AbstractCacheFactory implements CacheFactory {

    /**
     * Cache 集合
     *
     * key：URL
     */
    private final ConcurrentMap<String, Cache> caches = new ConcurrentHashMap<String, Cache>();

    @Override
    public Cache getCache(URL url) {
        // 获得 Cache 对象
        String key = url.toFullString();
        Cache cache = caches.get(key);
        // 不存在，创建 Cache 对象，并缓存
        if (cache == null) {
            caches.put(key, createCache(url));
            cache = caches.get(key);
        }
        return cache;
    }

    /**
     * 创建 Cache 对象
     *
     * @param url URL
     * @return Cache 对象
     */
    protected abstract Cache createCache(URL url);

}
```

## 4. LRU 实现

`lru` ，基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。

#### 4.1 LruCache

`com.alibaba.dubbo.cache.support.lru.LruCache` ，实现 Cache 接口，代码如下：

```
public class LruCache implements Cache {

    /**
     * 缓存集合
     */
    private final Map<Object, Object> store;

    public LruCache(URL url) {
        // `"cache.size"` 配置项，设置缓存大小
        final int max = url.getParameter("cache.size", 1000);
        // 创建 LRUCache 对象
        this.store = new LRUCache<Object, Object>(max);
    }

    @Override
    public void put(Object key, Object value) {
        store.put(key, value);
    }

    @Override
    public Object get(Object key) {
        return store.get(key);
    }

}
```

- `"cache.size"` 配置项，设置缓存**大小**。
- 基于 `com.alibaba.dubbo.common.utils.LRUCache` 实现。

###### 4.1.1 LRUCache

[`com.alibaba.dubbo.common.utils.LRUCache`](https://github.com/YunaiV/dubbo/blob/26d2f1811c23096224fc9a973b3526f01aabeb28/dubbo-common/src/main/java/com/alibaba/dubbo/common/utils/LRUCache.java) ，实现 LinkedHashMap 类，LRU 缓存实现类。代码比较多，胖友点击链接查看。笔者说几个关键点：

- 构造方法，设置 LRUCache 为**按访问顺序(调用get方法)**的链表。代码如下：

  ```
  public LRUCache(int maxCapacity) {
      super(16, DEFAULT_LOAD_FACTOR, true); // 最后一个参数，按访问顺序(调用get方法)的链表
      this.maxCapacity = maxCapacity;
  }
  ```

- 重写 removeEldestEntry 方法返回 true 值，指定插入元素时移除最老的元素。代码如下：

  ```
  @Override
  protected boolean removeEldestEntry(java.util.Map.Entry<K, V> eldest) {
      return size() > maxCapacity;
  }
  ```

  - 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。

- `lock` 属性，锁。避免并发读写，导致死锁。参见 [《疫苗：JAVA HashMap 的死循环》](https://coolshell.cn/articles/9606.html) 。涉及该属性的方法示例：

  ```
  @Override
  public V put(K key, V value) {
      try {
          lock.lock();
          return super.put(key, value);
      } finally {
          lock.unlock();
      }
  }
  
  @Override
  public V remove(Object key) {
      try {
          lock.lock();
          return super.remove(key);
      } finally {
          lock.unlock();
      }
  }
  ```

#### 4.2 LruCacheFactory

`com.alibaba.dubbo.cache.support.lru.LruCacheFactory` ，实现 AbstractCacheFactory 抽象类，代码如下：

```
public class LruCacheFactory extends AbstractCacheFactory {

    @Override
    protected Cache createCache(URL url) {
        return new LruCache(url);
    }

}
```

## 5. ThreadLocal 实现

基于 **ThreadLocal** ，当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。

#### 5.1 ThreadLocalCache

`com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCache` ，实现 Cache 接口，代码如下：

```
public class ThreadLocalCache implements Cache {

    private final ThreadLocal<Map<Object, Object>> store; // 线程变量

    public ThreadLocalCache(URL url) {
        this.store = new ThreadLocal<Map<Object, Object>>() {

            @Override
            protected Map<Object, Object> initialValue() {
                return new HashMap<Object, Object>();
            }

        };
    }

    @Override
    public void put(Object key, Object value) {
        store.get().put(key, value);
    }

    @Override
    public Object get(Object key) {
        return store.get().get(key);
    }

}
```

- 基于 ThreadLocal 实现，相当于一个线程，一个 ThreadLocalCache 对象。
- 🙂 ThreadLocalCache 目前没有过期或清理机制，所以**需要注意**。

#### 5.2 ThreadLocalCacheFactory

`com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory` ，实现 AbstractCacheFactory 抽象类，代码如下：

```
public class ThreadLocalCacheFactory extends AbstractCacheFactory {

    @Override
    protected Cache createCache(URL url) {
        return new ThreadLocalCache(url);
    }

}
```

## 6. JCache 实现

与 [JSR107](https://jcp.org/en/jsr/detail?id=107) 集成，可以桥接各种缓存实现。

#### 6.1 JCache

`com.alibaba.dubbo.cache.support.jcache.JCache` ，实现 Cache 接口，代码如下：

```
public class JCache implements com.alibaba.dubbo.cache.Cache {

    private final Cache<Object, Object> store;

    public JCache(URL url) {
        // 获得 Cache Key
        String method = url.getParameter(Constants.METHOD_KEY, "");
        String key = url.getAddress() + "." + url.getServiceKey() + "." + method;
        // `"jcache"` 配置项，为 Java SPI 实现的全限定类名
        // jcache parameter is the full-qualified class name of SPI implementation
        String type = url.getParameter("jcache");

        // 基于类型，获得 javax.cache.CachingProvider 对象，
        CachingProvider provider = type == null || type.length() == 0 ? Caching.getCachingProvider() : Caching.getCachingProvider(type);
        // 获得 javax.cache.CacheManager 对象
        CacheManager cacheManager = provider.getCacheManager();
        // 获得 javax.cache.Cache 对象
        Cache<Object, Object> cache = cacheManager.getCache(key);
        // 不存在，则进行创建
        if (cache == null) {
            try {
                // 设置 Cache 配置项
                // configure the cache
                MutableConfiguration config =
                        new MutableConfiguration<Object, Object>()
                                // 类型
                                .setTypes(Object.class, Object.class)
                                // 过期策略，按照写入时间过期。通过 `"cache.write.expire"` 配置项设置过期时间，默认为 1 分钟。
                                .setExpiryPolicyFactory(CreatedExpiryPolicy.factoryOf(new Duration(TimeUnit.MILLISECONDS, url.getMethodParameter(method, "cache.write.expire", 60 * 1000))))
                                .setStoreByValue(false)
                                // 设置 MBean
                                .setManagementEnabled(true)
                                .setStatisticsEnabled(true);
                // 创建 javax.cache.Cache 对象
                cache = cacheManager.createCache(key, config);
            } catch (CacheException e) {
                // 初始化 cache 的并发情况
                // concurrent cache initialization
                cache = cacheManager.getCache(key);
            }
        }

        this.store = cache;
    }

    @Override
    public void put(Object key, Object value) {
        store.put(key, value);
    }

    @Override
    public Object get(Object key) {
        return store.get(key);
    }

}
```

- 已经添加详细中文注释，胖友自己查看。
- 笔者对 JCache 了解不多，推荐阅读 [《 Java Caching(缓存)-策略和JCache API》](https://blog.csdn.net/boonya/article/details/54632129)

#### 6.2 JCacheFactory

`com.alibaba.dubbo.cache.support.jcache.JCacheFactory` ，实现 AbstractCacheFactory 抽象类，代码如下：

```
public class JCacheFactory extends AbstractCacheFactory {

    @Override
    protected Cache createCache(URL url) {
        return new JCache(url);
    }

}
```

# 11、ValidationFilter

## 1. 概述

本文分享 `dubbo-filter-validation` 项目的 ValidationFilter 过滤器，用于服务**消费者**和**提供者**中，提供 **参数验证** 的功能。在 [《Dubbo 用户指南 —— 参数验证》](http://dubbo.apache.org/zh-cn/docs/user/demos/parameter-validation.html) 定义如下：

> 参数验证功能，是基于 [JSR303](https://jcp.org/en/jsr/detail?id=303) Bean Validation 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。

- **配置**和**示例**，官方文档已经写的很齐全，笔者就不多哔哔了。

- 如下是新版本的 Maven 依赖的例子：

  ```
  <!-- JSR 303 - Bean Validation begin -->
  <dependency>
      <groupId>javax.validation</groupId>
      <artifactId>validation-api</artifactId>
      <version>1.1.0.Final</version>
  </dependency>
  <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-validator</artifactId>
      <version>5.3.4.Final</version>
  </dependency>
  <dependency>
      <groupId>javax.el</groupId>
      <artifactId>javax.el-api</artifactId>
      <version>2.2.4</version>
  </dependency>
  <dependency>
      <groupId>org.glassfish.web</groupId>
      <artifactId>javax.el</artifactId>
      <version>2.2.4</version>
  </dependency>
  <!-- JSR 303 - Bean Validation end -->
  ```

本文涉及的类，如下图所示：[![类图](http://static.iocoder.cn/images/Dubbo/2018_11_22/02.png)](http://static.iocoder.cn/images/Dubbo/2018_11_22/02.png)类图

## 2. ValidationFilter

`com.alibaba.dubbo.validation.filter.ValidationFilter` ，实现 Filter 接口，参数验证过滤器实现类。代码如下：

```
 1: @Activate(group = {Constants.CONSUMER, Constants.PROVIDER}, value = Constants.VALIDATION_KEY, order = 10000)
 2: public class ValidationFilter implements Filter {
 3: 
 4:     /**
 5:      * Validation$Adaptive 对象
 6:      *
 7:      * 通过 Dubbo SPI 机制，调用 {@link #setValidation(Validation)} 方法，进行注入
 8:      */
 9:     private Validation validation;
10: 
11:     public void setValidation(Validation validation) {
12:         this.validation = validation;
13:     }
14: 
15:     @Override
16:     public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
17:         if (validation != null && !invocation.getMethodName().startsWith("$") // 非泛化调用和回音调用等方法
18:                 && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.VALIDATION_KEY))) { // 方法开启 Validation 功能
19:             try {
20:                 // 获得 Validator 对象
21:                 Validator validator = validation.getValidator(invoker.getUrl());
22:                 // 使用 Validator ，验证方法参数。若不合法，抛出异常。
23:                 if (validator != null) {
24:                     validator.validate(invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());
25:                 }
26:             } catch (RpcException e) {
27:                 throw e;
28:             } catch (Throwable t) {
29:                 return new RpcResult(t);
30:             }
31:         }
32:         // 服务调用
33:         return invoker.invoke(invocation);
34:     }
35: 
36: }
```

- 第 17 行：非泛化调用和回音调用等方法。
- 第 18 行：判断方法**开启** Validation 功能。因为，一个服务里，可能只有**部分**方法开启了 Validation 功能。
- 第 21 行：调用 `Validation$Adaptive#getValidator(url)` 方法，基于 **URL** 为维度，获得 Validator 对象。
- 第 22 至 25 行：调用 `Validator#validate(String methodName, Class<?>[] parameterTypes, Object[] arguments)` 方法，方法参数验证。若不合法，抛出异常。
- 第 33 行：调用 `Invoker#invoke(invocation)` 方法，服务调用。

## 3. API 定义

#### 3.1 Validator

`com.alibaba.dubbo.validation.Validator` ，验证器接口。代码如下：

```
public interface Validator {

    /**
     * 方法参数验证
     *
     * @param methodName 方法名
     * @param parameterTypes 参数类型数组
     * @param arguments 参数值数组
     * @throws Exception 当发生异常时
     */
    void validate(String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Exception;

}
```

#### 3.2 Validation

`com.alibaba.dubbo.validation.Validation` ，Validator 工厂**接口**。代码如下：

```
@SPI("jvalidation")
public interface Validation {

    /**
     * 获得 Validator 对象
     *
     * @param url URL
     * @return Validator
     */
    @Adaptive(Constants.VALIDATION_KEY)
    Validator getValidator(URL url);

}
```

- `@SPI("jvalidation")` 注解，Dubbo SPI **拓展点**，默认为 `"jvalidation"` 。
- `@Adaptive("validation")` 注解，基于 Dubbo SPI Adaptive 机制，加载对应的 Validator 实现，使用 `URL.validation` 属性。

###### 3.2.1 AbstractValidation

`com.alibaba.dubbo.validation.support.AbstractValidation` ，实现 Validation 接口，Validator 工厂**抽象类**。代码如下：

```
public abstract class AbstractValidation implements Validation {

    /**
     * Validator 集合
     *
     * key：URL
     */
    private final ConcurrentMap<String, Validator> validators = new ConcurrentHashMap<String, Validator>();

    @Override
    public Validator getValidator(URL url) {
        // 获得 Validator 对象
        String key = url.toFullString();
        Validator validator = validators.get(key);
        // 不存在，创建 Validator 对象，并缓存
        if (validator == null) {
            validators.put(key, createValidator(url));
            validator = validators.get(key);
        }
        return validator;
    }

    /**
     * 创建 Validator 对象
     *
     * @param url URL
     * @return Validator 对象
     */
    protected abstract Validator createValidator(URL url);

}
```

## 3.3 @MethodValidated

`com.alibaba.dubbo.validation.@MethodValidated` ，方法分组验证**注解**。代码如下：

```
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MethodValidated {

    /**
     * @return 分组集合
     */
    Class<?>[] value() default {};

}
```

- 使用场景：当调用某个方法时，需要检查多个分组，可以在接口方法上加上该注解。

- 用法：

  ```
  @MethodValidated({Save.class, Update.class})
  void relatedQuery(ValidationParameter parameter);
  ```

  - 在接口方法上增加注解，表示 `#relatedQuery(ValidationParameter)` 这个方法，需要同时检查 Save 和 Update 这两个分组。
  - 如果胖友对 Java Bean Validation 分组不熟悉，可以理解起来比较绕。可以跑下官方提供的 [`com.alibaba.dubbo.config.validation`](https://github.com/YunaiV/dubbo/tree/f4216485f5641ea5cf406d1e58503c5651f86432/dubbo-config/dubbo-config-api/src/test/java/com/alibaba/dubbo/config/validation) 的立足。[![relatedQuery](http://static.iocoder.cn/images/Dubbo/2018_11_22/01.png)](http://static.iocoder.cn/images/Dubbo/2018_11_22/01.png)relatedQuery

## 4. JSR303 实现

基于 [JSR303](https://jcp.org/en/jsr/detail?id=303) Bean Validation 实现的，用户只需标识 JSR303 标准的验证 annotation 。

#### 4.1 JValidator

`com.alibaba.dubbo.validation.support.jvalidation.JValidator` ，实现 Validator 接口，基于 [JSR303](https://jcp.org/en/jsr/detail?id=303) 的验证器实现类。

###### 4.1.1 构造方法

```
/**
 * 服务接口类
 */
private final Class<?> clazz;
/**
 * Validator 对象
 */
private final javax.validation.Validator validator;

@SuppressWarnings({"unchecked", "rawtypes"})
public JValidator(URL url) {
    // 获得服务接口类
    this.clazz = ReflectUtils.forName(url.getServiceInterface());
    // 获得 `"jvalidation"` 配置项
    String jvalidation = url.getParameter("jvalidation");
    // 获得 ValidatorFactory 对象
    ValidatorFactory factory;
    if (jvalidation != null && jvalidation.length() > 0) { // 指定实现
        factory = Validation.byProvider((Class) ReflectUtils.forName(jvalidation)).configure().buildValidatorFactory();
    } else { // 默认
        factory = Validation.buildDefaultValidatorFactory();
    }
    // 获得 javax Validator 对象
    this.validator = factory.getValidator();
}
```

- `"jvalidation"` 配置项，可**指定**具体的 JSR303 的实现类。
- 如果我们**未配置**，并且引入 Hibernate Validator ，则使用的是 HibernateValidatorFactory 。

###### 4.1.2 validate

```
 1: @Override
 2: public void validate(String methodName, Class<?>[] parameterTypes, Object[] arguments) throws Exception {
 3:     // 验证分组集合
 4:     List<Class<?>> groups = new ArrayList<Class<?>>();
 5:     // 【第一种】添加以方法命名的内部接口，作为验证分组。例如 `ValidationService#save(...)` 方法，对应 `ValidationService.Save` 接口。
 6:     String methodClassName = clazz.getName() + "$" + toUpperMethodName(methodName);
 7:     Class<?> methodClass;
 8:     try {
 9:         methodClass = Class.forName(methodClassName, false, Thread.currentThread().getContextClassLoader());
10:         groups.add(methodClass);
11:     } catch (ClassNotFoundException e) {
12:     }
13:     // 【第二种】添加方法的 @MethodValidated 注解的值对应的类，作为验证分组。
14:     Method method = clazz.getMethod(methodName, parameterTypes);
15:     Class<?>[] methodClasses;
16:     if (method.isAnnotationPresent(MethodValidated.class)){
17:         methodClasses = method.getAnnotation(MethodValidated.class).value();
18:         groups.addAll(Arrays.asList(methodClasses));
19:     }
20:     // 【第三种】添加 Default.class 类，作为验证分组。在 JSR 303 中，未设置分组的验证注解，使用 Default.class 。
21:     // add into default group
22:     groups.add(0, Default.class);
23:     // 【第四种】添加服务接口类，作为验证分组。
24:     groups.add(1, clazz);
25:     // convert list to array
26:     Class<?>[] classGroups = groups.toArray(new Class[0]);
27: 
28:     // 验证错误集合
29:     Set<ConstraintViolation<?>> violations = new HashSet<ConstraintViolation<?>>();
30:     // 【第一步】获得方法参数的 Bean 对象。因为，JSR 303 是 Java Bean Validation ，以 Bean 为维度。
31:     Object parameterBean = getMethodParameterBean(clazz, method, arguments);
32:     // 【第一步】验证 Bean 对象。
33:     if (parameterBean != null) {
34:         violations.addAll(validator.validate(parameterBean, classGroups));
35:     }
36:     // 【第二步】验证集合参数
37:     for (Object arg : arguments) {
38:         validate(violations, arg, classGroups);
39:     }
40:     // 若有错误，抛出 ConstraintViolationException 异常。
41:     if (!violations.isEmpty()) {
42:         logger.error("Failed to validate service: " + clazz.getName() + ", method: " + methodName + ", cause: " + violations);
43:         throw new ConstraintViolationException("Failed to validate service: " + clazz.getName() + ", method: " + methodName + ", cause: " + violations, violations);
44:     }
45: }
```

- ============ 【第一步】获得验证分组集合 ============

- 第 4 行：验证分组集合 `group` ，目前有四种来源。

- 【第一种】第 5 至 12 行：添加以方法命名的内部接口，作为验证分组。例如 `ValidationService#save(...)` 方法，对应 `ValidationService.Save` 接口。

- 【第二种】第 13 至 19 行：添加方法的 `@MethodValidated` 注解的值对应的类，作为验证分组。

- 【第三种】第 22 行：添加 Default.class 类，作为验证分组。在 JSR 303 中，未设置分组的验证注解，使用 Default.class 。

- 【第四种】第 24 行：添加服务接口类 `clazz` ，作为验证分组。

- 最终生成的验证分组集合的顺序为：【第三种】》【第四种】》【第一种】》【第二种】。

- ============ 【第二步】验证方法参数 ============

- 第 29 行：验证错误集合 `violations` 。

- 【第一步】调用 `#getMethodParameterBean(Class<?> clazz, Method method, Object[] args)` 方法，获得方法参数的 Bean 对象。因为，JSR 303 是 Java Bean Validation ，以 Bean 为维度。具体的实现，我们在 [「4.1.3 getMethodParameterBean」](http://svip.iocoder.cn/Dubbo/filter-validation-filter/#) 中，详细解析。

- 【第一步】调用 `Validator#validate(T object, Class<?>... groups)` 方法，验证 **Bean** 对象。

- 【第二步】循环方法参数，调用 `#validate(violations, arg, classGroups)` 方法，验证**集合**参数。**为什么会有这一步**？因为，在【第一步】中，校验的是 Constraint 注解的参数( 例如 `@NotNull` ) ，但是呢，若是集合参数，**不会校验集合中的每个元素**。我们来举个例子：

  ```
  void saves(@NotNull(message = "至少需要保存一个用户") User[] users);
  ```

  - 【第一步】校验 `users` 参数的 `@NotNull` 约束。
  - 【第二步】校验 `users` 参数中的**每个 User** 的约束。

- 第 40 至 44 行：若有验证错误，抛出 ConstraintViolationException 异常。

------

`#validate(Set<ConstraintViolation<?>> violations, Object arg, Class<?>... groups)` 方法，代码如下：

```
 1: /**
 2:  * 验证集合参数
 3:  *
 4:  * @param violations 验证错误集合
 5:  * @param arg 参数
 6:  * @param groups 验证分组集合
 7:  */
 8: private void validate(Set<ConstraintViolation<?>> violations, Object arg, Class<?>... groups) {
 9:     if (arg != null && !isPrimitives(arg.getClass())) {
10:         // [] 数组
11:         if (Object[].class.isInstance(arg)) {
12:             for (Object item : (Object[]) arg) {
13:                 validate(violations, item, groups); // 单个元素
14:             }
15:         // Collection
16:         } else if (Collection.class.isInstance(arg)) {
17:             for (Object item : (Collection<?>) arg) {
18:                 validate(violations, item, groups); // 单个元素
19:             }
20:         // Map
21:         } else if (Map.class.isInstance(arg)) {
22:             for (Map.Entry<?, ?> entry : ((Map<?, ?>) arg).entrySet()) {
23:                 validate(violations, entry.getKey(), groups); // 单个元素
24:                 validate(violations, entry.getValue(), groups); // 单个元素
25:             }
26:         // 单个元素
27:         } else {
28:             violations.addAll(validator.validate(arg, groups));
29:         }
30:     }
31: }
```

- 第 9 行：调用 `#isPrimitives(Class<?> cls)` 方法，判断是否为**基本类型**。若是基本类型，已经被【**第一步**】给验证了，避免重复验证。代码如下：

  ```
  private static boolean isPrimitives(Class<?> cls) {
      // [] 数组，使用内部的类来判断
      if (cls.isArray()) {
          return isPrimitive(cls.getComponentType());
      }
      // 直接判断
      return isPrimitive(cls);
  }
  
  private static boolean isPrimitive(Class<?> cls) {
      return cls.isPrimitive() || cls == String.class || cls == Boolean.class || cls == Character.class
              || Number.class.isAssignableFrom(cls) || Date.class.isAssignableFrom(cls);
  }
  ```

- 第 10 至 14 行：验证 `[ ]` 数组参数，循环调用【第 26 至 29】的验证。

- 第 15 至 19 行：验证 Collection 参数，循环调用【第 26 至 29】的验证。

- 第 20 至 25 行：验证 Map 参数，循环调用【第 26 至 29】的验证。

- **第 26 至 29 行**：验证**单个**参数。

###### 4.1.3 getMethodParameterBean

在看 `#getMethodParameterBean(Class<?> clazz, Method method, Object[] args)` 的具体实现代码之前，我们来看下它，根据方法，**自动生成** Bean 类的例子。

- 接口方法，代码如下：

  ```
  void demo(@NotNull(message = "名字不能为空") @Min(value = 6, message = "昵称不能太短") String name,
            String password, // 不校验
            @NotNull(message = "至少需要保存一个用户") User user);
  ```

- 生成 Bean 类，代码如下：

  ```
  package com.alibaba.dubbo.demo.DemoService_DemoParameter_java.lang.String_java.lang.String_com.alibaba.dubbo.demo.entity;
  
  public class User {
  
      @NotNull(message = "名字不能为空") 
      @Min(value = 6, message = "昵称不能太短")
      public java.lang.String name;
      
      public java.lang.String password;
      
      @NotNull(message = "至少需要保存一个用户")
      public com.alibaba.dubbo.demo.entity.User user;
      
      public User() {}
  
  }
  ```

  - 😈 Javassist 生成的类，使用 JD-GUI 反编译一直报错。所以，该类是笔者，**手工**生成的。哈哈哈，意思能达到就好。

------

`#getMethodParameterBean(Class<?> clazz, Method method, Object[] args)` 方法，代码如下：

```
 1: /**
 2:  * 使用方法参数，创建 Bean 对象。
 3:  *
 4:  * 因为该 Bean 对象，实际不存在对应类，使用 Javassist 动态编译生成。
 5:  *
 6:  * @param clazz 服务接口类
 7:  * @param method 方法
 8:  * @param args 参数数组
 9:  * @return Bean 对象
10:  */
11: private static Object getMethodParameterBean(Class<?> clazz, Method method, Object[] args) {
12:     // 无 Constraint 注解的方法参数，无需创建 Bean 对象。
13:     if (!hasConstraintParameter(method)) {
14:         return null;
15:     }
16:     try {
17:         // 获得 Bean 类名
18:         String parameterClassName = generateMethodParameterClassName(clazz, method);
19:         Class<?> parameterClass;
20:         try {
21:             // 获得 Bean 类
22:             parameterClass = Class.forName(parameterClassName, true, clazz.getClassLoader());
23:         } catch (ClassNotFoundException e) { // 类不存在，使用 Javassist 动态编译生成
24:             // 创建 ClassPool 对象
25:             ClassPool pool = ClassGenerator.getClassPool(clazz.getClassLoader());
26:             // 创建 CtClass 对象
27:             CtClass ctClass = pool.makeClass(parameterClassName);
28:             // 设置 Java 版本为 5
29:             ClassFile classFile = ctClass.getClassFile();
30:             classFile.setVersionToJava5();
31:             // 添加默认构造方法
32:             ctClass.addConstructor(CtNewConstructor.defaultConstructor(pool.getCtClass(parameterClassName)));
33:             // 循环每个方法参数，生成对应的类的属性
34:             // parameter fields
35:             Class<?>[] parameterTypes = method.getParameterTypes();
36:             Annotation[][] parameterAnnotations = method.getParameterAnnotations();
37:             for (int i = 0; i < parameterTypes.length; i++) {
38:                 Class<?> type = parameterTypes[i];
39:                 Annotation[] annotations = parameterAnnotations[i];
40:                 // 创建注解属性
41:                 AnnotationsAttribute attribute = new AnnotationsAttribute(classFile.getConstPool(), AnnotationsAttribute.visibleTag);
42:                 // 循环每个方法参数的每个注解
43:                 for (Annotation annotation : annotations) {
44:                     if (annotation.annotationType().isAnnotationPresent(Constraint.class)) { // 约束条件的注解，例如 @NotNull
45:                         javassist.bytecode.annotation.Annotation ja = new javassist.bytecode.annotation.Annotation(
46:                                 classFile.getConstPool(), pool.getCtClass(annotation.annotationType().getName()));
47:                         // 循环注解的每个方法
48:                         Method[] members = annotation.annotationType().getMethods();
49:                         for (Method member : members) {
50:                             if (Modifier.isPublic(member.getModifiers())
51:                                     && member.getParameterTypes().length == 0
52:                                     && member.getDeclaringClass() == annotation.annotationType()) {
53:                                 // 将注解，添加到类的属性上
54:                                 Object value = member.invoke(annotation);
55:                                 if (null != value) {
56:                                     MemberValue memberValue = createMemberValue(
57:                                             classFile.getConstPool(), pool.get(member.getReturnType().getName()), value);
58:                                     ja.addMemberValue(member.getName(), memberValue);
59:                                 }
60:                             }
61:                         }
62:                         attribute.addAnnotation(ja);
63:                     }
64:                 }
65:                 // 创建属性
66:                 String fieldName = method.getName() + "Argument" + i;
67:                 CtField ctField = CtField.make("public " + type.getCanonicalName() + " " + fieldName + ";", pool.getCtClass(parameterClassName));
68:                 ctField.getFieldInfo().addAttribute(attribute);
69:                 // 添加属性
70:                 ctClass.addField(ctField);
71:             }
72:             // 生成类
73:             parameterClass = ctClass.toClass(clazz.getClassLoader(), null);
74:         }
75:         // 创建 Bean 对象
76:         Object parameterBean = parameterClass.newInstance();
77:         // 设置 Bean 对象的每个属性的值
78:         for (int i = 0; i < args.length; i++) {
79:             Field field = parameterClass.getField(method.getName() + "Argument" + i);
80:             field.set(parameterBean, args[i]);
81:         }
82:         return parameterBean;
83:     } catch (Throwable e) {
84:         logger.warn(e.getMessage(), e);
85:         return null;
86:     }
87: }
```

- 第 13 至 15 行：调用 `#hasConstraintParameter(method)` 方法，判断是否有 **Constraint** 注解( 例如，`@NotNull` )的方法参数。若没有，则无需创建 Bean 对象。代码如下：

  ```
  private static boolean hasConstraintParameter(Method method) {
      Annotation[][] parameterAnnotations = method.getParameterAnnotations();
      // 循环所有方法参数的注解
      if (parameterAnnotations != null && parameterAnnotations.length > 0) {
          // 循环每个方法参数的注解数组
          for (Annotation[] annotations : parameterAnnotations) {
              // 是否有 Constraint 注解
              for (Annotation annotation : annotations) {
                  if (annotation.annotationType().isAnnotationPresent(Constraint.class)) {
                      return true;
                  }
              }
          }
      }
      return false;
  }
  ```

- 第 17 至 22 行：获得 Bean 类。

- 第 23 至 73 行：若 Bean 类**不存在**，使用 Javassist 动态编译生成。🙂 代码比较简单，已经添加详细注释，胖友耐心看看哈。其中，`#createMemberValue(ConstPool cp, CtClass type, Object value)` 方法，获得注解**每个属性的值**，代码如下：

  ```
  // Copy from javassist.bytecode.annotation.Annotation.createMemberValue(ConstPool, CtClass);
  private static MemberValue createMemberValue(ConstPool cp, CtClass type, Object value) throws NotFoundException {
      MemberValue memberValue = javassist.bytecode.annotation.Annotation.createMemberValue(cp, type);
      if (memberValue instanceof BooleanMemberValue) // Boolean
          ((BooleanMemberValue) memberValue).setValue((Boolean) value);
      else if (memberValue instanceof ByteMemberValue) // Byte
          ((ByteMemberValue) memberValue).setValue((Byte) value);
      else if (memberValue instanceof CharMemberValue) // Char
          ((CharMemberValue) memberValue).setValue((Character) value);
      else if (memberValue instanceof ShortMemberValue) // Short
          ((ShortMemberValue) memberValue).setValue((Short) value);
      else if (memberValue instanceof IntegerMemberValue) // Integer
          ((IntegerMemberValue) memberValue).setValue((Integer) value);
      else if (memberValue instanceof LongMemberValue) // Long
          ((LongMemberValue) memberValue).setValue((Long) value);
      else if (memberValue instanceof FloatMemberValue) // Float
          ((FloatMemberValue) memberValue).setValue((Float) value);
      else if (memberValue instanceof DoubleMemberValue)
          ((DoubleMemberValue) memberValue).setValue((Double) value);
      else if (memberValue instanceof ClassMemberValue) // Class
          ((ClassMemberValue) memberValue).setValue(((Class<?>) value).getName());
      else if (memberValue instanceof StringMemberValue) // String
          ((StringMemberValue) memberValue).setValue((String) value);
      else if (memberValue instanceof EnumMemberValue) // Enum
          ((EnumMemberValue) memberValue).setValue(((Enum<?>) value).name());
      /* else if (memberValue instanceof AnnotationMemberValue) */
      else if (memberValue instanceof ArrayMemberValue) { // 数组
          CtClass arrayType = type.getComponentType();
          int len = Array.getLength(value);
          // 循环，递归
          MemberValue[] members = new MemberValue[len];
          for (int i = 0; i < len; i++) {
              members[i] = createMemberValue(cp, arrayType, Array.get(value, i));
          }
          ((ArrayMemberValue) memberValue).setValue(members);
      }
      return memberValue;
  }
  ```

- 第 75 至 81 行：创建 Bean 对象，**设置 Bean 对象的每个属性的值**。

😈 又是一处，使用 Javassist 动态编译类的代码。好用！！！

#### 4.2 JValidation

`com.alibaba.dubbo.validation.support.jvalidation.JValidation` ，实现 AbstractValidation 抽象类，代码如下：

```
public class JValidation extends AbstractValidation {

    @Override
    protected Validator createValidator(URL url) {
        return new JValidator(url);
    }

}
```

## 

终于弄懂，为什么 JSR303 是 Java Bean Validation ，结果接口方法上，每个参数都添加 Constraint 的注解，结果也可以做校验。

推荐两篇文章：

- [《JSR 303 - Bean Validation 介绍及最佳实践》](https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/)
- [《Spring4新特性——集成Bean Validation 1.1(JSR-349)到SpringMVC》](http://jinnianshilongnian.iteye.com/blog/1990081)

