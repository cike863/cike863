# 抽象 API

## 1. 概述

在 [《精尽 Dubbo 源码分析 —— 项目结构一览》「3.5 dubbo-registry」](http://svip.iocoder.cn/Dubbo/registry-api/#) 中，对 `dubbo-registry` **注册中心**这个大模块做了大体的介绍。那么从本文开始，分享注册中心的代码实现。

本文分享 `dubbo-registry-api` 模块，注册中心的抽象 API ，类结构如下图：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_08_01/01.png)](http://static.iocoder.cn/images/Dubbo/2018_08_01/01.png)类图

😈 整体比较易懂，笔者在这里先不介绍，胖友可以看完本文，回过头看看，自己是不是理解了？！

下面，我们按照从左到右的顺序，逐个分享。

## 2. RegistryFactory

[`com.alibaba.dubbo.registry.RegistryFactory`](https://github.com/YunaiV/dubbo/blob/7ece72959dd8c96e17fc240a2b22b40391265bcc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/RegistryFactory.java) ，注册中心工厂**接口**，代码如下：

```
@SPI("dubbo")
public interface RegistryFactory {

    /**
     * 连接注册中心.
     * <p>
     * 连接注册中心需处理契约：<br>
     * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。<br>
     * 2. 支持URL上的username:password权限认证。<br>
     * 3. 支持backup=10.20.153.10备选注册中心集群地址。<br>
     * 4. 支持file=registry.cache本地磁盘文件缓存。<br>
     * 5. 支持timeout=1000请求超时设置。<br>
     * 6. 支持session=60000会话超时或过期设置。<br>
     *
     * @param url 注册中心地址，不允许为空
     * @return 注册中心引用，总不返回空
     */
    @Adaptive({"protocol"})
    Registry getRegistry(URL url);

}
```

- RegistryFactory 是一个 Dubbo SPI 拓展接口。

- ```
  #getRegistry(url)
  ```

   

  方法，获得注册中心 Registry 对象。

  - 注意方法上注释的**处理契约**。
  - `@Adaptive({"protocol"})` 注解，Dubbo SPI 会自动实现 RegistryFactory$Adaptive 类，根据 `url.protocol` 获得对应的 RegistryFactory 实现类。例如，`url.protocol = zookeeper` 时，获得 ZookeeperRegistryFactory 实现类。

#### 2.1 AbstractRegistryFactory

[`com.alibaba.dubbo.registry.support.AbstractRegistryFactory`](https://github.com/YunaiV/dubbo/blob/7ece72959dd8c96e17fc240a2b22b40391265bcc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/AbstractRegistryFactory.java) ，实现 RegistryFactory 接口，RegistryFactory 抽象类，实现了 Registry 的**容器管理**。

###### 2.1.1 属性

```
// The lock for the acquisition process of the registry
private static final ReentrantLock LOCK = new ReentrantLock();

/**
 * Registry 集合
 *
 * key：{@link URL#toServiceString()}
 */
// Registry Collection Map<RegistryAddress, Registry>
private static final Map<String, Registry> REGISTRIES = new ConcurrentHashMap<String, Registry>();
```

- `REGISTRIES` 静态属性，Registry 集合。
- `LOCK` 静态属性，锁，用于 `#destroyAll()` 和 `#getRegistry(url)` 方法，对 `REGISTRIES` 访问的竞争。

###### 2.1.2 createRegistry

`#createRegistry(url)` **抽象**方法，创建 Registry 对象。代码如下：

```
/**
 * 创建 Registry 对象
 *
 * @param url 注册中心地址
 * @return Registry 对象
 */
protected abstract Registry createRegistry(URL url);
```

子类实现该方法，创建其对应的 Registry 实现类。例如，ZookeeperRegistryFactory 的该方法，创建 ZookeeperRegistry 对象。

###### 2.1.3 getRegistry

[`#getRegistry(url)`](https://github.com/YunaiV/dubbo/blob/d7c9cec324901c8285e602fdd3256cc9f5586357/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/AbstractRegistryFactory.java#L96-L132) **实现**方法，获得注册中心 Registry 对象。优先从缓存中获取，否则进行创建。

- 🙂 实现比较易懂，点击链接查看，有代码注释。

###### 2.1.4 destroyAll

[`#destroyAll()`](https://github.com/YunaiV/dubbo/blob/d7c9cec324901c8285e602fdd3256cc9f5586357/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/AbstractRegistryFactory.java#L65-L94) 方法，销毁所有 Registry 对象。

- 🙂 实现比较易懂，点击链接查看，有代码注释。

## 3. RegistryService

[`com.alibaba.dubbo.registry.RegistryService`](https://github.com/YunaiV/dubbo/blob/f2458c11b045f85f654ed1719c75f9b0ba6397fe/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/RegistryService.java) ，注册中心服务**接口**，定义了注册、订阅、查询**三种**操作方法，如下：

- ```
  #register(url)
  ```

   

  方法，

  注册

  数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。

  - `#unregister(url)` 方法，取消注册。

- `#subscribe(url, NotifyListener)` 方法，**订阅**符合条件的已注册数据，当有注册数据变更时自动推送。

  - `#unsubscribe(url, NotifyListener)` 方法，取消订阅。

  - 在

     

    ```
    URL.parameters.category
    ```

     

    属性上，表示订阅的数据分类。目前有四种类型：

    - `consumers` ，服务消费者列表。
    - `providers` ，服务提供者列表。
    - `routers` ，[路由规则](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html)列表。
    - `configurations` ，[配置规则](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html)列表。

- `#lookup(url)` 方法，**查询**符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。

ps：注意方法上注释的处理契约。

#### 3.1 Registry

[`com.alibaba.dubbo.registry.Registry`](https://github.com/YunaiV/dubbo/blob/f2458c11b045f85f654ed1719c75f9b0ba6397fe/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/Registry.java) ，注册中心**接口**。Registry 继承了：

- RegistryService 接口，拥有拥有注册、订阅、查询三种操作方法。
- [`com.alibaba.dubbo.common.Node`](https://github.com/YunaiV/dubbo/blob/f2458c11b045f85f654ed1719c75f9b0ba6397fe/dubbo-common/src/main/java/com/alibaba/dubbo/common/Node.java) 接口，拥有节点相关的方法。

#### 3.2 AbstractRegistry

[`com.alibaba.dubbo.registry.support.AbstractRegistry`](http://svip.iocoder.cn/Dubbo/registry-api/) ，实现 Registry 接口，Registry 抽象类，实现了如下方法：

- 通用的注册、订阅、查询、通知等方法。
- 持久化注册数据到文件，以 properties 格式存储。应用于，重启时，无法从注册中心加载服务提供者列表等信息时，从该文件中读取。

###### 3.2.1 属性

```
 1: // URL地址分隔符，用于文件缓存中，服务提供者URL分隔
 2: // URL address separator, used in file cache, service provider URL separation
 3: private static final char URL_SEPARATOR = ' ';
 4: // URL地址分隔正则表达式，用于解析文件缓存中服务提供者URL列表
 5: // URL address separated regular expression for parsing the service provider URL list in the file cache
 6: private static final String URL_SPLIT = "\\s+";
 7: 
 8: // Log output
 9: protected final Logger logger = LoggerFactory.getLogger(getClass());
10: /**
11:  *  本地磁盘缓存。
12:  *
13:  *  1. 其中特殊的 key 值 .registies 记录注册中心列表
14:  *  2. 其它均为 {@link #notified} 服务提供者列表
15:  */
16: // Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers
17: private final Properties properties = new Properties();
18: /**
19:  * 注册中心缓存写入执行器。
20:  *
21:  * 线程数=1
22:  */
23: // File cache timing writing
24: private final ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory("DubboSaveRegistryCache", true));
25: /**
26:  * 是否同步保存文件
27:  */
28: // Is it synchronized to save the file
29: private final boolean syncSaveFile;
30: /**
31:  * 数据版本号
32:  *
33:  * {@link #properties}
34:  */
35: private final AtomicLong lastCacheChanged = new AtomicLong();
36: /**
37:  * 已注册 URL 集合。
38:  *
39:  * 注意，注册的 URL 不仅仅可以是服务提供者的，也可以是服务消费者的
40:  */
41: private final Set<URL> registered = new ConcurrentHashSet<URL>();
42: /**
43:  * 订阅 URL 的监听器集合
44:  *
45:  * key：消费者的 URL ，例如消费者的 URL
46:  */
47: private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();
48: /**
49:  * 被通知的 URL 集合
50:  *
51:  * key1：消费者的 URL ，例如消费者的 URL ，和 {@link #subscribed} 的键一致
52:  * key2：分类，例如：providers、consumers、routes、configurators。【实际无 consumers ，因为消费者不会去订阅另外的消费者的列表】
53:  *            在 {@link Constants} 中，以 "_CATEGORY" 结尾
54:  */
55: private final ConcurrentMap<URL, Map<String, List<URL>>> notified = new ConcurrentHashMap<URL, Map<String, List<URL>>>();
56: /**
57:  * 注册中心 URL
58:  */
59: private URL registryUrl;
60: /**
61:  * 本地磁盘缓存文件，缓存注册中心的数据
62:  */
63: // Local disk cache file
64: private File file;
65: /**
66:  * 是否销毁
67:  */
68: private AtomicBoolean destroyed = new AtomicBoolean(false);
69: 
70: public AbstractRegistry(URL url) {
71:     setUrl(url);
72:     // Start file save timer
73:     syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);
74:     // 获得 `file`
75:     String filename = url.getParameter(Constants.FILE_KEY, System.getProperty("user.home") + "/.dubbo/dubbo-registry-" + url.getParameter(Constants.APPLICATION_KEY) + "-" + url.getAddress() + ".cache");
76:     File file = null;
77:     if (ConfigUtils.isNotEmpty(filename)) {
78:         file = new File(filename);
79:         if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {
80:             if (!file.getParentFile().mkdirs()) {
81:                 throw new IllegalArgumentException("Invalid registry store file " + file + ", cause: Failed to create directory " + file.getParentFile() + "!");
82:             }
83:         }
84:     }
85:     this.file = file;
86:     // 加载本地磁盘缓存文件到内存缓存
87:     loadProperties();
88:     // 通知监听器，URL 变化结果
89:     notify(url.getBackupUrls());
90: }
```

- `file` 属性，*见代码注释*。

- ```
  properties
  ```

   

  属性，

  见代码注释

  。

  - 数据流向
    - 启动时，从 `file` 读取数据到 `properties` 中。
    - 注册中心数据发生变更时，通知到 Registry 后，修改 `properties` 对应的值，并写入 `file` 。
  - 数据键值
    - 大多数情况下，键为服务消费者的 URL 的服务键( `URL#serviceKey()` )，对应的值为服务提供者列表、[路由规则](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html)列表、[配置规则](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html)列表。
    - 特殊情况下，【TODO 8019】.registies
    - 因为值会存在为列表的情况，使用空格( `URL_SEPARATOR` ) 分隔。

- `syncSaveFile` 属性，`properties` 发生变更时候，是同步还是异步写入 `file` 。

- `registryCacheExecutor` 属性，*见代码注释*。

- ```
  lastCacheChanged
  ```

   

  属性，

  见代码注释

  。

  - 因为每次写入 `file` 是全量，而不是增量写入，通过版本号，避免老版本覆盖新版本。

- `registered` 属性，*见代码注释*。

- `subscribed` 属性，*见代码注释*。

- ```
  notified
  ```

   

  属性，

  见代码注释

  。

  - 从数据上，和 `properties` 比较相似。笔者认为有两点差异：1）数据格式上，`notified` 根据**分类**做了聚合；2）不从 `file` 中读取，都是从注册中心读取的数据。

- `registryUrl` 属性，*见代码注释*。

- `destroyed` 属性，*见代码注释*。

- 构造方法

  ，

  见代码注释

  。

  - 第 87 行：调用

     

    `#loadProperties()`

     

    方法，加载本地磁盘缓存文件到内存缓存。

    - 🙂 代码比较简单，点击链接查看。

  - 第 89 行：// 【TODO 8020】为什么构造方法，要通知，连监听器都没注册

###### 3.2.2 register && unregister

- `#register(url)`
  - 从实现上，我们可以看出，并未向注册中心发起注册，仅仅是添加到 `registered` 中，进行状态的维护。实际上，真正的实现在 FailbackRegistry 类中。
- `#unregister(url)`
  - 和 `#register(url)` 的**处理方式**相同。

###### 3.2.3 subscribe && unsubscribe

- `#subscribe(url, listener)`
  - 和 `#register(url)` 的**处理方式**相同。
- `#unsubscribe(url, listener)`
  - 和 `#register(url)` 的**处理方式**相同。

###### 3.2.4 notify

[`#notify(url, listener, urls)`](https://github.com/YunaiV/dubbo/blob/06155d670fd1331fa1d2f41f7050338f9e9502c5/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/AbstractRegistry.java#L477-L535) 方法，通知监听器，URL 变化结果。这里我们有两点要注意下：

- 第一，向注册中心发起订阅后，会获取到**全量**数据，此时会被调用 `#notify(...)` 方法，即 Registry 获取到了全量数据。
- 第二，每次注册中心发生变更时，会调用 `#notify(...)` 方法，虽然变化是**增量**，调用这个方法的调用方，已经进行处理，传入的 `urls` 依然是**全量**的。

代码如下：

```
 1: /**
 2:  * 通知监听器，URL 变化结果。
 3:  *
 4:  * 数据流向 `urls` => {@link #notified} => {@link #properties} => {@link #file}
 5:  *
 6:  * @param url 消费者 URL
 7:  * @param listener 监听器
 8:  * @param urls 通知的 URL 变化结果（全量数据）
 9:  */
10: protected void  notify(URL url, NotifyListener listener, List<URL> urls) {
11:     if (url == null) {
12:         throw new IllegalArgumentException("notify url == null");
13:     }
14:     if (listener == null) {
15:         throw new IllegalArgumentException("notify listener == null");
16:     }
17:     if ((urls == null || urls.isEmpty())
18:             && !Constants.ANY_VALUE.equals(url.getServiceInterface())) {
19:         logger.warn("Ignore empty notify urls for subscribe url " + url);
20:         return;
21:     }
22:     if (logger.isInfoEnabled()) {
23:         logger.info("Notify urls for subscribe url " + url + ", urls: " + urls);
24:     }
25:     // 将 `urls` 按照 `url.parameter.category` 分类，添加到集合
26:     Map<String, List<URL>> result = new HashMap<String, List<URL>>();
27:     for (URL u : urls) {
28:         if (UrlUtils.isMatch(url, u)) {
29:             String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
30:             List<URL> categoryList = result.get(category);
31:             if (categoryList == null) {
32:                 categoryList = new ArrayList<URL>();
33:                 result.put(category, categoryList);
34:             }
35:             categoryList.add(u);
36:         }
37:     }
38:     if (result.size() == 0) {
39:         return;
40:     }
41:     // 获得消费者 URL 对应的在 `notified` 中，通知的 URL 变化结果（全量数据）
42:     Map<String, List<URL>> categoryNotified = notified.get(url);
43:     if (categoryNotified == null) {
44:         notified.putIfAbsent(url, new ConcurrentHashMap<String, List<URL>>());
45:         categoryNotified = notified.get(url);
46:     }
47:     // 处理通知的 URL 变化结果（全量数据）
48:     for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
49:         String category = entry.getKey();
50:         List<URL> categoryList = entry.getValue();
51:         // 覆盖到 `notified`
52:         // 当某个分类的数据为空时，会依然有 urls 。其中 `urls[0].protocol = empty` ，通过这样的方式，处理所有服务提供者为空的情况。
53:         categoryNotified.put(category, categoryList);
54:         // 保存到文件
55:         saveProperties(url);
56:         // 通知监听器
57:         listener.notify(categoryList);
58:     }
59: }
```

- 第 25 至 37 行：将

   

  ```
  urls
  ```

   

  按照

   

  ```
  url.parameter.category
  ```

   

  分类，添加到集合

   

  ```
  result
  ```

   

  中。

  - 第 28 行：TODO 芋艿
  - 这里有一点要注意，每次传入的 `urls` 的“**全量**”，指的是至少要是**一个分类**的全量，而不一定是全部数据。

- 第 41 至 46 行：获得消费者 URL 对应的在 `notified` 中的数据。

- 第 47 至 58 行：按照

  分类

  ，循环处理通知的 URL 变化结果（全量数据）。

  - 第 51 至 53 行：将 `result` 覆盖到 `notified` 中。这里又有一点需要注意，当某个分类的数据为空时，会依然有 `urls` 。其中 `urls[0].protocol = empty` ，通过这样的方式，处理**所有服务提供者为空**的情况。

  - 第 55 行：调用

     

    `#saveProperties(url)`

     

    方法，保存到文件。

    - 🙂 代码比较简单，点击链接查看。

  - 第 57 行：调用 `NotifyListener#notify(urls)` 方法，通知监听器处理。例如，有新的服务提供者启动时，被通知，创建新的 Invoker 对象。

###### 3.2.5 recover

- `#recover()`
  - 和 `#register(url)` 的**处理方式**相同。

在注册中心断开，重连成功，调用 `#recover()` 方法，进行恢复注册和订阅。

###### 3.2.6 destroy

- `#destroy()`
  - 和 `#register(url)` 的**处理方式**相同。

在 JVM 关闭时，调用 `#destroy()` 方法，进行取消注册和订阅。

#### 3.3 FailbackRegistry

[`com.alibaba.dubbo.registry.support.FailbackRegistry`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/AbstractRegistry.java) ，实现 AbstractRegistry 抽象类，支持失败重试的 Registry 抽象类。

在上文中的代码中，我们可以看到，AbstractRegistry 进行的注册、订阅等操作，更多的是修改状态，而无和注册中心实际的操作。FailbackRegistry 在 AbstractRegistry 的基础上，实现了和注册中心实际的操作，并且支持失败重试的特性。

###### 3.3.1 属性

```
 1: /**
 2:  * 定时任务执行器
 3:  */
 4: // Scheduled executor service
 5: private final ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory("DubboRegistryFailedRetryTimer", true));
 6: 
 7: /**
 8:  * 失败重试定时器，定时检查是否有请求失败，如有，无限次重试
 9:  */
10: // Timer for failure retry, regular check if there is a request for failure, and if there is, an unlimited retry
11: private final ScheduledFuture<?> retryFuture;
12: /**
13:  * 失败发起注册失败的 URL 集合
14:  */
15: private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();
16: /**
17:  * 失败取消注册失败的 URL 集合
18:  */
19: private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();
20: /**
21:  * 失败发起订阅失败的监听器集合
22:  */
23: private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();
24: /**
25:  * 失败取消订阅失败的监听器集合
26:  */
27: private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();
28: /**
29:  * 失败通知通知的 URL 集合
30:  */
31: private final ConcurrentMap<URL, Map<NotifyListener, List<URL>>> failedNotified = new ConcurrentHashMap<URL, Map<NotifyListener, List<URL>>>();
32: /**
33:  * 是否销毁
34:  */
35: private AtomicBoolean destroyed = new AtomicBoolean(false);
36: 
37: public FailbackRegistry(URL url) {
38:     super(url);
39:     // 重试频率，单位：毫秒
40:     int retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);
41:     // 创建失败重试定时器
42:     this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() {
43:         public void run() {
44:             // Check and connect to the registry
45:             try {
46:                 retry();
47:             } catch (Throwable t) { // Defensive fault tolerance
48:                 logger.error("Unexpected error occur at failed retry, cause: " + t.getMessage(), t);
49:             }
50:         }
51:     }, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);
52: }
```

- `retryExecutor` 属性，*见代码注释*。

- ```
  retryFuture
  ```

   

  属性，

  见代码注释

  。

  - 第 41 至 51 行，在构造方法中创建该定时器，在其 `#run()` 方法中，会调用 `#retry()` 方法，进行重试。

- ```
  failedXXX
  ```

   

  属性，

  见代码注释

  。

  - 每种操作都有一个记录失败的集合。

- `destroyed` 属性，*见代码注释*。

###### 3.3.2 register && unregister

- [`#register(url)`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L162-L199)
- [`#unregister(url)`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L201-L238)

> 代码比较易懂，点击链接查看。

###### 3.3.3 subscribe && unsubscribe

- [`#subscribe(url, listener)`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L240-L282)
- [`#unsubscribe(url, listener)`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L284-L324)

> 代码比较易懂，点击链接查看。

###### 3.3.4 notify

- [`#notify(url, listener, url)`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L326-L352)

> 代码比较易懂，点击链接查看。

###### 3.3.5 recover

- [`#recover()`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L354-L379) 方法，**完全覆盖父类方法**( 即不像前面几个方法，会调用父类的方法 )，将需要注册和订阅的 URL 添加到 `failedRegistered` `failedSubscribed` 属性中。这样，在 `#retry()` 方法中，会重试进行连接。

> 代码比较易懂，点击链接查看。

###### 3.3.6 retry

- [`#retry()`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L381-L528) 方法，遍历五个 `failedXXX` 属性，重试对应的操作。

> 代码比较易懂，点击链接查看。

###### 3.3.7 destroy

- [`#destroy()`](https://github.com/YunaiV/dubbo/blob/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/FailbackRegistry.java#L530-L541) 方法，取消注册和订阅，并关闭定时器。

> 代码比较易懂，点击链接查看。

## 4. NotifyListener

[`com.alibaba.dubbo.registry.NotifyListener`](https://github.com/YunaiV/dubbo/blob/da5ebc2737d560dc0fe308793780695c6afc5fda/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/NotifyListener.java) ，通知监听器。当收到服务变更通知时触发，代码如下：

```
public interface NotifyListener {

    /**
     * 当收到服务变更通知时触发。
     * <p>
     * 通知需处理契约：<br>
     * 1. 总是以服务接口和数据类型为维度全量通知，即不会通知一个服务的同类型的部分数据，用户不需要对比上一次通知结果。<br>
     * 2. 订阅时的第一次通知，必须是一个服务的所有类型数据的全量通知。<br>
     * 3. 中途变更时，允许不同类型的数据分开通知，比如：providers, consumers, routers, overrides，允许只通知其中一种类型，但该类型的数据必须是全量的，不是增量的。<br>
     * 4. 如果一种类型的数据为空，需通知一个empty协议并带category参数的标识性URL数据。<br>
     * 5. 通知者(即注册中心实现)需保证通知的顺序，比如：单线程推送，队列串行化，带版本对比。<br>
     *
     * @param urls 已注册信息列表，总不为空，含义同{@link com.alibaba.dubbo.registry.RegistryService#lookup(URL)}的返回值。
     */
    void notify(List<URL> urls);

}
```

- 注意看方法上的注释，特别是**全量**、**分类**、**为空**、**顺序**。

NotifyListener 的子类如下图：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_08_01/02.png)](http://static.iocoder.cn/images/Dubbo/2018_08_01/02.png)类图

## 5. ProviderConsumerRegTable

[`com.alibaba.dubbo.registry.support.ProviderConsumerRegTable`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java) ，服务提供者和消费者注册表，存储 JVM 进程内**自己**的服务提供者和消费者的 Invoker 。

该信息用于 [Dubbo QOS](http://dubbo.apache.org/zh-cn/docs/user/references/qos.html) 使用，例如将 JVM 进程中，**自己**的服务提供者下线，又或者查询自己的服务提供者和消费者列表。

- [《Dubbo 用户指南 —— 在线运维命令 - QOS》](http://dubbo.apache.org/zh-cn/docs/user/references/qos.html)
- 后续会有文章分享 QOS ，本文不多啰嗦。

代码如下：

```
public class ProviderConsumerRegTable {

    /**
     * 服务提供者 Invoker 集合
     *
     * key：服务提供者 URL 服务键
     */
    public static ConcurrentHashMap<String, Set<ProviderInvokerWrapper>> providerInvokers = new ConcurrentHashMap<String, Set<ProviderInvokerWrapper>>();
    /**
     * 服务消费者 Invoker 集合
     *
     * key：服务消费者 URL 服务键
     */
    public static ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>> consumerInvokers = new ConcurrentHashMap<String, Set<ConsumerInvokerWrapper>>();
    
    // .... 省略方法
    
}
```

- 如下方法，已经添加代码注释，胖友点击查看。
- 服务提供者
  - [`#registerProvider(invoker, registryUrl, providerUrl)`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java#L51-L70) 静态方法，注册 Provider Invoker 。
  - [`#getProviderInvoker(serviceUniqueName)`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java#L72-L84) 静态静态，获得指定服务键的 Provider Invoker 集合。
  - [`#getProviderWrapper(invoker)`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java#L86-L112) 静态方法，获得服务提供者对应的 Invoker Wrapper 对象。
- 服务消费者
  - [`#registerConsumer(invoker, registryUrl, consumerUrl, registryDirectory)`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java#L114-L134) 静态方法，注册 Consumer Invoker 。
  - [`#getConsumerInvoker(serviceUniqueName)`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderConsumerRegTable.java#L136-L148) 静态方法，获得指定服务键的 Consumer Invoker 集合。

#### 5.1 ProviderInvokerWrapper

[`com.alibaba.dubbo.registry.support.ProviderInvokerWrapper`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ProviderInvokerWrapper.java) ，实现 Invoker 接口，服务提供者 Invoker Wrapper ，代码如下：

```
/**
 * Invoker 对象
 */
private Invoker<T> invoker;
/**
 * 原始 URL
 */
private URL originUrl;
/**
 * 注册中心 URL
 */
private URL registryUrl;
/**
 * 服务提供者 URL
 */
private URL providerUrl;
/**
 * 是否注册
 */
private volatile boolean isReg;
    
// ... 省略方法
```

- 相比纯粹的 Invoker 对象，又多了运维命令需要的属性。例如 `isReg` **状态**属性，可以在使用**下线服务命令**后，标记为 `false` 。想提前深入了解的胖友，可以看下 [`com.alibaba.dubbo.qos.command.impl.Offline`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-plugin/dubbo-qos/src/main/java/com/alibaba/dubbo/qos/command/impl/Online.java) 和 [`com.alibaba.dubbo.qos.command.impl.Online`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-plugin/dubbo-qos/src/main/java/com/alibaba/dubbo/qos/command/impl/Online.java) 类。

#### 5.2 ConsumerInvokerWrapper

[`com.alibaba.dubbo.registry.support.ConsumerInvokerWrapper`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/support/ConsumerInvokerWrapper.java) ，实现 Invoker 接口，服务消费者 Invoker Wrapper ，代码如下：

```
/**
 * Invoker 对象
 */
private Invoker<T> invoker;
/**
 * 原始 URL
 */
private URL originUrl;
/**
 * 注册中心 URL
 */
private URL registryUrl;
/**
 * 消费者 URL
 */
private URL consumerUrl;
/**
 * 注册中心 Directory
 */
private RegistryDirectory registryDirectory;
```

- 相比纯粹的 Invoker 对象，又多了运维命令需要的属性。例如 `registryDirectory` 属性，可以在使用**列出消费者和提供者命令**后，输出可消费者**可调用**的服务提供者数量 。想提前深入了解的胖友，可以看下 [`com.alibaba.dubbo.qos.command.impl.Ls`](https://github.com/YunaiV/dubbo/blob/703764e6e82a72ddca7401c9302781e69c453f8e/dubbo-plugin/dubbo-qos/src/main/java/com/alibaba/dubbo/qos/command/impl/Ls.java) 类。

## 5. integration

不同于上面我们看到的代码，[`integration`](https://github.com/YunaiV/dubbo/tree/414a4799cef08f0b5263d838eeaf8d8f169f2cdc/dubbo-registry/dubbo-registry-api/src/main/java/com/alibaba/dubbo/registry/integration) 包下是对其他 Dubbo 模块的集成：

- RegistryProtocol ，对 `dubbo-rpc-api` 的依赖集成。
- RegistryDirectory ，对 `dubbo-cluster` 的依赖集成。

考虑到超出了本文的范畴，后面涉及到时，单独分享。

# Zookeeper

## 1. 概述

前置阅读文章：

- [《精尽 Dubbo 源码分析 —— Zookeeper 客户端》](http://svip.iocoder.cn/Dubbo/remoting-zookeeper/?self)
- [《精尽 Dubbo 源码分析 —— 注册中心（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/registry-api/?self)

😈 在《注册中心（一）之抽象 API》 中，我们分享的那是**相当抽象**。因此，在本文中，我们会分享 Dubbo 使用 Zookeeper 作为注册中心的代码，同时也会分享服务暴露和引用时，对注册中心的使用。

下面，我们先来看下 [《Dubbo 用户指南 —— zookeeper 注册中心》](http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html) 文档，内容如下：

> [![流程](http://static.iocoder.cn/images/Dubbo/2018_08_04/01.png)](http://static.iocoder.cn/images/Dubbo/2018_08_04/01.png)流程
>
> 流程说明：
>
> - **服务提供者**启动时: 向 `/dubbo/com.foo.BarService/providers` 目录下写入自己的 URL 地址
> - **服务消费者**启动时: 订阅 `/dubbo/com.foo.BarService/providers` 目录下的提供者 URL 地址。并向 `/dubbo/com.foo.BarService/consumers` 目录下写入自己的 URL 地址
> - **监控中心**启动时: 订阅 `/dubbo/com.foo.BarService` 目录下的所有提供者和消费者 URL 地址。

- 在图中，我们可以看到 Zookeeper 的节点层级，自上而下是：
  - **Root** 层：根目录，可通过 `<dubbo:registry group="dubbo" />` 的 `"group"` 设置 Zookeeper 的根节点，缺省使用 `"dubbo"` 。
  - **Service** 层：服务接口全名。
  - **Type** 层：分类。目前除了我们在图中看到的 `"providers"`( 服务提供者列表 ) `"consumers"`( 服务消费者列表 ) 外，还有 [`"routes"`](http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html)( 路由规则列表 ) 和 [`"configurations"`](http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html)( 配置规则列表 )。
  - **URL** 层：URL ，根据不同 Type 目录，下面可以是服务提供者 URL 、服务消费者 URL 、路由规则 URL 、配置规则 URL 。
  - 实际上 URL 上带有 `"category"` 参数，已经能判断每个 URL 的分类，但是 Zookeeper 是基于节点目录订阅的，所以增加了 **Type** 层。
- 实际上，**服务消费者**启动后，不仅仅订阅了 `"providers"` 分类，也订阅了 `"routes"` `"configurations"` 分类。

## 2. ZookeeperRegistryFactory

[`com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory`](https://github.com/YunaiV/dubbo/blob/66a1e1b0ef4b01175be148d27fdcf519f4f01b15/dubbo-registry/dubbo-registry-zookeeper/src/main/java/com/alibaba/dubbo/registry/zookeeper/ZookeeperRegistryFactory.java) ，实现 AbstractRegistryFactory 抽象类，Zookeeper Registry 工厂。代码如下：

```
public class ZookeeperRegistryFactory extends AbstractRegistryFactory {

    /**
     * Zookeeper 工厂
     */
    private ZookeeperTransporter zookeeperTransporter;

    /**
     * 设置 Zookeeper 工厂
     *
     * 该方法，通过 Dubbo SPI 注入
     *
     * @param zookeeperTransporter Zookeeper 工厂对象
     */
    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) {
        this.zookeeperTransporter = zookeeperTransporter;
    }

    @Override
    public Registry createRegistry(URL url) {
        return new ZookeeperRegistry(url, zookeeperTransporter);
    }

}
```

## 3. ZookeeperRegistry

[`com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry`](https://github.com/YunaiV/dubbo/blob/66a1e1b0ef4b01175be148d27fdcf519f4f01b15/dubbo-registry/dubbo-registry-zookeeper/src/main/java/com/alibaba/dubbo/registry/zookeeper/ZookeeperRegistry.java) ，实现 FailbackRegistry 抽象类，Zookeeper Registry 。

#### 3.1 属性 + 构造方法

```
 1: /**
 2:  * 默认端口
 3:  */
 4: private final static int DEFAULT_ZOOKEEPER_PORT = 2181;
 5: /**
 6:  * 默认 Zookeeper 根节点
 7:  */
 8: private final static String DEFAULT_ROOT = "dubbo";
 9: 
10: /**
11:  * Zookeeper 根节点
12:  */
13: private final String root;
14: /**
15:  * Service 接口全名集合
16:  */
17: private final Set<String> anyServices = new ConcurrentHashSet<String>();
18: /**
19:  * 监听器集合
20:  */
21: private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>> zkListeners = new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();
22: /**
23:  * Zookeeper 客户端
24:  */
25: private final ZookeeperClient zkClient;
26: 
27: public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
28:     super(url);
29:     if (url.isAnyHost()) {
30:         throw new IllegalStateException("registry address == null");
31:     }
32:     // 获得 Zookeeper 根节点
33:     String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT); // `url.parameters.group` 参数值
34:     if (!group.startsWith(Constants.PATH_SEPARATOR)) {
35:         group = Constants.PATH_SEPARATOR + group;
36:     }
37:     this.root = group;
38:     // 创建 Zookeeper Client
39:     zkClient = zookeeperTransporter.connect(url);
40:     // 添加 StateListener 对象。该监听器，在重连时，调用恢复方法。
41:     zkClient.addStateListener(new StateListener() {
42:         public void stateChanged(int state) {
43:             if (state == RECONNECTED) {
44:                 try {
45:                     recover();
46:                 } catch (Exception e) {
47:                     logger.error(e.getMessage(), e);
48:                 }
49:             }
50:         }
51:     });
52: }
```

- `root` 属性，Zookeeper 根节点，即首图的 **Root** 层。
- `anyServices` 属性，Service 接口接口全名**集合**。该属性适可用于监控中心，订阅**整个** **Service** 层。因为，Service 层是**动态**的，可以有不断有新的 Service 服务发布（注意，不是服务实例）。在 `#doSubscribe(url, notifyListener)` 方法中，会更容易理解。
- `zkListeners` 属性，监听器集合，建立 NotifyListener 和 ChildListener 的映射关系。
- `zkClient` 属性，Zookeeper 客户端。
- 构造方法
  - 第 28 至 31 行：设置注册中心的 URL 。
  - 第 32 至 37 行：设置在 Zookeeper 的根节点，缺省使用 `DEFAULT_ROOT` 。
  - 第 39 行：调用 `ZookeeperTransporter#connect(url)` 方法，基于 Dubbo SPI Adaptive 机制，根据 `url` 参数，加载对应的 ZookeeperTransporter 实现类，创建对应的 ZookeeperClient 实现类的对应。
  - 第 41 至 51 行：添加 StateListener 对象到 ZookeeperClient 对象中。该监听器，在重连时，在第 45 行的代码，调用 `#recover()` 方法，进行恢复逻辑，重新发起注册和订阅。

#### 3.2 doRegister

```
1: @Override
2: protected void doRegister(URL url) {
3:     try {
4:         zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));
5:     } catch (Throwable e) {
6:         throw new RpcException("Failed to register " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
7:     }
8: }
```

- 第 4 行：调用 `#toUrlPath(url)` 方法，获得 URL 的路径。
- 第 4 行：`url.parameters.dynamic` ，是否动态数据。若为 false ，该数据为**持久数据**，当注册方退出时，数据依然保存在注册中心。
- 第 4 行：调用 `ZookeeperClient#create(url, ephemeral)` 方法，创建 URL 节点，即我们在首图看到的 **URL 层**。

###### 3.2.1 toUrlPath

```
/**
 * 获得 URL 的路径
 *
 * Root + Service + Type + URL
 *
 * 被 {@link #doRegister(URL)} 和 {@link #doUnregister(URL)} 调用
 *
 * @param url URL
 * @return 路径
 */
private String toUrlPath(URL url) {
    return toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());
}
```

###### 3.2.2 toCategoryPath

```
/**
 * 获得分类路径
 *
 * Root + Service + Type
 *
 * @param url URL
 * @return 分类路径
 */
private String toCategoryPath(URL url) {
    return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
}
```

###### 3.2.3 toServicePath

```
/**
 * 获得服务路径
 *
 * Root + Type
 *
 * @param url URL
 * @return 服务路径
 */
private String toServicePath(URL url) {
    String name = url.getServiceInterface();
    if (Constants.ANY_VALUE.equals(name)) {
        return toRootPath();
    }
    return toRootDir() + URL.encode(name);
}
```

###### 3.2.4 toRootDir

```
/**
 * 获得根目录
 *
 * Root
 *
 * @return 路径
 */
private String toRootDir() {
    if (root.equals(Constants.PATH_SEPARATOR)) {
        return root;
    }
    return root + Constants.PATH_SEPARATOR;
}

/**
 * Root
 *
 * @return 根路径
 */
private String toRootPath() {
    return root;
}
```

#### 3.3 doUnregister

```
@Override
protected void doUnregister(URL url) {
    try {
        zkClient.delete(toUrlPath(url));
    } catch (Throwable e) {
        throw new RpcException("Failed to unregister " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

#### 3.4 doSubscribe

```
 1: @Override
 2: protected void doSubscribe(final URL url, final NotifyListener listener) {
 3:     try {
 4:         // 处理所有 Service 层的发起订阅，例如监控中心的订阅
 5:         if (Constants.ANY_VALUE.equals(url.getServiceInterface())) {
 6:             String root = toRootPath();
 7:             // 获得 url 对应的监听器集合
 8:             ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
 9:             if (listeners == null) { // 不存在，进行创建
10:                 zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
11:                 listeners = zkListeners.get(url);
12:             }
13:             // 获得 ChildListener 对象
14:             ChildListener zkListener = listeners.get(listener);
15:             if (zkListener == null) { // 不存在 ChildListener 对象，进行创建 ChildListener 对象
16:                 listeners.putIfAbsent(listener, new ChildListener() {
17:                     public void childChanged(String parentPath, List<String> currentChilds) {
18:                         for (String child : currentChilds) {
19:                             child = URL.decode(child);
20:                             // 新增 Service 接口全名时（即新增服务），发起该 Service 层的订阅
21:                             if (!anyServices.contains(child)) {
22:                                 anyServices.add(child);
23:                                 subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child,
24:                                         Constants.CHECK_KEY, String.valueOf(false)), listener);
25:                             }
26:                         }
27:                     }
28:                 });
29:                 zkListener = listeners.get(listener);
30:             }
31:             // 创建 Service 节点。该节点为持久节点。
32:             zkClient.create(root, false);
33:             // 向 Zookeeper ，Service 节点，发起订阅
34:             List<String> services = zkClient.addChildListener(root, zkListener);
35:             // 首次全量数据获取完成时，循环 Service 接口全名数组，发起该 Service 层的订阅
36:             if (services != null && !services.isEmpty()) {
37:                 for (String service : services) {
38:                     service = URL.decode(service);
39:                     anyServices.add(service);
40:                     subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service,
41:                             Constants.CHECK_KEY, String.valueOf(false)), listener);
42:                 }
43:             }
44:         // 处理指定 Service 层的发起订阅，例如服务消费者的订阅
45:         } else {
46:             // 子节点数据数组
47:             List<URL> urls = new ArrayList<URL>();
48:             // 循环分类数组
49:             for (String path : toCategoriesPath(url)) {
50:                 // 获得 url 对应的监听器集合
51:                 ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
52:                 if (listeners == null) { // 不存在，进行创建
53:                     zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
54:                     listeners = zkListeners.get(url);
55:                 }
56:                 // 获得 ChildListener 对象
57:                 ChildListener zkListener = listeners.get(listener);
58:                 if (zkListener == null) { // 不存在 ChildListener 对象，进行创建 ChildListener 对象
59:                     listeners.putIfAbsent(listener, new ChildListener() {
60:                         public void childChanged(String parentPath, List<String> currentChilds) {
61:                             // 变更时，调用 `#notify(...)` 方法，回调 NotifyListener
62:                             ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));
63:                         }
64:                     });
65:                     zkListener = listeners.get(listener);
66:                 }
67:                 // 创建 Type 节点。该节点为持久节点。
68:                 zkClient.create(path, false);
69:                 // 向 Zookeeper ，PATH 节点，发起订阅
70:                 List<String> children = zkClient.addChildListener(path, zkListener);
71:                 // 添加到 `urls` 中
72:                 if (children != null) {
73:                     urls.addAll(toUrlsWithEmpty(url, path, children));
74:                 }
75:             }
76:             // 首次全量数据获取完成时，调用 `#notify(...)` 方法，回调 NotifyListener
77:             notify(url, listener, urls);
78:         }
79:     } catch (Throwable e) {
80:         throw new RpcException("Failed to subscribe " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
81:     }
82: }
```

- 整个方法分成两部分，分别：
- ============ 第二部分【第 44 至 78 行】 ============
- 处理**指定** Service 层的发起订阅，例如**服务消费者**的订阅。
- 第 47 行：子节点数据数组，即 **Service 层**下的**所有 URL** 。
- 第 49 行：循环分类数组。其中，调用 `#toCategoriesPath(url)` 方法，获得 分类数组。
- 第 51 至 55 行：获得订阅的 `url` 对应的监听器集合。
- 第 56 至 66 行：获得 `listener`( NotifyListener ) 对应的 ChildListener 对象。**在 URL 层发生变更时**，会调用 `NotifyListener#notify(url, listener, currentChilds)` 方法，回调 NotifyListener 的逻辑。酱紫，如果 Service 下增加**新的服务提供者实例**( 新的 URL )，服务消费者可创建新的 Invoker 对象，用于调用该服务提供者。
- 第 68 行：创建 **Type** 节点。该节点为**持久**节点。
- 第 70 行：向 Zookeeper 的 **Path** 节点，发起订阅。
- 第 72 至 74 行：添加到 `urls` 中。
- 第 77 行：**首次全量数据获取完成时**，调用 `NotifyListener#notify(url, listener, currentChilds)` 方法，回调 NotifyListener 的逻辑。酱紫，服务消费者可创建所有的 Invoker 对象，用于调用服务提供者们。
- 🙂 回看【第 77 行】和【第 62 行】，全量 + 增量，仔细理解下。
- ============ 第一部分【第 5 至 43 行】 ============
- 处理**所有** Service 层的发起订阅，例如**监控中心**的订阅
- 第 8 至 12 行：获得订阅的 `url` 对应的监听器集合。
- 第 13 至 30 行：获得 `listener`( NotifyListener ) 对应的 ChildListener 对象。**在 Service 层发生变更时**，若是新增 Service 接口全名时（即新增服务），调用 `#subscribe(url, listener)` 方法，发起该 Service 层的订阅（【第 45 至 78 行】的逻辑）。是否是新增的服务，通过 `anyServices` 属性来判断。
- 第 32 行：创建 **Service** 节点。该节点为**持久**节点。
- 第 34 行：向 Zookeeper 的 **Service** 节点，发起订阅。
- 第 36 至 43 行：**首次全量数据获取完成时**，循环 Service 接口全名数组，调用 `#subscribe(url, listener)` 方法，发起该 Service 层的订阅（【第 45 至 78 行】的逻辑）。

> 友情提示：如果觉得比较绕，或者笔者讲的不清晰，胖友可以进行调试理解。

###### 3.4.1 toCategoriesPath

```
/**
 * 获得分类路径数组
 *
 * Root + Service + Type
 *
 * @param url URL
 * @return 分类路径数组
 */
private String[] toCategoriesPath(URL url) {
    // 获得分类数组
    String[] categories;
    if (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) { // * 时，
        categories = new String[]{Constants.PROVIDERS_CATEGORY, Constants.CONSUMERS_CATEGORY,
                Constants.ROUTERS_CATEGORY, Constants.CONFIGURATORS_CATEGORY};
    } else {
        categories = url.getParameter(Constants.CATEGORY_KEY, new String[]{Constants.DEFAULT_CATEGORY});
    }
    // 获得分类路径数组
    String[] paths = new String[categories.length];
    for (int i = 0; i < categories.length; i++) {
        paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];
    }
    return paths;
}
```

###### 3.4.2 toUrlsWithEmpty

```
/**
 * 获得 providers 中，和 consumer 匹配的 URL 数组
 *
 * 若不存在匹配，则创建 `empty://` 的 URL返回。通过这样的方式，可以处理类似服务提供者为空的情况。
 *
 * @param consumer 用于匹配 URL
 * @param path 被匹配的 URL 的字符串
 * @param providers 匹配的 URL 数组
 * @return 匹配的 URL 数组
 */
private List<URL> toUrlsWithEmpty(URL consumer, String path, List<String> providers) {
    // 获得 providers 中，和 consumer 匹配的 URL 数组
    List<URL> urls = toUrlsWithoutEmpty(consumer, providers);
    // 若不存在匹配，则创建 `empty://` 的 URL返回
    if (urls == null || urls.isEmpty()) {
        int i = path.lastIndexOf('/');
        String category = i < 0 ? path : path.substring(i + 1);
        URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);
        urls.add(empty);
    }
    return urls;
}
```

- `#toUrlsWithoutEmpty()` 方法，代码如下：

  ```
  /**
   * 获得 providers 中，和 consumer 匹配的 URL 数组
   *
   * @param consumer 用于匹配 URL
   * @param providers 被匹配的 URL 的字符串
   * @return 匹配的 URL 数组
   */
  private List<URL> toUrlsWithoutEmpty(URL consumer, List<String> providers) {
      List<URL> urls = new ArrayList<URL>();
      if (providers != null && !providers.isEmpty()) {
          for (String provider : providers) {
              provider = URL.decode(provider);
              if (provider.contains("://")) { // 是 url
                  URL url = URL.valueOf(provider); // 将字符串转化成 URL
                  if (UrlUtils.isMatch(consumer, url)) { // 匹配
                      urls.add(url);
                  }
              }
          }
      }
      return urls;
  }
  ```

#### 3.5 doUnsubscribe

```
@Override
protected void doUnsubscribe(URL url, NotifyListener listener) {
    ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
    if (listeners != null) {
        ChildListener zkListener = listeners.get(listener);
        if (zkListener != null) {
            // 向 Zookeeper ，移除订阅
            zkClient.removeChildListener(toUrlPath(url), zkListener);
        }
    }
}
```

#### 3.6 lookup

```
/**
 * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。
 *
 * @param url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&application=kylin
 * @return 已注册信息列表，可能为空，含义同{@link com.alibaba.dubbo.registry.NotifyListener#notify(List<URL>)}的参数。
 * @see com.alibaba.dubbo.registry.NotifyListener#notify(List)
 */
@Override
public List<URL> lookup(URL url) {
    if (url == null) {
        throw new IllegalArgumentException("lookup url == null");
    }
    try {
        // 循环分类数组，获得所有的 URL 数组
        List<String> providers = new ArrayList<String>();
        for (String path : toCategoriesPath(url)) {
            List<String> children = zkClient.getChildren(path);
            if (children != null) {
                providers.addAll(children);
            }
        }
        // 匹配
        return toUrlsWithoutEmpty(url, providers);
    } catch (Throwable e) {
        throw new RpcException("Failed to lookup " + url + " from zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

#### 3.7 isAvailable

```
@Override
public boolean isAvailable() {
    return zkClient.isConnected();
}
```

#### 3.8 destroy

```
@Override
public void destroy() {
    super.destroy();
    try {
        zkClient.close();
    } catch (Exception e) {
        logger.warn("Failed to close zookeeper client " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

## 4. 调用

#### 4.1 服务提供者

回头看 [《精尽 Dubbo 源码分析 —— 服务暴露（二）之远程暴露（Dubbo）》](http://svip.iocoder.cn/Dubbo/service-export-remote-dubbo/?self) 的 [「3.2.2 export」](http://svip.iocoder.cn/Dubbo/registry-zookeeper/#) 小节，我们可以看到：

- 第 14 行：调用 `#register(registryUrl, registedProviderUrl)` 方法，向注册中心注册服务提供者（自己）。代码如下：

  ```
  public void register(URL registryUrl, URL registedProviderUrl) {
      Registry registry = registryFactory.getRegistry(registryUrl);
      registry.register(registedProviderUrl);
  }
  ```

#### 4.2 服务消费者

回头看 [《精尽 Dubbo 源码分析 —— 服务引用（二）之远程引用（Dubbo）》](http://svip.iocoder.cn/Dubbo/reference-refer-dubbo/?self) 的 [「3.2.2 doRefer](http://svip.iocoder.cn/Dubbo/registry-zookeeper/#) 小节，我们可以看到：

- 第 20 至 25 行：调用 `RegistryService#register(url)` 方法，向注册中心注册**自己**（服务消费者）。

- 第 35 行：调用

   

  ```
  Directory#subscribe(url)
  ```

   

  方法，向注册中心订阅服务提供者 + 路由规则 + 配置规则。

  - 在该方法中，会循环获得到的服务体用这列表，调用 `Protocol#refer(type, url)` 方法，创建每个调用服务的 Invoker 对象。

# Redis

## 1. 概述

前置阅读文章：

- [《精尽 Dubbo 源码分析 —— 注册中心（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/registry-api/?self)
- [《精尽 Dubbo 源码分析 —— 注册中心（二）之 Zookeeper》](http://svip.iocoder.cn/Dubbo/registry-zookeeper/?self)

我们先来看下 [《Dubbo 用户指南 —— Redis 注册中心》](http://dubbo.apache.org/zh-cn/docs/user/references/registry/redis.html) 文档，内容如下：

> 基于 Redis 实现的注册中心。
>
> [![流程](http://static.iocoder.cn/images/Dubbo/2018_08_07/01.png)](http://static.iocoder.cn/images/Dubbo/2018_08_07/01.png)流程
>
> 使用 Redis 的 Key/Map 结构存储数据结构：
>
> - 主 Key 为服务名和类型
> - Map 中的 Key 为 URL 地址
> - Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除

- **横向**来看，和基于 Zookeeper 实现的注册中心，也是分成 **Root**、**Service**、**Type**、**URL** 四层。
- 使用 **Redis Map** 的数据结构，聚合相同服务和类型( Root + Service + Type )。
- 不使用 Redis 的**自动过期**机制，而是通过**监控中心**，实现过期机制。因为，Redis Key 自动过期时，不存在相应的事件通知。
- 服务提供者和消费者，定时延长其注册的 URL 地址的过期时间。

使用 Redis 的 **Publish/Subscribe** 事件通知数据变更：

> - 通过事件的值区分事件类型：`register`, `unregister`
> - 普通消费者直接订阅指定服务提供者的 Key，只会收到**指定服务**的变更事件
> - 监控中心通过 psubscribe 功能订阅 `/dubbo/*`，会收到**所有服务**的所有变更事件

- 服务实例的启动或关闭，会写入或删除对应的 Redis Map 中，并发起对应的 `register`, `unregister` 事件，从而保证**实时性**。
- 通过监控中心，轮询 Key 过期，保证**未正常关闭**的服务实例的 URL 的删除，并发起对应的 `unregister` 事件，从而保证**最终一致性**。

**调用过程**：

> 【一】服务提供方
>
> - 1、服务提供方启动时，向 `Key:/dubbo/com.foo.BarService/providers` 下，添加当前提供者的地址
> - 2、并向 `Channel:/dubbo/com.foo.BarService/providers` 发送 `register` 事件
>
> 【二】服务消费方
>
> - 3、服务消费方启动时，从 `Channel:/dubbo/com.foo.BarService/providers` 订阅 `register` 和 `unregister` 事件
> - 4、并向 `Key:/dubbo/com.foo.BarService/providers` 下，添加当前消费者的地址
>   服务消费方收到 `register` 和 `unregister` 事件后，从 `Key:/dubbo/com.foo.BarService/providers` 下获取提供者地址列表
>
> 【三】服务监控中心
>
> - 5、服务监控中心启动时，从 `Channel:/dubbo/*` 订阅 `register` 和 `unregister`，以及 `subscribe` 和 `unsubsribe` 事件
> - 6、服务监控中心收到 `register` 和 `unregister` 事件后，从 `Key:/dubbo/com.foo.BarService/providers` 下获取提供者地址列表
> - 7、服务监控中心收到 `subscribe` 和 `unsubsribe` 事件后，从 `Key:/dubbo/com.foo.BarService/consumers` 下获取消费者地址列表

本文涉及仅有 RedisRegistry 一个类，类图如下：

[![类图](http://static.iocoder.cn/images/Dubbo/2018_08_07/02.png)](http://static.iocoder.cn/images/Dubbo/2018_08_07/02.png)类图

## 2. RedisRegistry

[`com.alibaba.dubbo.registry.redis.RedisRegistry`](https://github.com/YunaiV/dubbo/blob/master/dubbo-registry/dubbo-registry-redis/src/main/java/com/alibaba/dubbo/registry/redis/RedisRegistry.java) ，实现 FailbackRegistry 抽象类，基于 Redis 实现的注册中心实现类。

#### 2.1 构造方法

```
  1: /**
  2:  * 默认端口
  3:  */
  4: private static final int DEFAULT_REDIS_PORT = 6379;
  5: /**
  6:  * 默认 Redis 根节点
  7:  */
  8: private final static String DEFAULT_ROOT = "dubbo";
  9: 
 10: /**
 11:  * Redis Key 过期机制执行器
 12:  */
 13: private final ScheduledExecutorService expireExecutor = Executors.newScheduledThreadPool(1, new NamedThreadFactory("DubboRegistryExpireTimer", true));
 14: /**
 15:  * Redis Key 过期机制 Future
 16:  */
 17: private final ScheduledFuture<?> expireFuture;
 18: 
 19: /**
 20:  * Redis 根节点
 21:  */
 22: private final String root;
 23: 
 24: /**
 25:  * JedisPool 集合
 26:  *
 27:  * key：ip:port
 28:  */
 29: private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();
 30: 
 31: /**
 32:  * 通知器集合
 33:  *
 34:  * key：Root + Service ，例如 `/dubbo/com.alibaba.dubbo.demo.DemoService`
 35:  */
 36: private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();
 37: 
 38: /**
 39:  * 重连周期，单位：毫秒
 40:  */
 41: private final int reconnectPeriod;
 42: /**
 43:  * 过期周期，单位：毫秒
 44:  */
 45: private final int expirePeriod;
 46: 
 47: /**
 48:  * 是否监控中心
 49:  *
 50:  * 用于判断脏数据，脏数据由监控中心删除 {@link #clean(Jedis)}
 51:  */
 52: private volatile boolean admin = false;
 53: 
 54: /**
 55:  * 是否复制模式
 56:  */
 57: private boolean replicate;
 58: 
 59: public RedisRegistry(URL url) {
 60:     super(url);
 61:     if (url.isAnyHost()) {
 62:         throw new IllegalStateException("registry address == null");
 63:     }
 64:     // 创建 GenericObjectPoolConfig 对象
 65:     GenericObjectPoolConfig config = new GenericObjectPoolConfig();
 66:     config.setTestOnBorrow(url.getParameter("test.on.borrow", true));
 67:     config.setTestOnReturn(url.getParameter("test.on.return", false));
 68:     config.setTestWhileIdle(url.getParameter("test.while.idle", false));
 69:     if (url.getParameter("max.idle", 0) > 0)
 70:         config.setMaxIdle(url.getParameter("max.idle", 0));
 71:     if (url.getParameter("min.idle", 0) > 0)
 72:         config.setMinIdle(url.getParameter("min.idle", 0));
 73:     if (url.getParameter("max.active", 0) > 0)
 74:         config.setMaxTotal(url.getParameter("max.active", 0));
 75:     if (url.getParameter("max.total", 0) > 0)
 76:         config.setMaxTotal(url.getParameter("max.total", 0));
 77:     if (url.getParameter("max.wait", url.getParameter("timeout", 0)) > 0)
 78:         config.setMaxWaitMillis(url.getParameter("max.wait", url.getParameter("timeout", 0)));
 79:     if (url.getParameter("num.tests.per.eviction.run", 0) > 0)
 80:         config.setNumTestsPerEvictionRun(url.getParameter("num.tests.per.eviction.run", 0));
 81:     if (url.getParameter("time.between.eviction.runs.millis", 0) > 0)
 82:         config.setTimeBetweenEvictionRunsMillis(url.getParameter("time.between.eviction.runs.millis", 0));
 83:     if (url.getParameter("min.evictable.idle.time.millis", 0) > 0)
 84:         config.setMinEvictableIdleTimeMillis(url.getParameter("min.evictable.idle.time.millis", 0));
 85: 
 86:     // 是否复制模式
 87:     String cluster = url.getParameter("cluster", "failover");
 88:     if (!"failover".equals(cluster) && !"replicate".equals(cluster)) {
 89:         throw new IllegalArgumentException("Unsupported redis cluster: " + cluster + ". The redis cluster only supported failover or replicate.");
 90:     }
 91:     replicate = "replicate".equals(cluster);
 92: 
 93:     // 解析
 94:     List<String> addresses = new ArrayList<String>();
 95:     addresses.add(url.getAddress());
 96:     String[] backups = url.getParameter(Constants.BACKUP_KEY, new String[0]);
 97:     if (backups != null && backups.length > 0) {
 98:         addresses.addAll(Arrays.asList(backups));
 99:     }
100: 
101:     // 创建 JedisPool 对象
102:     String password = url.getPassword();
103:     for (String address : addresses) {
104:         int i = address.indexOf(':');
105:         String host;
106:         int port;
107:         if (i > 0) {
108:             host = address.substring(0, i);
109:             port = Integer.parseInt(address.substring(i + 1));
110:         } else {
111:             host = address;
112:             port = DEFAULT_REDIS_PORT;
113:         }
114:         if (StringUtils.isEmpty(password)) { // 无密码连接
115:             this.jedisPools.put(address, new JedisPool(config, host, port,
116:                     url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT)));
117:         } else { // 有密码连接
118:             this.jedisPools.put(address, new JedisPool(config, host, port,
119:                     url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT), password));
120:         }
121:     }
122: 
123:     // 解析重连周期
124:     this.reconnectPeriod = url.getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD);
125: 
126:     // 获得 Redis 根节点
127:     String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);
128:     if (!group.startsWith(Constants.PATH_SEPARATOR)) { // 头 `/`
129:         group = Constants.PATH_SEPARATOR + group;
130:     }
131:     if (!group.endsWith(Constants.PATH_SEPARATOR)) { // 尾 `/`
132:         group = group + Constants.PATH_SEPARATOR;
133:     }
134:     this.root = group;
135: 
136:     // 创建实现 Redis Key 过期机制的任务
137:     this.expirePeriod = url.getParameter(Constants.SESSION_TIMEOUT_KEY, Constants.DEFAULT_SESSION_TIMEOUT);
138:     this.expireFuture = expireExecutor.scheduleWithFixedDelay(new Runnable() {
139:         public void run() {
140:             try {
141:                 deferExpired(); // Extend the expiration time
142:             } catch (Throwable t) { // Defensive fault tolerance
143:                 logger.error("Unexpected exception occur at defer expire time, cause: " + t.getMessage(), t);
144:             }
145:         }
146:     }, expirePeriod / 2, expirePeriod / 2, TimeUnit.MILLISECONDS);
147: }
```

- `jedisPools` 属性，JedisPool 集合，其中键为 `ip:port` 。在【第 64 至 84 行】和【第 93 至 99 行】和【101 至 121 行】初始化。

  - `root` 属性，Redis 根节点，即首图的 **Root** 层。在【第 126 至 134 行】初始化。

  - `replicate` 属性，是否复制模式。在【第 86 至 90 行】文档说明如下：

    > 可通过 `<dubbo:registry cluster="replicate" />` 设置 redis 集群策略，缺省为 `failover`：
    >
    > - `failover`: 只写入和读取任意一台，失败时重试另一台，需要服务器端自行配置数据同步。
    > - `replicate`: 在客户端同时写入所有服务器，只读取单台，服务器端不需要同步，注册中心集群增大，性能压力也会更大。

- `notifiers` 属性，通知器集合，其中键为 Root + Service 。Notifier ，用于 Redis Publish/Subscribe 机制中的订阅，实时监听数据的变化。

  - `reconnectPeriod` 属性，重连周期，单位：毫秒。在【第 91 行】初始化。用于订阅发生 Redis 连接异常时，Notifier **sleep** ，等待重连上。

- ```
  expireExecutor
  ```

   

  属性，Redis Key 过期机制执行器。

  - `expirePeriod` 属性，Redis Key 过期周期，单位：毫秒。在【第 137 行】初始化。

  - ```
    expireFuture
    ```

     

    属性，Redis Key 过期机制任务的 Future 。在【第 138 至 146 行】初始化。

    - 该任务主要有两个逻辑：1）延长未过期的 Key ；2）删除过期的 Key 。
    - 任务间隔为 `expirePeriod` 的**一半**，避免过于频繁，对 Redis 的压力过大；同时，避免过于不频繁，每次执行时，都过期了。

  - `admin` 属性，是否监控中心，在 `#clean(Jedis)` 方法，看到具体的使用。

#### 2.2 doRegister

```
 1: @Override
 2: public void doRegister(URL url) {
 3:     String key = toCategoryPath(url);
 4:     String value = url.toFullString();
 5:     // 计算过期时间
 6:     String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);
 7:     boolean success = false;
 8:     RpcException exception = null;
 9:     // 向 Redis 注册
10:     for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
11:         JedisPool jedisPool = entry.getValue();
12:         try {
13:             Jedis jedis = jedisPool.getResource();
14:             try {
15:                 // 写入 Redis Map 键
16:                 jedis.hset(key, value, expire);
17:                 // 发布 Redis 注册事件
18:                 jedis.publish(key, Constants.REGISTER);
19:                 success = true;
20:                 //  如果服务器端已同步数据，只需写入单台机器
21:                 if (!replicate) {
22:                     break; //  If the server side has synchronized data, just write a single machine
23:                 }
24:             } finally {
25:                 jedisPool.returnResource(jedis);
26:             }
27:         } catch (Throwable t) {
28:             exception = new RpcException("Failed to register service to redis registry. registry: " + entry.getKey() + ", service: " + url + ", cause: " + t.getMessage(), t);
29:         }
30:     }
31:     // 处理异常
32:     if (exception != null) {
33:         if (success) { // 虽然发生异常，但是结果成功
34:             logger.warn(exception.getMessage(), exception);
35:         } else { // 最终未成功
36:             throw exception;
37:         }
38:     }
39: }
```

- 第 3 行：调用 `#toCategoryPath(url)` 方法，获得**分类路径**作为 Key 。
- 第 4 行：调用 `URL#toFullString()` 方法，获得 **URL 字符串**作为 Value 。
- 第 6 行：计算过期时间，当前时间 + `expirePeriod` 。
- 第 9 至 30 行：向 Redis 注册。
  - 第 16 行：调用 `Jedis#hset(key, value, expire)` 方法，写入 Redis Map 中。**注意，过期时间，作为 Map 的值**。
  - 第 18 行：调用 `Jedis#publish(channel, message)` 方法，发布 `register` 事件。这样订阅该 Key 的服务消费者和监控中心，就会实时从 Redis 读取**该服务**的最新数据。
  - 第 21 至 23 行：如果非 `replicate` ，意味着 Redis 服务器端已同步数据，只需写入单台机器。因此，结束循环。否则，满足 `replicate` ，向所有 Redis 写入。
- 第 31 至 38 行：处理异常。这块代码胖友自己看下，注意下 `exception` 和 `success` 赋值的地方。这块的打印告警日志的处理方式，也适用于多次重试某个操作，结果发生异常，但是最终成功。例如，HTTP 请求远程服务。

###### 2.1.1 toCategoryPath

```
/**
 * 获得分类路径
 *
 * Root + Service + Type
 *
 * @param url URL
 * @return 分类路径
 */
private String toCategoryPath(URL url) {
    return toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
}
```

#### 2.3 doUnregister

```
@Override
public void doUnregister(URL url) {
    String key = toCategoryPath(url);
    String value = url.toFullString();
    RpcException exception = null;
    boolean success = false;
    // 向 Redis 注册
    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
        JedisPool jedisPool = entry.getValue();
        try {
            Jedis jedis = jedisPool.getResource();
            try {
                // 删除 Redis Map 键
                jedis.hdel(key, value);
                // 发布 Redis 取消注册事件
                jedis.publish(key, Constants.UNREGISTER);
                success = true;
                //  如果服务器端已同步数据，只需写入单台机器
                if (!replicate) {
                    break; //  If the server side has synchronized data, just write a single machine
                }
            } finally {
                jedisPool.returnResource(jedis);
            }
        } catch (Throwable t) {
            exception = new RpcException("Failed to unregister service to redis registry. registry: " + entry.getKey() + ", service: " + url + ", cause: " + t.getMessage(), t);
        }
    }
    // 处理异常
    if (exception != null) {
        if (success) { // 虽然发生异常，但是结果成功
            logger.warn(exception.getMessage(), exception);
        } else { // 最终未成功
            throw exception;
        }
    }
}
```

- 当服务消费者或服务提供者，关闭时，会调用 `#doUnregister(url)` 方法，取消注册。在该方法中，会删除对应 Map 中的**键** + 发布 `unregister` 事件，从而**实时**通知订阅者们。因此，正常情况下，就无需监控中心，做脏数据删除的工作。
- 🙂 代码比较简单，和 `#doRegister()` 方法，逻辑相反。

#### 2.4 doSubscribe

```
 1: @Override
 2: public void doSubscribe(final URL url, final NotifyListener listener) {
 3:     // 获得服务路径，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService`
 4:     String service = toServicePath(url);
 5:     // 获得通知器 Notifier 对象
 6:     Notifier notifier = notifiers.get(service);
 7:     // 不存在，则创建 Notifier 对象
 8:     if (notifier == null) {
 9:         Notifier newNotifier = new Notifier(service);
10:         notifiers.putIfAbsent(service, newNotifier);
11:         notifier = notifiers.get(service);
12:         if (notifier == newNotifier) { // 保证并发的情况下，有且仅有一个启动
13:             notifier.start();
14:         }
15:     }
16:     boolean success = false;
17:     RpcException exception = null;
18:     // 循环 `jedisPools` ，仅向一个 Redis 发起订阅
19:     for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
20:         JedisPool jedisPool = entry.getValue();
21:         try {
22:             Jedis jedis = jedisPool.getResource();
23:             try {
24:                 // 处理所有 Service 层的发起订阅，例如监控中心的订阅
25:                 if (service.endsWith(Constants.ANY_VALUE)) {
26:                     admin = true;
27:                     // 获得分类层集合，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService/providers`
28:                     Set<String> keys = jedis.keys(service);
29:                     if (keys != null && !keys.isEmpty()) {
30:                         // 按照服务聚合 URL 集合
31:                         Map<String, Set<String>> serviceKeys = new HashMap<String, Set<String>>(); // Key：Root + Service ; Value：URL 。
32:                         for (String key : keys) {
33:                             String serviceKey = toServicePath(key);
34:                             Set<String> sk = serviceKeys.get(serviceKey);
35:                             if (sk == null) {
36:                                 sk = new HashSet<String>();
37:                                 serviceKeys.put(serviceKey, sk);
38:                             }
39:                             sk.add(key);
40:                         }
41:                         // 循环 serviceKeys ，按照每个 Service 层的发起通知
42:                         for (Set<String> sk : serviceKeys.values()) {
43:                             doNotify(jedis, sk, url, Collections.singletonList(listener));
44:                         }
45:                     }
46:                 // 处理指定 Service 层的发起通知
47:                 } else {
48:                     doNotify(jedis, jedis.keys(service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE), url, Collections.singletonList(listener));
49:                 }
50:                 // 标记成功
51:                 success = true;
52:                 // 结束，仅仅从一台服务器读取数据
53:                 break; // Just read one server's data
54:             } finally {
55:                 jedisPool.returnResource(jedis);
56:             }
57:         } catch (Throwable t) { // Try the next server
58:             exception = new RpcException("Failed to subscribe service from redis registry. registry: " + entry.getKey() + ", service: " + url + ", cause: " + t.getMessage(), t);
59:         }
60:     }
61:     // 处理异常
62:     if (exception != null) {
63:         if (success) { // 虽然发生异常，但是结果成功
64:             logger.warn(exception.getMessage(), exception);
65:         } else { // 最终未成功
66:             throw exception;
67:         }
68:     }
69: }
```

- ========== 【第一步】Notifier 部分 ==========
- 第 4 行：调用 `#toServicePath(url)` 方法，获得服务路径，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService` 。
- 第 6 行：获得通知器 Notifier 对象。
- 第 8 至 15 行：若不存在，则创建 Notifier 对象，并调用 `Notifier#start()` 方法。
- ========== 【第二步】获取初始化数据，并进行通知 ==========
- 第 19 行：循环 `jedisPools` ，向 Redis 发起订阅，**直到一个成功**。我们会看到代码，分成**两个部分**。
- 【第二部分】第 46 至 49 行，适用服务提供者和服务消费者，处理**指定** Service 层的初始化数据：
- 第 48 行：调用 `Jedis#keys(pattern)` 方法，获得**指定** Service 层下的所有 URL 们。例如 `/dubbo/com.alibaba.dubbo.demo.DemoService/*` 。
- 第 48 行：调用 `#doNotify(jedis, keys, url, listeners)` 方法，通知监听器，初始的数据。
- 【第一部分】第 25 至 45 行，适用注册中心，处理**所有** Service 层的初始化数据：
- 第 26 行：标记 `admin = true` 。因为，只有注册中心，才清理脏数据。
- 第 28 行：调用 `Jedis#keys(pattern)` 方法，获得**所有** Service 层下的所有 URL 们。例如 `/dubbo/*` 。
- 第 31 至 39 行：按照**服务**聚合 URL 集合。
- 第 42 至 44 行：循环 `serviceKeys` ，调用 `#doNotify(jedis, keys, url, listeners)` 方法，按照**每个 Service 层**，通知监听器，初始的数据。此处，就和【第 48 行】**类似**。

另外，订阅动作（【第一步】）**一定**要在获取初始化数据（【第二步】）**之前**。如果反过来，可能获取数据完后，处理的过程中，有数据的变更，我们就无法收到 `register` `unregister` 的事件。

###### 2.4.1 toServicePath

```
/**
 * 获得服务路径
 *
 * Root + Type
 *
 * @param url URL
 * @return 服务路径
 */
private String toServicePath(URL url) {
    return root + url.getServiceInterface();
}
```

###### 2.4.2 toServicePath

```
/**
 * 获得服务路径，主要截掉多余的部分
 *
 * Root + Type
 *
 * @param categoryPath 分类路径
 * @return 服务路径
 */
private String toServicePath(String categoryPath) {
    int i;
    if (categoryPath.startsWith(root)) {
        i = categoryPath.indexOf(Constants.PATH_SEPARATOR, root.length());
    } else {
        i = categoryPath.indexOf(Constants.PATH_SEPARATOR);
    }
    return i > 0 ? categoryPath.substring(0, i) : categoryPath;
}
```

#### 2.5 doUnsubscribe

```
@Override
public void doUnsubscribe(URL url, NotifyListener listener) {
}
```

- 此处目前并未实现，艿艿觉得，此处应该增加取消向 Redis 的订阅( Subscribe ) 。在 ZookeeperRegistry 的该方法中，是移除了对应的监听器。

#### 2.6 doNotify

```
 1: // @params key 分类数组，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService/providers`
 2: private void doNotify(Jedis jedis, String key) {
 3:     for (Map.Entry<URL, Set<NotifyListener>> entry : new HashMap<URL, Set<NotifyListener>>(getSubscribed()).entrySet()) {
 4:         doNotify(jedis, Collections.singletonList(key), entry.getKey(), new HashSet<NotifyListener>(entry.getValue()));
 5:     }
 6: }
 7: 
 8: // @params keys 分类数组，元素例如：`/dubbo/com.alibaba.dubbo.demo.DemoService/providers`
 9: private void doNotify(Jedis jedis, Collection<String> keys, URL url, Collection<NotifyListener> listeners) {
10:     if (keys == null || keys.isEmpty() || listeners == null || listeners.isEmpty()) {
11:         return;
12:     }
13:     long now = System.currentTimeMillis();
14:     List<URL> result = new ArrayList<URL>();
15:     List<String> categories = Arrays.asList(url.getParameter(Constants.CATEGORY_KEY, new String[0])); // 分类数组
16:     String consumerService = url.getServiceInterface(); // 服务接口
17:     // 循环分类层，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService/providers`
18:     for (String key : keys) {
19:         // 若服务不匹配，返回
20:         if (!Constants.ANY_VALUE.equals(consumerService)) {
21:             String providerService = toServiceName(key);
22:             if (!providerService.equals(consumerService)) {
23:                 continue;
24:             }
25:         }
26:         // 若订阅的不包含该分类，返回
27:         String category = toCategoryName(key);
28:         if (!categories.contains(Constants.ANY_VALUE) && !categories.contains(category)) {
29:             continue;
30:         }
31:         // 获得所有 URL 数组
32:         List<URL> urls = new ArrayList<URL>();
33:         Map<String, String> values = jedis.hgetAll(key);
34:         if (values != null && values.size() > 0) {
35:             for (Map.Entry<String, String> entry : values.entrySet()) {
36:                 URL u = URL.valueOf(entry.getKey());
37:                 if (!u.getParameter(Constants.DYNAMIC_KEY, true) // 非动态节点，因为动态节点，不受过期的限制
38:                         || Long.parseLong(entry.getValue()) >= now) { // 未过期
39:                     if (UrlUtils.isMatch(url, u)) {
40:                         urls.add(u);
41:                     }
42:                 }
43:             }
44:         }
45:         // 若不存在匹配，则创建 `empty://` 的 URL返回，用于清空该服务的该分类。
46:         if (urls.isEmpty()) {
47:             urls.add(url.setProtocol(Constants.EMPTY_PROTOCOL)
48:                     .setAddress(Constants.ANYHOST_VALUE)
49:                     .setPath(toServiceName(key))
50:                     .addParameter(Constants.CATEGORY_KEY, category));
51:         }
52:         result.addAll(urls);
53:         if (logger.isInfoEnabled()) {
54:             logger.info("redis notify: " + key + " = " + urls);
55:         }
56:     }
57:     if (result.isEmpty()) {
58:         return;
59:     }
60:     // 全量数据获取完成时，调用 `super#notify(...)` 方法，回调 NotifyListener
61:     for (NotifyListener listener : listeners) {
62:         super.notify(url, listener, result);
63:     }
64: }
```

- 两个重载的 `#doNotify(...)` 方法，主要差异点在前者少 `url` 和 `listeners` 方法参数。所以：

  - 第 3 行：我们可以看到调用 `#getSubscribed()` 方法，获得**所有**监听器。代码如下：

    ```
    /**
     * 订阅 URL 的监听器集合
     *
     * key：订阅者的 URL ，例如消费者的 URL
     */
    private final ConcurrentMap<URL, Set<NotifyListener>> subscribed = new ConcurrentHashMap<URL, Set<NotifyListener>>();
    ```

    - x

  - 第 3 至 5 行：**循环**调用 `#doNotify(jedis, keys, url, listeners)` 方法，进行通知。**但是呢**？这样一来，通知的事件( `key` )和监听器未必匹配，因此在【第 20 至 30 行】的代码，进行匹配。

- 第 15 行：获得分类层( Category )，即分类数组。在

   

  《精尽 Dubbo 源码分析 —— 注册中心（二）之 Zookeeper》「4. 调用」

   

  小节中，我们也看到，不同角色关注不同的分类数据。

  - 服务消费者，关注 `providers` `configurations` `routes` 。
  - 服务提供者，关注 `consumers` 。
  - 监控中心，关注所有。

- 第 18 行：循环分类层，即每个元素为 Root + Service + Type ，例如：`/dubbo/com.alibaba.dubbo.demo.DemoService/providers` 。

- 第 32 至 44 行：调用 `Jedis#hgetAll(key)` 方法，获得所有 URL 数组。并且，获取完成后，会过滤掉**已过期**的**动态**节点。

- 第 45 至 51 行：若不存在匹配，则创建 `empty://` 的 URL返回，用于**清空**该服务的该分类。

- 第 52 行：添加到 `result` 中。

- 第 60 至 63 行：全量数据获取完成时，调用 `super#notify(...)` 方法，回调 NotifyListener 。该方法，在 [《精尽 Dubbo 源码分析 —— 注册中心（一）之抽象 API》](http://svip.iocoder.cn/Dubbo/registry-api/?self) 有详细解析。

###### 2.6.1 toServiceName

```
/**
 * 获得服务名，从服务路径上
 *
 * Service
 *
 * @param categoryPath 服务路径
 * @return 服务名
 */
private String toServiceName(String categoryPath) {
    String servicePath = toServicePath(categoryPath);
    return servicePath.startsWith(root) ? servicePath.substring(root.length()) : servicePath;
}
```

###### 2.6.2 toCategoryName

```
/**
 * 获得分类名，从分类路径上
 *
 * Type
 *
 * @param categoryPath 分类路径
 * @return 分类名
 */
private String toCategoryName(String categoryPath) {
    int i = categoryPath.lastIndexOf(Constants.PATH_SEPARATOR);
    return i > 0 ? categoryPath.substring(i + 1) : categoryPath;
}
```

#### 2.7 deferExpired

```
 1: private void deferExpired() {
 2:     for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
 3:         JedisPool jedisPool = entry.getValue();
 4:         try {
 5:             Jedis jedis = jedisPool.getResource();
 6:             try {
 7:                 // 循环已注册的 URL 集合
 8:                 for (URL url : new HashSet<URL>(getRegistered())) {
 9:                     // 动态节点
10:                     if (url.getParameter(Constants.DYNAMIC_KEY, true)) {
11:                         // 获得分类路径
12:                         String key = toCategoryPath(url);
13:                         // 写入 Redis Map 中
14:                         if (jedis.hset(key, url.toFullString(), String.valueOf(System.currentTimeMillis() + expirePeriod)) == 1) {
15:                             // 发布 `register` 事件。
16:                             jedis.publish(key, Constants.REGISTER);
17:                         }
18:                     }
19:                 }
20:                 // 监控中心负责删除过期脏数据
21:                 if (admin) {
22:                     clean(jedis);
23:                 }
24:                 // 如果服务器端已同步数据，只需写入单台机器
25:                 if (!replicate) {
26:                     break;//  If the server side has synchronized data, just write a single machine
27:                 }
28:             } finally {
29:                 jedisPool.returnResource(jedis);
30:             }
31:         } catch (Throwable t) {
32:             logger.warn("Failed to write provider heartbeat to redis registry. registry: " + entry.getKey() + ", cause: " + t.getMessage(), t);
33:         }
34:     }
35: }
```

- 被 `expireExecutor` 中的定时调用，整体逻辑类似 `#doRegister()` 方法。

- 第 8 行：调用 `#getRegistered()` 方法，获得已注册的 URL 集合。代码如下：

  ```
  /**
   * 已注册 URL 集合。
   *
   * 注意，注册的 URL 不仅仅可以是服务提供者的，也可以是服务消费者的
   */
  private final Set<URL> registered = new ConcurrentHashSet<URL>();
  ```

- 第 8 行：循环 URL 集合。

- 第 10 行：判断是否为**动态**节点，只有动态节点需要延长过期时间。

- 第 14 行：调用 `Jedis#hset(key, value, expire)` 方法，写入 Redis Map 中。**注意，过期时间，作为 Map 的值**。

- 第 16 行：若【第 14 行】写入返回的值为 1 ，说明 Map 中该键对应的值不存在（例如，多写 Redis 节点时，有个节点写入失败），发布 `register` 事件。

- 第 21 至 23 行：若是注册中心( `admin = true` ) 时，调用 `#clean(Jedis)` 方法，清理过期脏数据。

- 第 25 至 27 行：如果服务器端已同步数据，只需写入单台机器。

###### 2.7.1 clean

```
private void clean(Jedis jedis) {
    // 获得所有服务
    Set<String> keys = jedis.keys(root + Constants.ANY_VALUE);
    if (keys != null && !keys.isEmpty()) {
        for (String key : keys) {
            // 获得所有 URL
            Map<String, String> values = jedis.hgetAll(key);
            if (values != null && values.size() > 0) {
                boolean delete = false;
                long now = System.currentTimeMillis();
                for (Map.Entry<String, String> entry : values.entrySet()) {
                    URL url = URL.valueOf(entry.getKey());
                    // 动态节点
                    if (url.getParameter(Constants.DYNAMIC_KEY, true)) {
                        long expire = Long.parseLong(entry.getValue());
                        // 已经过期
                        if (expire < now) {
                            //
                            jedis.hdel(key, entry.getKey());
                            delete = true;
                            if (logger.isWarnEnabled()) {
                                logger.warn("Delete expired key: " + key + " -> value: " + entry.getKey() + ", expire: " + new Date(expire) + ", now: " + new Date(now));
                            }
                        }
                    }
                }
                // 若删除成功，发布 `unregister` 事件
                if (delete) {
                    jedis.publish(key, Constants.UNREGISTER);
                }
            }
        }
    }
}
```

- 整体逻辑类似 `#doUnregister()` 方法。
- 🙂 胖友自己看方法的注释哈。

#### 2.8 isAvailable

```
@Override
public boolean isAvailable() {
    for (JedisPool jedisPool : jedisPools.values()) {
        try {
            Jedis jedis = jedisPool.getResource();
            try {
                if (jedis.isConnected()) { // 至少一个 Redis 节点可用
                    return true; // At least one single machine is available.
                }
            } finally {
                jedisPool.returnResource(jedis);
            }
        } catch (Throwable ignored) {
        }
    }
    return false;
}
```

#### 2.9 destroy

```
@Override
public void destroy() {
    // 父类关闭
    super.destroy();
    // 关闭定时任务
    try {
        expireFuture.cancel(true);
    } catch (Throwable t) {
        logger.warn(t.getMessage(), t);
    }
    // 关闭通知器
    try {
        for (Notifier notifier : notifiers.values()) {
            notifier.shutdown();
        }
    } catch (Throwable t) {
        logger.warn(t.getMessage(), t);
    }
    // 关闭连接池
    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
        JedisPool jedisPool = entry.getValue();
        try {
            jedisPool.destroy();
        } catch (Throwable t) {
            logger.warn("Failed to destroy the redis registry client. registry: " + entry.getKey() + ", cause: " + t.getMessage(), t);
        }
    }
}
```

## 3. Notifier

> Notifier 是 RedisRegistry 的内部类。

Notifier ，继承 Thread 类，负责向 Redis 发起订阅逻辑。

#### 3.1 构造方法

```
 1: /**
 2:  * 服务名 Root + Service
 3:  */
 4: private final String service;
 5: /**
 6:  * Jedis
 7:  */
 8: private volatile Jedis jedis;
 9: /**
10:  * 是否首次
11:  */
12: private volatile boolean first = true;
13: /**
14:  * 是否运行中
15:  */
16: private volatile boolean running = true;
17: /**
18:  * 连接次数随机数
19:  */
20: private volatile int connectRandom;
21: /**
22:  * 需要忽略连接的次数
23:  */
24: private final AtomicInteger connectSkip = new AtomicInteger();
25: /**
26:  * 已经忽略连接的次数
27:  */
28: private final AtomicInteger connectSkiped = new AtomicInteger();
29: /**
30:  * 随机
31:  */
32: private final Random random = new Random();
```

- `service` 属性，服务名 Root + Service。

- `first` 属性，是否首次。在 `#run()` 方法中，查看。

- 【第 13 至 32 行】的属性，相当于**重连策略**，用于和 Redis 断开时，忽略一定次数和 Redis 的连接，避免空跑。涉及方法如下：

  - `#isSkip()` 方法，判断是否忽略本次对 Redis 的连接。代码如下：

    ```
     1: private boolean isSkip() {
     2:     // 获得需要忽略连接的总次数。如果超过 10 ，则加上一个 10 以内的随机数。
     3:     int skip = connectSkip.get(); // Growth of skipping times
     4:     if (skip >= 10) { // If the number of skipping times increases by more than 10, take the random number
     5:         if (connectRandom == 0) {
     6:             connectRandom = random.nextInt(10);
     7:         }
     8:         skip = 10 + connectRandom;
     9:     }
    10:     // 自增忽略次数。若忽略次数不够，则继续忽略。
    11:     if (connectSkiped.getAndIncrement() < skip) { // Check the number of skipping times
    12:         return true;
    13:     }
    14:     // 增加需要忽略的次数
    15:     connectSkip.incrementAndGet();
    16:     // 重置已忽略次数和随机数
    17:     connectSkiped.set(0);
    18:     connectRandom = 0;
    19:     return false;
    20: }
    ```

    - 第 2 至 9 行：获得**需要忽略连接的总次数**。如果超过 10 ，则加上一个 10 以内的随机数。思路是，连接失败的次数越多，**每一轮**加大需要忽略的总次数，并且带有一定的随机性。

    - 第 10 至 13 行：自增忽略次数。若忽略次数不够，则继续忽略，即返回 `true` 。

    - 第 15 行：增加需要忽略的次数。也就是说，**下一轮**，不考虑随机数，会多一次。如下是一次模拟：

      > 第一轮
      >
      > - connectSkip: 0; connectSkiped: 0
      >
      > 第二轮
      >
      > - connectSkip: 1; connectSkiped: 0
      > - connectSkip: 1; connectSkiped: 1
      >
      > 第三轮
      >
      > - connectSkip: 2; connectSkiped: 0
      > - connectSkip: 2; connectSkiped: 1
      > - connectSkip: 2; connectSkiped: 2

      - 当超过十轮后，增加随机数。

    - 第 16 至 18 行：重置已忽略次数和随机数。

  - `#resetSkip()` 方法，重置忽略连接的信息。代码如下：

    ```
    private void resetSkip() {
        // 重置需要连接的次数
        connectSkip.set(0);
        // 重置已忽略次数和随机数
        connectSkiped.set(0);
        connectRandom = 0;
    }
    ```

    - x

#### 3.2 run

```
 1: @Override
 2: public void run() {
 3:     while (running) {
 4:         try {
 5:             // 是否跳过本次 Redis 连接
 6:             if (!isSkip()) {
 7:                 try {
 8:                     for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {
 9:                         JedisPool jedisPool = entry.getValue();
10:                         try {
11:                             jedis = jedisPool.getResource();
12:                             try {
13:                                 // 监控中心
14:                                 if (service.endsWith(Constants.ANY_VALUE)) {
15:                                     if (!first) {
16:                                         first = false;
17:                                         Set<String> keys = jedis.keys(service);
18:                                         if (keys != null && !keys.isEmpty()) {
19:                                             for (String s : keys) {
20:                                                 doNotify(jedis, s);
21:                                             }
22:                                         }
23:                                         resetSkip();
24:                                     }
25:                                     // 批订阅
26:                                     jedis.psubscribe(new NotifySub(jedisPool), service); // blocking
27:                                 // 服务提供者或消费者
28:                                 } else {
29:                                     if (!first) {
30:                                         first = false;
31:                                         doNotify(jedis, service);
32:                                         resetSkip();
33:                                     }
34:                                     // 批订阅
35:                                     jedis.psubscribe(new NotifySub(jedisPool), service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE); // blocking
36:                                 }
37:                                 break;
38:                             } finally {
39:                                 jedisPool.returnBrokenResource(jedis);
40:                             }
41:                         } catch (Throwable t) { // Retry another server
42:                             logger.warn("Failed to subscribe service from redis registry. registry: " + entry.getKey() + ", cause: " + t.getMessage(), t);
43:                             // If you only have a single redis, you need to take a rest to avoid overtaking a lot of CPU resources
44:                             sleep(reconnectPeriod);
45:                         }
46:                     }
47:                 } catch (Throwable t) {
48:                     logger.error(t.getMessage(), t);
49:                     sleep(reconnectPeriod);
50:                 }
51:             }
52:         } catch (Throwable t) {
53:             logger.error(t.getMessage(), t);
54:         }
55:     }
56: }
```

- 第 3 行：循环执行，直到关闭。

- 第 6 行：调用 `#isSkip()` 方法，判断是否跳过本次 Redis 连接。But ，即使跳过，也没有执行类似 sleep 的逻辑，有点奇怪。这样，会导致实际即使跳过，也会快速向 Redis 发起订阅。【TODO 8032】Redis 重连逻辑

- 第 8 行：循环连接池，发起订阅，直到**一个成功**。

- ======================================================

- 【第一种情况】第 14 至 26 行：监控中心

  - 第 15 至 24 行：目前这块代码有一些问题？！初始时 `first=true` ，那么这块代码永远无法执行到。笔者猜测这块的意图是，在 ZookeeperRegistry 中，可以实现对连接状态的监听，从而实现断开重连成功后，从 Zookeeper 获取到最新的数据。代码如下：

    ```
            zkClient.addStateListener(new StateListener() {
                public void stateChanged(int state) {
                    if (state == RECONNECTED) {
                        try {
                            recover();
                        } catch (Exception e) {
                            logger.error(e.getMessage(), e);
                        }
                    }
                }
            });
    ```

            * 而 JedisPool 中，不提供这样的连接监控机制。那么如果订阅 Redis 发生了异常，我们可以认为 Redis 连接断开了，需要重新发起订阅，并且需要**重新**从 Redis 中获取到最新的数据。
            * 那么此处的代码可以这样改：
                * 第 16 行： `first = true;`
                * 第 42 行：增加 `first = false;`
        * 第 26 行：调用 `Jedis#psubscribe(JedisPubSub jedisPubSub, String... patterns)` 方法，订阅**所有 Service 层**。

    * 【第二种情况】第 27 至 36 行：服务提供者或消费者。
      * 第 29 至 34 行：和【第 15 至 24 行】**类似**。
      * 第 35 行：调用 `Jedis#psubscribe(JedisPubSub jedisPubSub, String... patterns)` 方法，订阅**指定 Service 层**。
    * ======================================================
    * 第 37 至 40 行：无法执行到，因为 `Jedis#psubscribe(JedisPubSub jedisPubSub, String... patterns)` 方法，是**阻塞**的。这也是为什么 Notifier 是一个 **Thread** 的原因。
    * 第 41 至 45 行：发生异常，说明 Redis 连接断开了。因此，调用 `#sleep(millis)` 方法，等待 Redis 重连成功。通过这样的方式，避免执行，占用大量的 CPU 资源。

    #### 3.3 shutdown

    ```Java
    public void shutdown() {
        try {
            // 停止运行
            running = false;
            // Jedis 断开连接
            jedis.disconnect();
        } catch (Throwable t) {
            logger.warn(t.getMessage(), t);
        }
    }

    ```
    
    ```

## 4. NotifySub

> NotifySub 是 RedisRegistry 的内部类。

NotifySub ，实现 `redis.clients.jedis.JedisPubSub` 抽象类，通知订阅实现类。

```
 1: private class NotifySub extends JedisPubSub {
 2: 
 3:     private final JedisPool jedisPool;
 4: 
 5:     public NotifySub(JedisPool jedisPool) {
 6:         this.jedisPool = jedisPool;
 7:     }
 8: 
 9:     @Override
10:     public void onMessage(String key, String msg) {
11:         if (logger.isInfoEnabled()) {
12:             logger.info("redis event: " + key + " = " + msg);
13:         }
14:         if (msg.equals(Constants.REGISTER)
15:                 || msg.equals(Constants.UNREGISTER)) {
16:             try {
17:                 Jedis jedis = jedisPool.getResource();
18:                 try {
19:                     doNotify(jedis, key);
20:                 } finally {
21:                     jedisPool.returnResource(jedis);
22:                 }
23:             } catch (Throwable t) { // TODO Notification failure does not restore mechanism guarantee
24:                 logger.error(t.getMessage(), t);
25:             }
26:         }
27:     }
28: 
29:     @Override
30:     public void onPMessage(String pattern, String key, String msg) {
31:         onMessage(key, msg);
32:     }
33: 
34:     @Override
35:     public void onSubscribe(String key, int num) {
36:     }
37: 
38:     @Override
39:     public void onPSubscribe(String pattern, int num) {
40:     }
41: 
42:     @Override
43:     public void onUnsubscribe(String key, int num) {
44:     }
45: 
46:     @Override
47:     public void onPUnsubscribe(String pattern, int num) {
48:     }
49: 
50: }
```

- 实现了 `#onMessage(key, msg)` 和 `#onPMessage(pattern, key, msg)` 方法，收到 `register` `unregister` 事件，调用 `#doNotify(jedis, key)` 方法，通知监听器，数据变化，从而实现**实时**更新。

## 5. 可靠性

> FROM [《Dubbo 用户指南 —— Redis 注册中心》](http://dubbo.apache.org/zh-cn/docs/user/references/registry/redis.html)
>
> 阿里内部并没有采用 Redis 做为注册中心，而是使用自己实现的基于数据库的注册中心，即：Redis 注册中心并没有在阿里内部长时间运行的可靠性保障，此 Redis 桥接实现只为开源版本提供，其可靠性依赖于 Redis 本身的可靠性。

> FROM [《Dubbo 用户指南 —— 成熟度》](http://dubbo.apache.org/zh-cn/docs/user/maturity.html)
>
> Redis注册中心
>
> - Maturity：Stable
> - Strength：支持基于客户端双写的集群方式，性能高
> - Problem：要求服务器时间同步，用于检查心跳过期脏数据
> - Advise：可用于生产环境

做个小笔记，Redis 主从复制的情况下，从节点的订阅( Subscribe )，可以收到主节点的发布( Publish ) 。做这个笔记的原因是，原来担心 `"failover"` 模式下，Redis 主节点挂了，如果订阅从节点，会不会出现，Redis 主节点恢复后，收不到在其上的发布事件。

