# 1. æ¦‚è¿°

æœ¬æ–‡ï¼Œæˆ‘ä»¬æ¥åˆ†äº« MyBatis çš„ç±»å‹æ¨¡å—ï¼Œå¯¹åº” `type` åŒ…ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š[![`type` åŒ…](http://static.iocoder.cn/images/MyBatis/2020_01_25/01.png)](http://static.iocoder.cn/images/MyBatis/2020_01_25/01.png)`type` åŒ…

åœ¨ [ã€Šç²¾å°½ MyBatis æºç è§£æ â€”â€” é¡¹ç›®ç»“æ„ä¸€è§ˆã€‹](http://svip.iocoder.cn/MyBatis/intro) ä¸­ï¼Œç®€å•ä»‹ç»äº†è¿™ä¸ªæ¨¡å—å¦‚ä¸‹ï¼š

> â‘  MyBatis ä¸ºç®€åŒ–é…ç½®æ–‡ä»¶æä¾›äº†**åˆ«åæœºåˆ¶**ï¼Œè¯¥æœºåˆ¶æ˜¯ç±»å‹è½¬æ¢æ¨¡å—çš„ä¸»è¦åŠŸèƒ½ä¹‹ä¸€ã€‚
>
> â‘¡ ç±»å‹è½¬æ¢æ¨¡å—çš„å¦ä¸€ä¸ªåŠŸèƒ½æ˜¯**å®ç° JDBC ç±»å‹ä¸ Java ç±»å‹ä¹‹é—´**çš„è½¬æ¢ï¼Œè¯¥åŠŸèƒ½åœ¨ä¸º SQL è¯­å¥ç»‘å®šå®å‚ä»¥åŠæ˜ å°„æŸ¥è¯¢ç»“æœé›†æ—¶éƒ½ä¼šæ¶‰åŠï¼š
>
> - åœ¨ä¸º SQL è¯­å¥ç»‘å®šå®å‚æ—¶ï¼Œä¼šå°†æ•°æ®ç”± Java ç±»å‹è½¬æ¢æˆ JDBC ç±»å‹ã€‚
> - è€Œåœ¨æ˜ å°„ç»“æœé›†æ—¶ï¼Œä¼šå°†æ•°æ®ç”± JDBC ç±»å‹è½¬æ¢æˆ Java ç±»å‹ã€‚

æœ¬æ–‡æ¶‰åŠçš„ç±»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š[![ç±»å›¾](http://static.iocoder.cn/images/MyBatis/2020_01_25/02.png)](http://static.iocoder.cn/images/MyBatis/2020_01_25/02.png)ç±»å›¾

# 2. TypeHandler

`org.apache.ibatis.type.TypeHandler` ï¼Œç±»å‹è½¬æ¢å¤„ç†å™¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandler.java

public interface TypeHandler<T> {

    /**
     * è®¾ç½® PreparedStatement çš„æŒ‡å®šå‚æ•°
     *
     * Java Type => JDBC Type
     *
     * @param ps PreparedStatement å¯¹è±¡
     * @param i å‚æ•°å ä½ç¬¦çš„ä½ç½®
     * @param parameter å‚æ•°
     * @param jdbcType JDBC ç±»å‹
     * @throws SQLException å½“å‘ç”Ÿ SQL å¼‚å¸¸æ—¶
     */
    void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

    /**
     * è·å¾— ResultSet çš„æŒ‡å®šå­—æ®µçš„å€¼
     *
     * JDBC Type => Java Type
     *
     * @param rs ResultSet å¯¹è±¡
     * @param columnName å­—æ®µå
     * @return å€¼
     * @throws SQLException å½“å‘ç”Ÿ SQL å¼‚å¸¸æ—¶
     */
    T getResult(ResultSet rs, String columnName) throws SQLException;

    /**
     * è·å¾— ResultSet çš„æŒ‡å®šå­—æ®µçš„å€¼
     *
     * JDBC Type => Java Type
     *
     * @param rs ResultSet å¯¹è±¡
     * @param columnIndex å­—æ®µä½ç½®
     * @return å€¼
     * @throws SQLException å½“å‘ç”Ÿ SQL å¼‚å¸¸æ—¶
     */
    T getResult(ResultSet rs, int columnIndex) throws SQLException;

    /**
     * è·å¾— CallableStatement çš„æŒ‡å®šå­—æ®µçš„å€¼
     *
     * JDBC Type => Java Type
     *
     * @param cs CallableStatement å¯¹è±¡ï¼Œæ”¯æŒè°ƒç”¨å­˜å‚¨è¿‡ç¨‹
     * @param columnIndex å­—æ®µä½ç½®
     * @return å€¼
     * @throws SQLException
     */
    T getResult(CallableStatement cs, int columnIndex) throws SQLException;

}
```

- ä¸€å…±æœ‰ä¸¤ç±»æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ï¼š

  - `#setParameter(...)` æ–¹æ³•ï¼Œæ˜¯ `Java Type => JDBC Type` çš„è¿‡ç¨‹ã€‚
  - `#getResult(...)` æ–¹æ³•ï¼Œæ˜¯ `JDBC Type => Java Type` çš„è¿‡ç¨‹ã€‚

- æµç¨‹å¦‚ä¸‹å›¾ï¼š

  ![æµç¨‹](http://static.iocoder.cn/images/MyBatis/2020_01_25/03.png)

  æµç¨‹

  - å·¦è¾¹æ˜¯ `#setParameter(...)` æ–¹æ³•ï¼Œæ˜¯ `Java Type => JDBC Type` çš„è¿‡ç¨‹ï¼Œä»ä¸Šå¾€ä¸‹çœ‹ã€‚
  - å³è¾¹æ˜¯ `#getResult(...)` æ–¹æ³•ï¼Œæ˜¯ `JDBC Type => Java Type` çš„è¿‡ç¨‹ï¼Œä»ä¸‹å¾€ä¸Šçœ‹ã€‚

## 2.1 BaseTypeHandler

`org.apache.ibatis.type.BaseTypeHandler` ï¼Œå®ç° TypeHandler æ¥å£ï¼Œç»§æ‰¿ TypeReference æŠ½è±¡ç±»ï¼ŒTypeHandler åŸºç¡€æŠ½è±¡ç±»ã€‚

- å…³äº TypeReference ï¼Œæˆ‘ä»¬åœ¨ [ã€Œ3. TypeHandlerã€](http://svip.iocoder.cn/MyBatis/type-package/#) ä¸­ï¼Œè¯¦ç»†è§£æã€‚

### 2.1.1 setParameter

`#setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// BaseTypeHandler.java

@Override
public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {
    // <1> å‚æ•°ä¸ºç©ºæ—¶ï¼Œè®¾ç½®ä¸º null ç±»å‹
    if (parameter == null) {
        if (jdbcType == null) {
            throw new TypeException("JDBC requires that the JdbcType must be specified for all nullable parameters.");
        }
        try {
            ps.setNull(i, jdbcType.TYPE_CODE);
        } catch (SQLException e) {
            throw new TypeException("Error setting null for parameter #" + i + " with JdbcType " + jdbcType + " . " +
                    "Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. " +
                    "Cause: " + e, e);
        }
    // å‚æ•°éç©ºæ—¶ï¼Œè®¾ç½®å¯¹åº”çš„å‚æ•°
    } else {
        try {
            setNonNullParameter(ps, i, parameter, jdbcType);
        } catch (Exception e) {
            throw new TypeException("Error setting non null for parameter #" + i + " with JdbcType " + jdbcType + " . " +
                    "Try setting a different JdbcType for this parameter or a different configuration property. " +
                    "Cause: " + e, e);
        }
    }
}
```

- `<1>` å¤„ï¼Œå‚æ•°ä¸ºç©ºï¼Œè®¾ç½®ä¸º `null` ç±»å‹ã€‚

- `<2>` å¤„ï¼Œå‚æ•°éç©ºï¼Œè°ƒç”¨ `#setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType)` **æŠ½è±¡**æ–¹æ³•ï¼Œè®¾ç½®å¯¹åº”çš„å‚æ•°ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // BaseTypeHandler.java
  
  public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;
  ```

  - è¯¥æ–¹æ³•ç”±å­ç±»å®ç°ã€‚

- å½“å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œç»Ÿä¸€æŠ›å‡º TypeException å¼‚å¸¸ã€‚

### 2.1.2 getResult

`#getResult(...)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// BaseTypeHandler.java

@Override
public T getResult(ResultSet rs, String columnName) throws SQLException {
    try {
        return getNullableResult(rs, columnName);
    } catch (Exception e) {
        throw new ResultMapException("Error attempting to get column '" + columnName + "' from result set.  Cause: " + e, e);
    }
}

@Override
public T getResult(ResultSet rs, int columnIndex) throws SQLException {
    try {
        return getNullableResult(rs, columnIndex);
    } catch (Exception e) {
        throw new ResultMapException("Error attempting to get column #" + columnIndex + " from result set.  Cause: " + e, e);
    }
}

@Override
public T getResult(CallableStatement cs, int columnIndex) throws SQLException {
    try {
        return getNullableResult(cs, columnIndex);
    } catch (Exception e) {
        throw new ResultMapException("Error attempting to get column #" + columnIndex + " from callable statement.  Cause: " + e, e);
    }
}
```

- è°ƒç”¨ `#getNullableResult(...)` **æŠ½è±¡**æ–¹æ³•ï¼Œè·å¾—æŒ‡å®šç»“æœçš„å­—æ®µå€¼ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // BaseTypeHandler.java
  
  public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;
  
  public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;
  
  public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException;
  ```

  - è¯¥æ–¹æ³•ç”±å­ç±»å®ç°ã€‚

- å½“å‘ç”Ÿå¼‚å¸¸æ—¶ï¼Œç»Ÿä¸€æŠ›å‡º ResultMapException å¼‚å¸¸ã€‚

## 2.2 å­ç±»

TypeHandler æœ‰éå¸¸å¤šçš„å­ç±»ï¼Œ**å½“ç„¶æ‰€æœ‰å­ç±»éƒ½æ˜¯ç»§æ‰¿è‡ª BaseTypeHandler æŠ½è±¡ç±»**ã€‚è€ƒè™‘åˆ°ç¯‡å¹…ï¼Œæˆ‘ä»¬å°±æŒ‘é€‰å‡ ä¸ªæ¥èŠèŠã€‚

### 2.2.1 IntegerTypeHandler

`org.apache.ibatis.type.IntegerTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒInteger ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// IntegerTypeHandler.java

public class IntegerTypeHandler extends BaseTypeHandler<Integer> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)
            throws SQLException {
        // ç›´æ¥è®¾ç½®å‚æ•°å³å¯
        ps.setInt(i, parameter);
    }

    @Override
    public Integer getNullableResult(ResultSet rs, String columnName)
            throws SQLException {
        // è·å¾—å­—æ®µçš„å€¼
        int result = rs.getInt(columnName);
        // å…ˆé€šè¿‡ rs åˆ¤æ–­æ˜¯å¦ç©ºï¼Œå¦‚æœæ˜¯ç©ºï¼Œåˆ™è¿”å› null ï¼Œå¦åˆ™è¿”å› result
        return (result == 0 && rs.wasNull()) ? null : result;
    }

    @Override
    public Integer getNullableResult(ResultSet rs, int columnIndex)
            throws SQLException {
        // è·å¾—å­—æ®µçš„å€¼
        int result = rs.getInt(columnIndex);
        // å…ˆé€šè¿‡ rs åˆ¤æ–­æ˜¯å¦ç©ºï¼Œå¦‚æœæ˜¯ç©ºï¼Œåˆ™è¿”å› null ï¼Œå¦åˆ™è¿”å› result
        return (result == 0 && rs.wasNull()) ? null : result;
    }

    @Override
    public Integer getNullableResult(CallableStatement cs, int columnIndex)
            throws SQLException {
        // è·å¾—å­—æ®µçš„å€¼
        int result = cs.getInt(columnIndex);
        // å…ˆé€šè¿‡ cs åˆ¤æ–­æ˜¯å¦ç©ºï¼Œå¦‚æœæ˜¯ç©ºï¼Œåˆ™è¿”å› null ï¼Œå¦åˆ™è¿”å› result
        return (result == 0 && cs.wasNull()) ? null : result;
    }
}
```

- æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹ç…ç…ã€‚æ¯”è¾ƒæœ‰æ„æ€çš„æ˜¯ `ResultSet#wasNull()` æ–¹æ³•ï¼Œå®ƒä¼šåˆ¤æ–­**æœ€åè¯»å–**çš„å­—æ®µæ˜¯å¦ä¸ºç©ºã€‚

### 2.2.2 DateTypeHandler

`org.apache.ibatis.type.DateTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒDate ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DateTypeHandler.java

public class DateTypeHandler extends BaseTypeHandler<Date> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType)
            throws SQLException {
        // å°† Date è½¬æ¢æˆ Timestamp ç±»å‹
        // ç„¶åè®¾ç½®åˆ° ps ä¸­
        ps.setTimestamp(i, new Timestamp(parameter.getTime()));
    }

    @Override
    public Date getNullableResult(ResultSet rs, String columnName)
            throws SQLException {
        // è·å¾— Timestamp çš„å€¼
        Timestamp sqlTimestamp = rs.getTimestamp(columnName);
        // å°† Timestamp è½¬æ¢æˆ Date ç±»å‹
        if (sqlTimestamp != null) {
            return new Date(sqlTimestamp.getTime());
        }
        return null;
    }

    @Override
    public Date getNullableResult(ResultSet rs, int columnIndex)
            throws SQLException {
        // è·å¾— Timestamp çš„å€¼
        Timestamp sqlTimestamp = rs.getTimestamp(columnIndex);
        // å°† Timestamp è½¬æ¢æˆ Date ç±»å‹
        if (sqlTimestamp != null) {
            return new Date(sqlTimestamp.getTime());
        }
        return null;
    }

    @Override
    public Date getNullableResult(CallableStatement cs, int columnIndex)
            throws SQLException {
        // è·å¾— Timestamp çš„å€¼
        Timestamp sqlTimestamp = cs.getTimestamp(columnIndex);
        // å°† Timestamp è½¬æ¢æˆ Date ç±»å‹
        if (sqlTimestamp != null) {
            return new Date(sqlTimestamp.getTime());
        }
        return null;
    }

}
```

- `java.util.Date` å’Œ `java.sql.Timestamp` çš„äº’ç›¸è½¬æ¢ã€‚

### 2.2.3 DateOnlyTypeHandler

`org.apache.ibatis.type.DateOnlyTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒDate ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// DateOnlyTypeHandler.java

public class DateOnlyTypeHandler extends BaseTypeHandler<Date> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType)
            throws SQLException {
        // å°† java Date è½¬æ¢æˆ sql Date ç±»å‹
        ps.setDate(i, new java.sql.Date(parameter.getTime()));
    }

    @Override
    public Date getNullableResult(ResultSet rs, String columnName)
            throws SQLException {
        // è·å¾— sql Date çš„å€¼
        java.sql.Date sqlDate = rs.getDate(columnName);
        // å°† sql Date è½¬æ¢æˆ java Date ç±»å‹
        if (sqlDate != null) {
            return new Date(sqlDate.getTime());
        }
        return null;
    }

    @Override
    public Date getNullableResult(ResultSet rs, int columnIndex)
            throws SQLException {
        // è·å¾— sql Date çš„å€¼
        java.sql.Date sqlDate = rs.getDate(columnIndex);
        // å°† sql Date è½¬æ¢æˆ java Date ç±»å‹
        if (sqlDate != null) {
            return new Date(sqlDate.getTime());
        }
        return null;
    }

    @Override
    public Date getNullableResult(CallableStatement cs, int columnIndex)
            throws SQLException {
        // è·å¾— sql Date çš„å€¼
        java.sql.Date sqlDate = cs.getDate(columnIndex);
        // å°† sql Date è½¬æ¢æˆ java Date ç±»å‹
        if (sqlDate != null) {
            return new Date(sqlDate.getTime());
        }
        return null;
    }

}
```

- `java.util.Date` å’Œ `java.sql.Date` çš„äº’ç›¸è½¬æ¢ã€‚
- æ•°æ®åº“é‡Œçš„æ—¶é—´æœ‰å¤šç§ç±»å‹ï¼Œä»¥ MySQL ä¸¾ä¾‹å­ï¼Œæœ‰ `date`ã€`timestamp`ã€`datetime` ä¸‰ç§ç±»å‹ã€‚

### 2.2.4 EnumTypeHandler

`org.apache.ibatis.type.EnumTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒEnum ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// EnumTypeHandler.java

public class EnumTypeHandler<E extends Enum<E>> extends BaseTypeHandler<E> {

    /**
     * æšä¸¾ç±»
     */
    private final Class<E> type;

    public EnumTypeHandler(Class<E> type) {
        if (type == null) {
            throw new IllegalArgumentException("Type argument cannot be null");
        }
        this.type = type;
    }

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, E parameter, JdbcType jdbcType) throws SQLException {
        // å°† Enum è½¬æ¢æˆ String ç±»å‹
        if (jdbcType == null) {
            ps.setString(i, parameter.name());
        } else {
            ps.setObject(i, parameter.name(), jdbcType.TYPE_CODE); // see r3589
        }
    }

    @Override
    public E getNullableResult(ResultSet rs, String columnName) throws SQLException {
        // è·å¾— String çš„å€¼
        String s = rs.getString(columnName);
        // å°† String è½¬æ¢æˆ Enum ç±»å‹
        return s == null ? null : Enum.valueOf(type, s);
    }

    @Override
    public E getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        // è·å¾— String çš„å€¼
        String s = rs.getString(columnIndex);
        // å°† String è½¬æ¢æˆ Enum ç±»å‹
        return s == null ? null : Enum.valueOf(type, s);
    }

    @Override
    public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        // è·å¾— String çš„å€¼
        String s = cs.getString(columnIndex);
        // å°† String è½¬æ¢æˆ Enum ç±»å‹
        return s == null ? null : Enum.valueOf(type, s);
    }

}
```

- `java.lang.Enum` å’Œ `java.util.String` çš„äº’ç›¸è½¬æ¢ã€‚
- å› ä¸ºæ•°æ®åº“ä¸å­˜åœ¨æšä¸¾ç±»å‹ï¼Œæ‰€ä»¥è®²æšä¸¾ç±»å‹æŒä¹…åŒ–åˆ°æ•°æ®åº“æœ‰ä¸¤ç§æ–¹å¼ï¼Œ`Enum.name <=> String` å’Œ `Enum.ordinal <=> int` ã€‚æˆ‘ä»¬ç›®å‰çœ‹åˆ°çš„ EnumTypeHandler æ˜¯å‰è€…ï¼Œä¸‹é¢æˆ‘ä»¬å°†çœ‹åˆ°çš„ EnumOrdinalTypeHandler æ˜¯åè€…ã€‚

### 2.2.5 EnumOrdinalTypeHandler

`org.apache.ibatis.type.EnumOrdinalTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒEnum ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// EnumOrdinalTypeHandler.java

public class EnumOrdinalTypeHandler<E extends Enum<E>> extends BaseTypeHandler<E> {

    /**
     * æšä¸¾ç±»
     */
    private final Class<E> type;
    /**
     * {@link #type} ä¸‹æ‰€æœ‰çš„æšä¸¾
     *
     * @see Class#getEnumConstants()
     */
    private final E[] enums;

    public EnumOrdinalTypeHandler(Class<E> type) {
        if (type == null) {
            throw new IllegalArgumentException("Type argument cannot be null");
        }
        this.type = type;
        this.enums = type.getEnumConstants();
        if (this.enums == null) {
            throw new IllegalArgumentException(type.getSimpleName() + " does not represent an enum type.");
        }
    }

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, E parameter, JdbcType jdbcType) throws SQLException {
        // å°† Enum è½¬æ¢æˆ int ç±»å‹
        ps.setInt(i, parameter.ordinal());
    }

    @Override
    public E getNullableResult(ResultSet rs, String columnName) throws SQLException {
        // è·å¾— int çš„å€¼
        int i = rs.getInt(columnName);
        // å°† int è½¬æ¢æˆ Enum ç±»å‹
        if (i == 0 && rs.wasNull()) {
            return null;
        } else {
            try {
                return enums[i];
            } catch (Exception ex) {
                throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by ordinal value.", ex);
            }
        }
    }

    @Override
    public E getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        // è·å¾— int çš„å€¼
        int i = rs.getInt(columnIndex);
        // å°† int è½¬æ¢æˆ Enum ç±»å‹
        if (i == 0 && rs.wasNull()) {
            return null;
        } else {
            try {
                return enums[i];
            } catch (Exception ex) {
                throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by ordinal value.", ex);
            }
        }
    }

    @Override
    public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        // è·å¾— int çš„å€¼
        int i = cs.getInt(columnIndex);
        // å°† int è½¬æ¢æˆ Enum ç±»å‹
        if (i == 0 && cs.wasNull()) {
            return null;
        } else {
            try {
                return enums[i];
            } catch (Exception ex) {
                throw new IllegalArgumentException("Cannot convert " + i + " to " + type.getSimpleName() + " by ordinal value.", ex);
            }
        }
    }

}
```

- `java.lang.Enum` å’Œ `int` çš„äº’ç›¸è½¬æ¢ã€‚

### 2.2.6 ObjectTypeHandler

`org.apache.ibatis.type.ObjectTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼ŒObject ç±»å‹çš„ TypeHandler å®ç°ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ObjectTypeHandler.java

public class ObjectTypeHandler extends BaseTypeHandler<Object> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType)
            throws SQLException {
        ps.setObject(i, parameter);
    }

    @Override
    public Object getNullableResult(ResultSet rs, String columnName)
            throws SQLException {
        return rs.getObject(columnName);
    }

    @Override
    public Object getNullableResult(ResultSet rs, int columnIndex)
            throws SQLException {
        return rs.getObject(columnIndex);
    }

    @Override
    public Object getNullableResult(CallableStatement cs, int columnIndex)
            throws SQLException {
        return cs.getObject(columnIndex);
    }

}
```

### 2.2.7 UnknownTypeHandler

`org.apache.ibatis.type.UnknownTypeHandler` ï¼Œç»§æ‰¿ BaseTypeHandler æŠ½è±¡ç±»ï¼Œ**æœªçŸ¥çš„** TypeHandler å®ç°ç±»ã€‚é€šè¿‡è·å–å¯¹åº”çš„ TypeHandler ï¼Œè¿›è¡Œå¤„ç†ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// UnknownTypeHandler.java

public class UnknownTypeHandler extends BaseTypeHandler<Object> {

    /**
     * ObjectTypeHandler å•ä¾‹
     */
    private static final ObjectTypeHandler OBJECT_TYPE_HANDLER = new ObjectTypeHandler();

    /**
     * TypeHandler æ³¨å†Œè¡¨
     */
    private TypeHandlerRegistry typeHandlerRegistry;

    public UnknownTypeHandler(TypeHandlerRegistry typeHandlerRegistry) {
        this.typeHandlerRegistry = typeHandlerRegistry;
    }

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType)
            throws SQLException {
        // è·å¾—å‚æ•°å¯¹åº”çš„å¤„ç†å™¨
        TypeHandler handler = resolveTypeHandler(parameter, jdbcType); // <1>
        // ä½¿ç”¨ handler è®¾ç½®å‚æ•°
        handler.setParameter(ps, i, parameter, jdbcType);
    }

    @Override
    public Object getNullableResult(ResultSet rs, String columnName)
            throws SQLException {
        // è·å¾—å‚æ•°å¯¹åº”çš„å¤„ç†å™¨
        TypeHandler<?> handler = resolveTypeHandler(rs, columnName); // <2>
        // ä½¿ç”¨ handler è·å¾—å€¼
        return handler.getResult(rs, columnName);
    }

    @Override
    public Object getNullableResult(ResultSet rs, int columnIndex)
            throws SQLException {
        // è·å¾—å‚æ•°å¯¹åº”çš„å¤„ç†å™¨
        TypeHandler<?> handler = resolveTypeHandler(rs.getMetaData(), columnIndex); // <3>
        // å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„å¤„ç†å™¨ï¼Œä½¿ç”¨ OBJECT_TYPE_HANDLER
        if (handler == null || handler instanceof UnknownTypeHandler) {
            handler = OBJECT_TYPE_HANDLER;
        }
        // ä½¿ç”¨ handler è·å¾—å€¼
        return handler.getResult(rs, columnIndex);
    }

    @Override
    public Object getNullableResult(CallableStatement cs, int columnIndex)
            throws SQLException {
        return cs.getObject(columnIndex);
    }

    private TypeHandler<? extends Object> resolveTypeHandler(Object parameter, JdbcType jdbcType) { // <1>
        TypeHandler<? extends Object> handler;
        // å‚æ•°ä¸ºç©ºï¼Œè¿”å› OBJECT_TYPE_HANDLER
        if (parameter == null) {
            handler = OBJECT_TYPE_HANDLER;
        // å‚æ•°éç©ºï¼Œä½¿ç”¨å‚æ•°ç±»å‹è·å¾—å¯¹åº”çš„ TypeHandler
        } else {
            handler = typeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType);
            // check if handler is null (issue #270)
            // è·å–ä¸åˆ°ï¼Œåˆ™ä½¿ç”¨ OBJECT_TYPE_HANDLER
            if (handler == null || handler instanceof UnknownTypeHandler) {
                handler = OBJECT_TYPE_HANDLER;
            }
        }
        return handler;
    }

    private TypeHandler<?> resolveTypeHandler(ResultSet rs, String column) {
        try {
            // è·å¾— columnIndex
            Map<String, Integer> columnIndexLookup = new HashMap<>();
            ResultSetMetaData rsmd = rs.getMetaData(); // é€šè¿‡ metaData
            int count = rsmd.getColumnCount();
            for (int i = 1; i <= count; i++) {
                String name = rsmd.getColumnName(i);
                columnIndexLookup.put(name, i);
            }
            Integer columnIndex = columnIndexLookup.get(column);
            TypeHandler<?> handler = null;
            // é¦–å…ˆï¼Œé€šè¿‡ columnIndex è·å¾— TypeHandler
            if (columnIndex != null) {
                handler = resolveTypeHandler(rsmd, columnIndex); // <3>
            }
            // è·å¾—ä¸åˆ°ï¼Œä½¿ç”¨ OBJECT_TYPE_HANDLER
            if (handler == null || handler instanceof UnknownTypeHandler) {
                handler = OBJECT_TYPE_HANDLER;
            }
            return handler;
        } catch (SQLException e) {
            throw new TypeException("Error determining JDBC type for column " + column + ".  Cause: " + e, e);
        }
    }

    private TypeHandler<?> resolveTypeHandler(ResultSetMetaData rsmd, Integer columnIndex) { // <3>
        TypeHandler<?> handler = null;
        // è·å¾— JDBC Type ç±»å‹
        JdbcType jdbcType = safeGetJdbcTypeForColumn(rsmd, columnIndex);
        // è·å¾— Java Type ç±»å‹
        Class<?> javaType = safeGetClassForColumn(rsmd, columnIndex);
        //è·å¾—å¯¹åº”çš„ TypeHandler å¯¹è±¡
        if (javaType != null && jdbcType != null) {
            handler = typeHandlerRegistry.getTypeHandler(javaType, jdbcType);
        } else if (javaType != null) {
            handler = typeHandlerRegistry.getTypeHandler(javaType);
        } else if (jdbcType != null) {
            handler = typeHandlerRegistry.getTypeHandler(jdbcType);
        }
        return handler;
    }

    private JdbcType safeGetJdbcTypeForColumn(ResultSetMetaData rsmd, Integer columnIndex) {
        try {
            // ä» ResultSetMetaData ä¸­ï¼Œè·å¾—å­—æ®µç±»å‹
            // è·å¾— JDBC Type
            return JdbcType.forCode(rsmd.getColumnType(columnIndex));
        } catch (Exception e) {
            return null;
        }
    }

    private Class<?> safeGetClassForColumn(ResultSetMetaData rsmd, Integer columnIndex) {
        try {
            // ä» ResultSetMetaData ä¸­ï¼Œè·å¾—å­—æ®µç±»å‹
            // è·å¾— Java Type
            return Resources.classForName(rsmd.getColumnClassName(columnIndex));
        } catch (Exception e) {
            return null;
        }
    }
    
}
```

- ä»£ç æ¯”è¾ƒç®€å•ï¼Œèƒ–å‹è‡ªå·±ç…ç…ã€‚

# 3. TypeReference

`org.apache.ibatis.type.TypeReference` ï¼Œå¼•ç”¨æ³›å‹æŠ½è±¡ç±»ã€‚ç›®çš„å¾ˆç®€å•ï¼Œå°±æ˜¯è§£æç±»ä¸Šå®šä¹‰çš„æ³›å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeReference.java

public abstract class TypeReference<T> {

    /**
     * æ³›å‹
     */
    private final Type rawType;

    protected TypeReference() {
        rawType = getSuperclassTypeParameter(getClass());
    }

    Type getSuperclassTypeParameter(Class<?> clazz) {
        // ã€1ã€‘ä»çˆ¶ç±»ä¸­è·å– <T>
        Type genericSuperclass = clazz.getGenericSuperclass();
        if (genericSuperclass instanceof Class) {
            // èƒ½æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„ï¼Œä¾‹å¦‚ GenericTypeSupportedInHierarchiesTestCase.CustomStringTypeHandler è¿™ä¸ªç±»
            // try to climb up the hierarchy until meet something useful
            if (TypeReference.class != genericSuperclass) { // æ’é™¤ TypeReference ç±»
                return getSuperclassTypeParameter(clazz.getSuperclass());
            }

            throw new TypeException("'" + getClass() + "' extends TypeReference but misses the type parameter. "
                    + "Remove the extension or add a type parameter to it.");
        }

        // ã€2ã€‘è·å– <T>
        Type rawType = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0];
        // TODO remove this when Reflector is fixed to return Types
        // å¿…é¡»æ˜¯æ³›å‹ï¼Œæ‰è·å– <T>
        if (rawType instanceof ParameterizedType) {
            rawType = ((ParameterizedType) rawType).getRawType();
        }

        return rawType;
    }

    public final Type getRawType() {
        return rawType;
    }

    @Override
    public String toString() {
        return rawType.toString();
    }

}
```

- ä¸¾ä¸ªä¾‹å­ï¼Œ[ã€Œ2.2.1 IntegerTypeHandlerã€](http://svip.iocoder.cn/MyBatis/type-package/#) è§£æåçš„ç»“æœ `rawType` ä¸º Integer ã€‚

- `ã€1ã€‘` å¤„ï¼Œä»çˆ¶ç±»ä¸­è·å– `<T>` ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  // GenericTypeSupportedInHierarchiesTestCase.java çš„å†…éƒ¨é™æ€ç±»
  
  public static final class CustomStringTypeHandler extends StringTypeHandler {
  
      /**
       * Defined as reported in #581
       */
      @Override
      public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
          // do something
          super.setNonNullParameter(ps, i, parameter, jdbcType);
      }
  
  }
  ```

  - å› ä¸º CustomStringTypeHandler è‡ªèº«æ˜¯æ²¡æœ‰æ³›å‹çš„ï¼Œéœ€è¦ä»çˆ¶ç±» StringTypeHandler ä¸­è·å–ã€‚å¹¶ä¸”ï¼Œè·å–çš„ç»“æœä¼šæ˜¯ `rawType` ä¸º String ã€‚

- `ã€2ã€‘` å¤„ï¼Œä»å½“å‰ç±»è·å– `<T>` ã€‚

# 4. æ³¨è§£

`type` åŒ…ä¸­ï¼Œä¹Ÿå®šä¹‰äº†ä¸‰ä¸ªæ³¨è§£ï¼Œæˆ‘ä»¬é€ä¸ªæ¥çœ‹çœ‹ã€‚

## 4.1 @MappedTypes

`org.apache.ibatis.type.@MappedTypes` ï¼ŒåŒ¹é…çš„ Java Type ç±»å‹çš„æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// MappedTypes.java

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE) // æ³¨å†Œåˆ°ç±»
public @interface MappedTypes {

    /**
     * @return åŒ¹é…çš„ Java Type ç±»å‹çš„æ•°ç»„
     */
    Class<?>[] value();

}
```

## 4.2 @MappedJdbcTypes

`org.apache.ibatis.type.@MappedJdbcTypes` ï¼ŒåŒ¹é…çš„ JDBC Type ç±»å‹çš„æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// MappedJdbcTypes.java

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE) // æ³¨å†Œåˆ°ç±»
public @interface MappedJdbcTypes {

    /**
     * @return åŒ¹é…çš„ JDBC Type ç±»å‹çš„æ³¨è§£
     */
    JdbcType[] value();

    /**
     * @return æ˜¯å¦åŒ…å« {@link java.sql.JDBCType#NULL}
     */
    boolean includeNullJdbcType() default false;

}
```

## 4.3 Alias

`org.apache.ibatis.type.@Alias` ï¼Œåˆ«åçš„æ³¨è§£ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// Alias.java

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Alias {

    /**
     * @return åˆ«å
     */
    String value();

}
```

# 5. JdbcType

`org.apache.ibatis.type.JdbcType` ï¼ŒJdbc Type æšä¸¾ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// JdbcType.java

public enum JdbcType {

    /*
     * This is added to enable basic support for the
     * ARRAY data type - but a custom type handler is still required
     */
    ARRAY(Types.ARRAY),
    BIT(Types.BIT),
    TINYINT(Types.TINYINT),
    SMALLINT(Types.SMALLINT),
    INTEGER(Types.INTEGER),
    BIGINT(Types.BIGINT),
    FLOAT(Types.FLOAT),
    REAL(Types.REAL),
    DOUBLE(Types.DOUBLE),
    NUMERIC(Types.NUMERIC),
    DECIMAL(Types.DECIMAL),
    CHAR(Types.CHAR),
    VARCHAR(Types.VARCHAR),
    LONGVARCHAR(Types.LONGVARCHAR),
    DATE(Types.DATE),
    TIME(Types.TIME),
    TIMESTAMP(Types.TIMESTAMP),
    BINARY(Types.BINARY),
    VARBINARY(Types.VARBINARY),
    LONGVARBINARY(Types.LONGVARBINARY),
    NULL(Types.NULL),
    OTHER(Types.OTHER),
    BLOB(Types.BLOB),
    CLOB(Types.CLOB),
    BOOLEAN(Types.BOOLEAN),
    CURSOR(-10), // Oracle
    UNDEFINED(Integer.MIN_VALUE + 1000),
    NVARCHAR(Types.NVARCHAR), // JDK6
    NCHAR(Types.NCHAR), // JDK6
    NCLOB(Types.NCLOB), // JDK6
    STRUCT(Types.STRUCT),
    JAVA_OBJECT(Types.JAVA_OBJECT),
    DISTINCT(Types.DISTINCT),
    REF(Types.REF),
    DATALINK(Types.DATALINK),
    ROWID(Types.ROWID), // JDK6
    LONGNVARCHAR(Types.LONGNVARCHAR), // JDK6
    SQLXML(Types.SQLXML), // JDK6
    DATETIMEOFFSET(-155); // SQL Server 2008

    /**
     * ç±»å‹ç¼–å·ã€‚å˜¿å˜¿ï¼Œæ­¤å¤„ä»£ç ä¸è§„èŒƒ
     */
    public final int TYPE_CODE;

    /**
     * ä»£ç ç¼–å·å’Œ {@link JdbcType} çš„æ˜ å°„
     */
    private static Map<Integer, JdbcType> codeLookup = new HashMap<>();

    static {
        // åˆå§‹åŒ– codeLookup
        for (JdbcType type : JdbcType.values()) {
            codeLookup.put(type.TYPE_CODE, type);
        }
    }

    JdbcType(int code) {
        this.TYPE_CODE = code;
    }

    public static JdbcType forCode(int code) {
        return codeLookup.get(code);
    }

}
```

# 6. TypeHandlerRegistry

`org.apache.ibatis.type.TypeHandlerRegistry` ï¼ŒTypeHandler æ³¨å†Œè¡¨ï¼Œç›¸å½“äºç®¡ç† TypeHandler çš„å®¹å™¨ï¼Œä»å…¶ä¸­èƒ½è·å–åˆ°å¯¹åº”çš„ TypeHandler ã€‚

## 6.1 æ„é€ æ–¹æ³•

```
// TypeHandlerRegistry.java

/**
 * ç©º TypeHandler é›†åˆçš„æ ‡è¯†ï¼Œå³ä½¿ {@link #TYPE_HANDLER_MAP} ä¸­ï¼ŒæŸä¸ª KEY1 å¯¹åº”çš„ Map<JdbcType, TypeHandler<?>> ä¸ºç©ºã€‚
 *
 * @see #getJdbcHandlerMap(Type)
 */
private static final Map<JdbcType, TypeHandler<?>> NULL_TYPE_HANDLER_MAP = Collections.emptyMap();

/**
 * JDBC Type å’Œ {@link TypeHandler} çš„æ˜ å°„
 *
 * {@link #register(JdbcType, TypeHandler)}
 */
private final Map<JdbcType, TypeHandler<?>> JDBC_TYPE_HANDLER_MAP = new EnumMap<>(JdbcType.class);
/**
 * {@link TypeHandler} çš„æ˜ å°„
 *
 * KEY1ï¼šJDBC Type
 * KEY2ï¼šJava Type
 * VALUEï¼š{@link TypeHandler} å¯¹è±¡
 */
private final Map<Type, Map<JdbcType, TypeHandler<?>>> TYPE_HANDLER_MAP = new ConcurrentHashMap<>();
/**
 * æ‰€æœ‰ TypeHandler çš„â€œé›†åˆâ€
 *
 * KEYï¼š{@link TypeHandler#getClass()}
 * VALUEï¼š{@link TypeHandler} å¯¹è±¡
 */
private final Map<Class<?>, TypeHandler<?>> ALL_TYPE_HANDLERS_MAP = new HashMap<>();

/**
 * {@link UnknownTypeHandler} å¯¹è±¡
 */
private final TypeHandler<Object> UNKNOWN_TYPE_HANDLER = new UnknownTypeHandler(this);
/**
 * é»˜è®¤çš„æšä¸¾ç±»å‹çš„ TypeHandler å¯¹è±¡
 */
private Class<? extends TypeHandler> defaultEnumTypeHandler = EnumTypeHandler.class;

public TypeHandlerRegistry() {
    // ... çœç•¥å…¶å®ƒç±»å‹çš„æ³¨å†Œ

    // <1>
    register(Date.class, new DateTypeHandler());
    register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());
    register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());
    // <2>
    register(JdbcType.TIMESTAMP, new DateTypeHandler());
    register(JdbcType.DATE, new DateOnlyTypeHandler());
    register(JdbcType.TIME, new TimeOnlyTypeHandler());

    // ... çœç•¥å…¶å®ƒç±»å‹çš„æ³¨å†Œ
}
```

- ```
  TYPE_HANDLER_MAP
  ```

   

  å±æ€§ï¼ŒTypeHandler çš„æ˜ å°„ã€‚

  - ä¸€ä¸ª Java Type å¯ä»¥å¯¹åº”å¤šä¸ª JDBC Type ï¼Œä¹Ÿå°±æ˜¯å¤šä¸ª TypeHandler ï¼Œæ‰€ä»¥ Map çš„ç¬¬ä¸€å±‚çš„å€¼æ˜¯ `Map<JdbcType, TypeHandler<?>` ã€‚åœ¨ `<1>` å¤„ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼ŒDate å¯¹åº”äº†å¤šä¸ª JDBC çš„ TypeHandler çš„æ³¨å†Œã€‚
  - å½“ä¸€ä¸ª Java Type ä¸å­˜åœ¨å¯¹åº”çš„ JDBC Type æ—¶ï¼Œå°±ä½¿ç”¨ `NULL_TYPE_HANDLER_MAP` **é™æ€**å±æ€§ï¼Œæ·»åŠ åˆ° `TYPE_HANDLER_MAP` ä¸­è¿›è¡Œå ä½ã€‚

- ```
  JDBC_TYPE_HANDLER_MAP
  ```

   

  å±æ€§ï¼ŒJDBC Type å’Œ TypeHandler çš„æ˜ å°„ã€‚

  - ä¸€ä¸ª JDBC Type åªå¯¹åº”ä¸€ä¸ª Java Type ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ª TypeHandler ï¼Œä¸åŒäº `TYPE_HANDLER_MAP` å±æ€§ã€‚åœ¨ `<2>` å¤„ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä¸‰ä¸ªæ—¶é—´ç±»å‹çš„ JdbcType æ³¨å†Œåˆ° `JDBC_TYPE_HANDLER_MAP` ä¸­ã€‚
  - é‚£ä¹ˆå¯èƒ½ä¼šæœ‰èƒ–å‹é—®ï¼Œ`JDBC_TYPE_HANDLER_MAP` æ˜¯**ä¸€ä¸€**æ˜ å°„ï¼Œç®€å•å°±å¯ä»¥è·å¾— JDBC Type å¯¹åº”çš„ TypeHandler ï¼Œè€Œ `TYPE_HANDLER_MAP` æ˜¯**ä¸€å¯¹å¤š**æ˜ å°„ï¼Œä¸€ä¸ª JavaType æ€ä¹ˆè·å–åˆ°å¯¹åº”çš„ TypeHandler å‘¢ï¼Ÿç»§ç»­å¾€ä¸‹çœ‹ï¼Œç­”æ¡ˆåœ¨ `#getTypeHandler(Type type, JdbcType jdbcType)` æ–¹æ³•ã€‚

- `ALL_TYPE_HANDLERS_MAP` å±æ€§ï¼Œæ‰€æœ‰ TypeHandler çš„â€œé›†åˆâ€ ã€‚

- `UNKNOWN_TYPE_HANDLER` å±æ€§ï¼ŒUnknownTypeHandler å¯¹è±¡ï¼Œç”¨äº Object ç±»å‹çš„æ³¨å†Œã€‚

- `defaultEnumTypeHandler` å±æ€§ï¼Œé»˜è®¤çš„æšä¸¾ç±»å‹çš„ TypeHandler å¯¹è±¡ã€‚

- åœ¨æ„é€ æ–¹æ³•ä¸­ï¼Œæœ‰é»˜è®¤çš„ Java Type å’Œ JDBC Type å¯¹ TypeHandler çš„æ³¨å†Œï¼Œå› ä¸ºæœ‰ä¸¢ä¸¢å¤šï¼Œæ‰€ä»¥è¢«è‰¿è‰¿çœç•¥äº†ã€‚

- å¦å¤–ï¼Œè¿™é‡Œçš„å˜é‡å‘½åæ˜¯ä¸ç¬¦åˆ Java å‘½åè§„èŒƒï¼Œä¸è¦å­¦ä¹ ã€‚

## 6.2 getInstance

`#getInstance(Class<?> javaTypeClass, Class<?> typeHandlerClass)` æ–¹æ³•ï¼Œåˆ›å»º TypeHandler å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java

public <T> TypeHandler<T> getInstance(Class<?> javaTypeClass, Class<?> typeHandlerClass) {
    // è·å¾— Class ç±»å‹çš„æ„é€ æ–¹æ³•
    if (javaTypeClass != null) {
        try {
            Constructor<?> c = typeHandlerClass.getConstructor(Class.class);
            return (TypeHandler<T>) c.newInstance(javaTypeClass); // ç¬¦åˆè¿™ä¸ªæ¡ä»¶çš„ï¼Œä¾‹å¦‚ EnumTypeHandler
        } catch (NoSuchMethodException ignored) {
            // ignored å¿½ç•¥è¯¥å¼‚å¸¸ï¼Œç»§ç»­å‘ä¸‹
        } catch (Exception e) {
            throw new TypeException("Failed invoking constructor for handler " + typeHandlerClass, e);
        }
    }
    // <2> è·å¾—ç©ºå‚çš„æ„é€ æ–¹æ³•
    try {
        Constructor<?> c = typeHandlerClass.getConstructor();
        return (TypeHandler<T>) c.newInstance(); // ç¬¦åˆè¿™ä¸ªæ¡ä»¶çš„ï¼Œä¾‹å¦‚ IntegerTypeHandler
    } catch (Exception e) {
        throw new TypeException("Unable to find a usable constructor for " + typeHandlerClass, e);
    }
}
```

- `<1>` å¤„ï¼Œè·å¾— Class ç±»å‹çš„æ„é€ æ–¹æ³•ï¼Œé€‚åˆ [ã€Œ2.2.4 EnumTypeHandlerã€](http://svip.iocoder.cn/MyBatis/type-package/#) çš„æƒ…å†µã€‚
- `<2>` å¤„ï¼Œè·å¾—ç©ºå‚çš„æ„é€ æ–¹æ³•ï¼Œé€‚åˆ [ã€Œ2.2.1 IntegerTypeHandlerã€](http://svip.iocoder.cn/MyBatis/type-package/#) çš„æƒ…å†µã€‚

## 6.3 register

`#register(...)` æ–¹æ³•ï¼Œæ³¨å†Œ TypeHandler ã€‚TypeHandlerRegistry ä¸­æœ‰å¤§é‡è¯¥æ–¹æ³•çš„é‡è½½å®ç°ï¼Œå¤§ä½“æ•´ç†å¦‚ä¸‹ï¼š

> FROM å¾éƒ¡æ˜ [ã€ŠMyBatis æŠ€æœ¯å†…å¹•ã€‹](https://item.jd.com/12125531.html)
>
> [![register æ–¹æ³•](http://static.iocoder.cn/images/MyBatis/2020_01_25/04.png)](http://static.iocoder.cn/images/MyBatis/2020_01_25/04.png)register æ–¹æ³•

é™¤äº† â‘¤ ä»¥å¤–ï¼Œæ‰€æœ‰æ–¹æ³•æœ€ç»ˆéƒ½ä¼šè°ƒç”¨ â‘£ ï¼Œå³ `#register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java

private void register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler) {
    // <1> æ·»åŠ  handler åˆ° TYPE_HANDLER_MAP ä¸­
    if (javaType != null) {
        // è·å¾— Java Type å¯¹åº”çš„ map
        Map<JdbcType, TypeHandler<?>> map = TYPE_HANDLER_MAP.get(javaType);
        if (map == null || map == NULL_TYPE_HANDLER_MAP) { // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿›è¡Œåˆ›å»º
            map = new HashMap<>();
            TYPE_HANDLER_MAP.put(javaType, map);
        }
        // æ·»åŠ åˆ° handler ä¸­ map ä¸­
        map.put(jdbcType, handler);
    }
    // <2> æ·»åŠ  handler åˆ° ALL_TYPE_HANDLERS_MAP ä¸­
    ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);
}
```

- `<1>` å¤„ï¼Œæ·»åŠ  `handler` åˆ° `TYPE_HANDLER_MAP` ä¸­ã€‚
- `<2>` å¤„ï¼Œæ·»åŠ  `handler` åˆ° `ALL_TYPE_HANDLERS_MAP` ä¸­ã€‚
- è¿™ä¸ªæ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæˆ‘ä»¬çœ‹çœ‹å…¶ä»–è°ƒç”¨çš„æ–¹æ³•ã€‚

â‘  `#register(String packageName)` æ–¹æ³•ï¼Œæ‰«ææŒ‡å®šåŒ…ä¸‹çš„æ‰€æœ‰ TypeHandler ç±»ï¼Œå¹¶å‘èµ·æ³¨å†Œã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java
    
public void register(String packageName) {
    // æ‰«ææŒ‡å®šåŒ…ä¸‹çš„æ‰€æœ‰ TypeHandler ç±»
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
    resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);
    Set<Class<? extends Class<?>>> handlerSet = resolverUtil.getClasses();
    // éå† TypeHandler æ•°ç»„ï¼Œå‘èµ·æ³¨å†Œ
    for (Class<?> type : handlerSet) {
        //Ignore inner classes and interfaces (including package-info.java) and abstract classes
        // æ’é™¤åŒ¿åç±»ã€æ¥å£ã€æŠ½è±¡ç±»
        if (!type.isAnonymousClass() && !type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
            register(type);
        }
    }
}
```

- åœ¨æ–¹æ³•ï¼Œä¼šè°ƒç”¨ â‘¥ `#register(Class<?> typeHandlerClass)` æ–¹æ³•ï¼Œæ³¨å†ŒæŒ‡å®š TypeHandler **ç±»**ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  public void register(Class<?> typeHandlerClass) {
      boolean mappedTypeFound = false;
      // <3> è·å¾— @MappedTypes æ³¨è§£
      MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);
      if (mappedTypes != null) {
          // éå†æ³¨è§£çš„ Java Type æ•°ç»„ï¼Œé€ä¸ªè¿›è¡Œæ³¨å†Œ
          for (Class<?> javaTypeClass : mappedTypes.value()) {
              register(javaTypeClass, typeHandlerClass);
              mappedTypeFound = true;
          }
      }
      // <4> æœªä½¿ç”¨ @MappedTypes æ³¨è§£ï¼Œåˆ™ç›´æ¥æ³¨å†Œ
      if (!mappedTypeFound) {
          register(getInstance(null, typeHandlerClass)); // åˆ›å»º TypeHandler å¯¹è±¡
      }
  }
  ```

  - åˆ†æˆ `<3>` `<4>` ä¸¤ç§æƒ…å†µã€‚

  - `<3>` å¤„ï¼Œ**åŸºäº** `@MappedTypes` æ³¨è§£ï¼Œè°ƒç”¨ `#register(Class<?> javaTypeClass, Class<?> typeHandlerClass)` æ–¹æ³•ï¼Œæ³¨å†ŒæŒ‡å®š Java Type çš„æŒ‡å®š TypeHandler **ç±»**ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    // TypeHandlerRegistry.java
    
    public void register(Class<?> javaTypeClass, Class<?> typeHandlerClass) {
        register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass)); // åˆ›å»º TypeHandler å¯¹è±¡
    }
    ```

    - è°ƒç”¨ â‘¢ `#register(Class<T> javaType, TypeHandler<? extends T> typeHandler)` æ–¹æ³•ï¼Œæ³¨å†ŒæŒ‡å®š Java Type çš„æŒ‡å®š TypeHandler **å¯¹è±¡**ã€‚ä»£ç å¦‚ä¸‹ï¼š

      ```
      // TypeHandlerRegistry.java
      
      private <T> void register(Type javaType, TypeHandler<? extends T> typeHandler) {
          // è·å¾— MappedJdbcTypes æ³¨è§£
          MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);
          if (mappedJdbcTypes != null) {
              // éå† MappedJdbcTypes æ³¨å†Œçš„ JDBC Type è¿›è¡Œæ³¨å†Œ
              for (JdbcType handledJdbcType : mappedJdbcTypes.value()) {
                  register(javaType, handledJdbcType, typeHandler);
              }
              if (mappedJdbcTypes.includeNullJdbcType()) {
                  // <5>
                  register(javaType, null, typeHandler); // jdbcType = null
              }
          } else {
              // <5>
              register(javaType, null, typeHandler); // jdbcType = null
          }
      }
      ```

      - **æœ‰** `@MappedJdbcTypes` æ³¨è§£çš„ â‘£ `#register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler)` æ–¹æ³•ï¼Œå‘èµ·**æœ€ç»ˆ**æ³¨å†Œã€‚
      - å¯¹äº `<5>` å¤„ï¼Œå‘èµ·æ³¨å†Œæ—¶ï¼Œ`jdbcType` å‚æ•°ä¸º `null` ï¼Œè¿™æ˜¯ä¸ºå•¥ï¼ŸğŸ˜ˆ ä¸‹æ–‡è¯¦ç»†è§£æã€‚

  - `<4>` å¤„ï¼Œè°ƒç”¨ â‘¡ `#register(TypeHandler<T> typeHandler)` æ–¹æ³•ï¼Œ**æœªä½¿ç”¨** `@MappedTypes` æ³¨è§£ï¼Œè°ƒç”¨ `#register(TypeHandler<T> typeHandler)` æ–¹æ³•ï¼Œæ³¨å†Œ TypeHandler å¯¹è±¡ã€‚ä»£ç å¦‚ä¸‹ï¼š

    ```
    // TypeHandlerRegistry.java
    
    public <T> void register(TypeHandler<T> typeHandler) {
        boolean mappedTypeFound = false;
        // <5> è·å¾— @MappedTypes æ³¨è§£
        MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);
        // ä¼˜å…ˆï¼Œä½¿ç”¨ @MappedTypes æ³¨è§£çš„ Java Type è¿›è¡Œæ³¨å†Œ
        if (mappedTypes != null) {
            for (Class<?> handledType : mappedTypes.value()) {
                register(handledType, typeHandler);
                mappedTypeFound = true;
            }
        }
        // @since 3.1.0 - try to auto-discover the mapped type
        // <6> å…¶æ¬¡ï¼Œå½“ typeHandler ä¸º TypeReference å­ç±»æ—¶ï¼Œè¿›è¡Œæ³¨å†Œ
        if (!mappedTypeFound && typeHandler instanceof TypeReference) {
            try {
                TypeReference<T> typeReference = (TypeReference<T>) typeHandler;
                register(typeReference.getRawType(), typeHandler); // Java Type ä¸º <T> æ³›å‹
                mappedTypeFound = true;
            } catch (Throwable t) {
                // maybe users define the TypeReference with a different type and are not assignable, so just ignore it
            }
        }
        // <7> æœ€å·®ï¼Œä½¿ç”¨ Java Type ä¸º null è¿›è¡Œæ³¨å†Œ
        if (!mappedTypeFound) {
            register((Class<T>) null, typeHandler);
        }
    }
    ```

    - åˆ†æˆä¸‰ç§æƒ…å†µï¼Œæœ€ç»ˆéƒ½æ˜¯è°ƒç”¨ `#register(Type javaType, TypeHandler<? extends T> typeHandler)` æ–¹æ³•ï¼Œè¿›è¡Œæ³¨å†Œï¼Œä¹Ÿå°±æ˜¯è·³åˆ° â‘¢ ã€‚
    - `<5>` å¤„ï¼Œä¼˜å…ˆï¼Œæœ‰ç¬¦åˆçš„ `@MappedTypes` æ³¨è§£æ—¶ï¼Œä½¿ç”¨ `@MappedTypes` æ³¨è§£çš„ Java Type è¿›è¡Œæ³¨å†Œã€‚
    - `<6>` å¤„ï¼Œå…¶æ¬¡ï¼Œå½“ `typeHandler` ä¸º TypeReference å­ç±»æ—¶ï¼Œä½¿ç”¨ `<T>` ä½œä¸º Java Type è¿›è¡Œæ³¨å†Œã€‚
    - `<7>` å¤„ï¼Œæœ€å·®ï¼Œä½¿ç”¨ `null` ä½œä¸º Java Type è¿›è¡Œæ³¨å†Œã€‚ä½†æ˜¯ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œåªä¼šå°† `typeHandler` æ·»åŠ åˆ° `ALL_TYPE_HANDLERS_MAP` ä¸­ã€‚å› ä¸ºï¼Œå®é™…ä¸Šæ²¡æœ‰ Java Type ã€‚

å› ä¸ºé‡è½½çš„æ–¹æ³•æœ‰ç‚¹å¤šï¼Œç†è§£èµ·æ¥å¯èƒ½æ¯”è¾ƒç»•ï¼Œèƒ–å‹å¯èƒ½ä¼šæ¯”è¾ƒé—·é€¼ã€‚å“ˆå“ˆå“ˆï¼Œå®é™…åœ¨è‡ªå·±å†™çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿæœ‰ç‚¹æ‡µé€¼ã€‚é‚£æ€ä¹ˆåŠï¼Ÿå¤§ä½“ç†è§£å°±å¥½ï¼Œå¦å¤– `@MappedTypes` å’Œ `@MappedJdbcTypes` è¿™ä¸¤ä¸ªæ³¨è§£åŸºæœ¬ä¸ä¼šç”¨åˆ°ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å…ˆâ€œå¿½ç•¥â€ã€‚

å¦å¤–ï¼Œ`#register(...)` æ–¹æ³•ï¼Œè¿˜æœ‰å…¶å®ƒé‡è½½æ–¹æ³•ï¼Œèƒ–å‹å¯ä»¥è‡ªå·±ç¿»ä¸‹ã€‚

------

â‘¤ `#register(JdbcType jdbcType, TypeHandler<?> handler)` æ–¹æ³•ï¼Œæ³¨å†Œ `handler` åˆ° `JDBC_TYPE_HANDLER_MAP` ä¸­ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java

public void register(JdbcType jdbcType, TypeHandler<?> handler) {
    JDBC_TYPE_HANDLER_MAP.put(jdbcType, handler);
}
```

- å’Œä¸Šè¿°çš„ `#register(...)` æ–¹æ³•æ˜¯ä¸åŒçš„ã€‚

## 6.4 getTypeHandler

`#getTypeHandler(...)` æ–¹æ³•ï¼Œè·å¾— TypeHandler ã€‚TypeHandlerRegistry æœ‰å¤§é‡è¯¥æ–¹æ³•çš„é‡è½½å®ç°ï¼Œå¤§ä½“æ•´ä½“å¦‚ä¸‹ï¼š

> FROM å¾éƒ¡æ˜ [ã€ŠMyBatis æŠ€æœ¯å†…å¹•ã€‹](https://item.jd.com/12125531.html)
>
> [![getTypeHandler æ–¹æ³•](http://static.iocoder.cn/images/MyBatis/2020_01_25/05.png)](http://static.iocoder.cn/images/MyBatis/2020_01_25/05.png)getTypeHandler æ–¹æ³•

ä»å›¾ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ â‘  å¤„çš„ `#getTypeHandler(Type type, JdbcType jdbcType)` æ–¹æ³•ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä¸‰ç§è°ƒç”¨çš„æƒ…å†µï¼š

- è°ƒç”¨æƒ…å†µä¸€ï¼š`#getTypeHandler(Class<T> type)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  public <T> TypeHandler<T> getTypeHandler(Class<T> type) {
      return getTypeHandler((Type) type, null);
  }
  ```

  - `jdbcType` ä¸º `null` ã€‚

- è°ƒç”¨æƒ…å†µäºŒï¼š`#getTypeHandler(Class<T> type, JdbcType jdbcType)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  public <T> TypeHandler<T> getTypeHandler(Class<T> type, JdbcType jdbcType) {
      return getTypeHandler((Type) type, jdbcType);
  }
  ```

  - å°† `type` è½¬æ¢æˆ Type ç±»å‹ã€‚

- è°ƒç”¨æƒ…å†µä¸‰ï¼š`#getTypeHandler(TypeReference<T> javaTypeReference, ...)` æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  public <T> TypeHandler<T> getTypeHandler(TypeReference<T> javaTypeReference) {
      return getTypeHandler(javaTypeReference, null);
  }
  
  public <T> TypeHandler<T> getTypeHandler(TypeReference<T> javaTypeReference, JdbcType jdbcType) {
      return getTypeHandler(javaTypeReference.getRawType(), jdbcType);
  }
  ```

  - ä½¿ç”¨ `<T>` æ³›å‹ä½œä¸º `type` ã€‚

ä¸‹é¢ï¼Œæ­£å¼æ¥çœ‹çœ‹ â‘  å¤„çš„ `#getTypeHandler(Type type, JdbcType jdbcType)` æ–¹æ³•ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java

private <T> TypeHandler<T> getTypeHandler(Type type, JdbcType jdbcType) {
    // å¿½ç•¥ ParamMap çš„æƒ…å†µ
    if (ParamMap.class.equals(type)) {
        return null;
    }
    // <1> è·å¾— Java Type å¯¹åº”çš„ TypeHandler é›†åˆ
    Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = getJdbcHandlerMap(type);
    TypeHandler<?> handler = null;
    if (jdbcHandlerMap != null) {
        // <2.1> ä¼˜å…ˆï¼Œä½¿ç”¨ jdbcType è·å–å¯¹åº”çš„ TypeHandler
        handler = jdbcHandlerMap.get(jdbcType);
        // <2.2> å…¶æ¬¡ï¼Œä½¿ç”¨ null è·å–å¯¹åº”çš„ TypeHandler ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯é»˜è®¤çš„ TypeHandler
        if (handler == null) {
            handler = jdbcHandlerMap.get(null);
        }
        // <2.3> æœ€å·®ï¼Œä» TypeHandler é›†åˆä¸­é€‰æ‹©ä¸€ä¸ªå”¯ä¸€çš„ TypeHandler
        if (handler == null) {
            // #591
            handler = pickSoleHandler(jdbcHandlerMap);
        }
    }
    // type drives generics here
    return (TypeHandler<T>) handler;
}
```

- `<1>` å¤„ï¼Œè°ƒç”¨ `#getJdbcHandlerMap(Type type)` æ–¹æ³•ï¼Œè·å¾— Java Type å¯¹åº”çš„ TypeHandler é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMap(Type type) {
      // <1.1> è·å¾— Java Type å¯¹åº”çš„ TypeHandler é›†åˆ
      Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = TYPE_HANDLER_MAP.get(type);
      // <1.2> å¦‚æœä¸º NULL_TYPE_HANDLER_MAP ï¼Œæ„å‘³ç€ä¸ºç©ºï¼Œç›´æ¥è¿”å›
      if (NULL_TYPE_HANDLER_MAP.equals(jdbcHandlerMap)) {
          return null;
      }
      // <1.3> å¦‚æœæ‰¾ä¸åˆ°
      if (jdbcHandlerMap == null && type instanceof Class) {
          Class<?> clazz = (Class<?>) type;
          // æšä¸¾ç±»å‹
          if (clazz.isEnum()) {
              // è·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆ
              jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(clazz, clazz);
              // å¦‚æœæ‰¾ä¸åˆ°
              if (jdbcHandlerMap == null) {
                  // æ³¨å†Œ defaultEnumTypeHandler ï¼Œå¹¶ä½¿ç”¨å®ƒ
                  register(clazz, getInstance(clazz, defaultEnumTypeHandler));
                  // è¿”å›ç»“æœ
                  return TYPE_HANDLER_MAP.get(clazz);
              }
          // éæšä¸¾ç±»å‹
          } else {
              // è·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆ
              jdbcHandlerMap = getJdbcHandlerMapForSuperclass(clazz);
          }
      }
      // <1.4> å¦‚æœç»“æœä¸ºç©ºï¼Œè®¾ç½®ä¸º NULL_TYPE_HANDLER_MAP ï¼Œæå‡æŸ¥æ‰¾é€Ÿåº¦ï¼Œé¿å…äºŒæ¬¡æŸ¥æ‰¾
      TYPE_HANDLER_MAP.put(type, jdbcHandlerMap == null ? NULL_TYPE_HANDLER_MAP : jdbcHandlerMap);
      // è¿”å›ç»“æœ
      return jdbcHandlerMap;
  }
  ```

  - `<1.1>` å¤„ï¼Œè·å¾— Java Type å¯¹åº”çš„ TypeHandler é›†åˆã€‚

  - `<1.2>` å¤„ï¼Œå¦‚æœä¸º `NULL_TYPE_HANDLER_MAP` ï¼Œæ„å‘³ç€ä¸ºç©ºï¼Œç›´æ¥è¿”å›ã€‚åŸå› å¯è§ `<1.4>` å¤„ã€‚

  - `<1.3>` å¤„ï¼Œæ‰¾ä¸åˆ°ï¼Œåˆ™æ ¹æ® `type` æ˜¯å¦ä¸ºæšä¸¾ç±»å‹ï¼Œè¿›è¡Œä¸åŒå¤„ç†ã€‚

    - ã€æšä¸¾ã€‘

    - å…ˆè°ƒç”¨ `#getJdbcHandlerMapForEnumInterfaces(Class<?> clazz, Class<?> enumClazz)` æ–¹æ³•ï¼Œ è·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

      ```
      // TypeHandlerRegistry.java
      
      private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMapForEnumInterfaces(Class<?> clazz, Class<?> enumClazz) {
          // éå†æšä¸¾ç±»çš„æ‰€æœ‰æ¥å£
          for (Class<?> iface : clazz.getInterfaces()) {
              // è·å¾—è¯¥æ¥å£å¯¹åº”çš„ jdbcHandlerMap é›†åˆ
              Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = TYPE_HANDLER_MAP.get(iface);
              // ä¸ºç©ºï¼Œé€’å½’ getJdbcHandlerMapForEnumInterfaces æ–¹æ³•ï¼Œç»§ç»­ä»çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆ
              if (jdbcHandlerMap == null) {
                  jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(iface, enumClazz);
              }
              // å¦‚æœæ‰¾åˆ°ï¼Œåˆ™ä» jdbcHandlerMap åˆå§‹åŒ–ä¸­ newMap ä¸­ï¼Œå¹¶è¿›è¡Œè¿”å›
              if (jdbcHandlerMap != null) {
                  // Found a type handler regsiterd to a super interface
                  HashMap<JdbcType, TypeHandler<?>> newMap = new HashMap<>();
                  for (Entry<JdbcType, TypeHandler<?>> entry : jdbcHandlerMap.entrySet()) {
                      // Create a type handler instance with enum type as a constructor arg
                      newMap.put(entry.getKey(), getInstance(enumClazz, entry.getValue().getClass()));
                  }
                  return newMap;
              }
          }
          // æ‰¾ä¸åˆ°ï¼Œåˆ™è¿”å› null
          return null;
      }
      ```

      - ä»£ç æ¯”è¾ƒç®€å•ï¼Œçœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

    - æ‰¾ä¸åˆ°ï¼Œåˆ™æ³¨å†Œ `defaultEnumTypeHandler` ï¼Œå¹¶ä½¿ç”¨å®ƒã€‚

    - ã€éæšä¸¾ã€‘

    - è°ƒç”¨ `#getJdbcHandlerMapForSuperclass(Class<?> clazz)` æ–¹æ³•ï¼Œè·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆã€‚ä»£ç å¦‚ä¸‹ï¼š

      ```
      // TypeHandlerRegistry.java
      
      private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMapForSuperclass(Class<?> clazz) {
          // è·å¾—çˆ¶ç±»
          Class<?> superclass = clazz.getSuperclass();
          // ä¸å­˜åœ¨é Object çš„çˆ¶ç±»ï¼Œè¿”å› null
          if (superclass == null || Object.class.equals(superclass)) {
              return null;
          }
          // è·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆ
          Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = TYPE_HANDLER_MAP.get(superclass);
          // æ‰¾åˆ°ï¼Œåˆ™ç›´æ¥è¿”å›
          if (jdbcHandlerMap != null) {
              return jdbcHandlerMap;
          // æ‰¾ä¸åˆ°ï¼Œåˆ™é€’å½’ getJdbcHandlerMapForSuperclass æ–¹æ³•ï¼Œç»§ç»­è·å¾—çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆ
          } else {
              return getJdbcHandlerMapForSuperclass(superclass);
          }
      }
      ```

      - ä»£ç æ¯”è¾ƒç®€å•ï¼Œçœ‹ä¸‹ä»£ç æ³¨é‡Šã€‚

  - `<1.4>` å¤„ï¼Œå¦‚æœç»“æœä¸ºç©ºï¼Œè®¾ç½®ä¸º `NULL_TYPE_HANDLER_MAP` ï¼Œæå‡æŸ¥æ‰¾é€Ÿåº¦ï¼Œé¿å…äºŒæ¬¡æŸ¥æ‰¾ã€‚

- `<2.1>` å¤„ï¼Œä¼˜å…ˆï¼Œä½¿ç”¨ `jdbcType` è·å–å¯¹åº”çš„ TypeHandler ã€‚

- `<2.2>` å¤„ï¼Œå…¶æ¬¡ï¼Œä½¿ç”¨ `null` è·å–å¯¹åº”çš„ TypeHandler ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯**é»˜è®¤**çš„ TypeHandler ã€‚è¿™é‡Œæ˜¯è§£å†³ä¸€ä¸ª Java Type å¯èƒ½å¯¹åº”å¤šä¸ª TypeHandler çš„**æ–¹å¼ä¹‹ä¸€**ã€‚

- `<2.3>` å¤„ï¼Œæœ€å·®ï¼Œè°ƒç”¨ `#pickSoleHandler(Map<JdbcType, TypeHandler<?>> jdbcHandlerMap)` æ–¹æ³•ï¼Œä» TypeHandler é›†åˆä¸­é€‰æ‹©ä¸€ä¸ª**å”¯ä¸€**çš„ TypeHandler ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeHandlerRegistry.java
  
  private TypeHandler<?> pickSoleHandler(Map<JdbcType, TypeHandler<?>> jdbcHandlerMap) {
      TypeHandler<?> soleHandler = null;
      for (TypeHandler<?> handler : jdbcHandlerMap.values()) {
          // é€‰æ‹©ä¸€ä¸ª
          if (soleHandler == null) {
              soleHandler = handler;
          // å¦‚æœè¿˜æœ‰ï¼Œå¹¶ä¸”ä¸åŒç±»ï¼Œé‚£ä¹ˆä¸å¥½é€‰æ‹©ï¼Œæ‰€ä»¥è¿”å› null
          } else if (!handler.getClass().equals(soleHandler.getClass())) {
              // More than one type handlers registered.
              return null;
          }
      }
      return soleHandler;
  }
  ```

  - è¿™æ®µä»£ç çœ‹èµ·æ¥æ¯”è¾ƒç»•ï¼Œå…¶å®ç›®çš„å¾ˆæ¸…æ™°ï¼Œå°±æ˜¯é€‰æ‹©**ç¬¬ä¸€ä¸ª**ï¼Œå¹¶ä¸”ä¸èƒ½æœ‰å…¶å®ƒçš„**ä¸åŒç±»**çš„å¤„ç†å™¨ã€‚
  - è¿™é‡Œæ˜¯è§£å†³ä¸€ä¸ª Java Type å¯èƒ½å¯¹åº”å¤šä¸ª TypeHandler çš„**æ–¹å¼ä¹‹ä¸€**ã€‚

- é€šè¿‡ `<2.1>` + `<2.2>` + `<2.3>` ä¸‰å¤„ï¼Œè§£å†³ Java Type å¯¹åº”çš„ TypeHandler é›†åˆã€‚

------

`#getTypeHandler(JdbcType jdbcType)` æ–¹æ³•ï¼Œè·å¾— `jdbcType` å¯¹åº”çš„ TypeHandler ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeHandlerRegistry.java

public TypeHandler<?> getTypeHandler(JdbcType jdbcType) {
    return JDBC_TYPE_HANDLER_MAP.get(jdbcType);
}
```

# 7. TypeAliasRegistry

`org.apache.ibatis.type.TypeAliasRegistry` ï¼Œç±»å‹ä¸åˆ«åçš„æ³¨å†Œè¡¨ã€‚é€šè¿‡åˆ«åï¼Œæˆ‘ä»¬åœ¨ Mapper XML ä¸­çš„ `resultType` å’Œ `parameterType` å±æ€§ï¼Œç›´æ¥ä½¿ç”¨ï¼Œè€Œä¸ç”¨å†™å…¨ç±»åã€‚

## 7.1 æ„é€ æ–¹æ³•

```
// TypeAliasRegistry.java

/**
 * ç±»å‹ä¸åˆ«åçš„æ˜ å°„ã€‚
 */
private final Map<String, Class<?>> TYPE_ALIASES = new HashMap<>();

/**
 * åˆå§‹åŒ–é»˜è®¤çš„ç±»å‹ä¸åˆ«å
 *
 * å¦å¤–ï¼Œåœ¨ {@link org.apache.ibatis.session.Configuration} æ„é€ æ–¹æ³•ä¸­ï¼Œä¹Ÿæœ‰é»˜è®¤çš„æ³¨å†Œ
 */
public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);

    // ... çœç•¥å…¶ä»–æ³¨å†Œè°ƒç”¨
}
```

- `TYPE_ALIASES` å±æ€§ï¼Œç±»å‹ä¸åˆ«åçš„æ˜ å°„ã€‚
- æ„é€ æ–¹æ³•ï¼Œåˆå§‹åŒ–é»˜è®¤çš„ç±»å‹ä¸åˆ«åã€‚
- å¦å¤–ï¼Œåœ¨ `org.apache.ibatis.session.Configuration` æ„é€ æ–¹æ³•ä¸­ï¼Œä¹Ÿæœ‰é»˜è®¤çš„æ³¨å†Œç±»å‹ä¸åˆ«åã€‚

## 7.2 registerAlias

`#registerAlias(Class<?> type)` æ–¹æ³•ï¼Œæ³¨å†ŒæŒ‡å®šç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeAliasRegistry.java

public void registerAlias(Class<?> type) {
    // <1> é»˜è®¤ä¸ºï¼Œç®€å•ç±»å
    String alias = type.getSimpleName();
    // <2> å¦‚æœæœ‰æ³¨è§£ï¼Œä½¿ç”¨æ³¨å†Œä¸Šçš„åå­—
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) {
        alias = aliasAnnotation.value();
    }
    // <3> æ³¨å†Œç±»å‹ä¸åˆ«åçš„æ³¨å†Œè¡¨
    registerAlias(alias, type);
}
```

- åˆ«åçš„è§„åˆ™

  - `<1>` ï¼Œé»˜è®¤ä¸ºï¼Œç®€å•ç±»åã€‚
  - `<2>` ï¼Œå¯é€šè¿‡ `@Alias` æ³¨è§£çš„åˆ«åã€‚

- `<3>` ï¼Œè°ƒç”¨ `#registerAlias(String alias, Class<?> value)` æ–¹æ³•ï¼Œæ³¨å†Œç±»å‹ä¸åˆ«åçš„æ³¨å†Œè¡¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

  ```
  // TypeAliasRegistry.java
  
  public void registerAlias(String alias, Class<?> value) {
      if (alias == null) {
          throw new TypeException("The parameter alias cannot be null");
      }
      // issue #748
      // <1> è½¬æ¢æˆå°å†™
      String key = alias.toLowerCase(Locale.ENGLISH);
      if (TYPE_ALIASES.containsKey(key) && TYPE_ALIASES.get(key) != null && !TYPE_ALIASES.get(key).equals(value)) { // <2> å†²çªï¼ŒæŠ›å‡º TypeException å¼‚å¸¸
          throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'.");
      }
      // <3>
      TYPE_ALIASES.put(key, value);
  }
  ```

```
* `<1>` å¤„ï¼Œå°†åˆ«åè½¬æ¢æˆ**å°å†™**ã€‚è¿™æ ·çš„è¯ï¼Œæ— è®ºæˆ‘ä»¬åœ¨ Mapper XML ä¸­ï¼Œå†™ `String` è¿˜æ˜¯ `string` ç”šè‡³æ˜¯ `STRING` ï¼Œéƒ½æ˜¯å¯¹åº”çš„ String ç±»å‹ã€‚ * `<2>` å¤„ï¼Œå¦‚æœå·²ç»æ³¨å†Œï¼Œå¹¶ä¸”ç±»å‹ä¸ä¸€è‡´ï¼Œè¯´æ˜æœ‰å†²çªï¼ŒæŠ›å‡º TypeException å¼‚å¸¸ã€‚ * `<3>` å¤„ï¼Œæ·»åŠ åˆ° `TYPE_ALIASES` ä¸­ã€‚ * å¦å¤–ï¼Œ`#registerAlias(String alias, String value)` æ–¹æ³•ï¼Œä¹Ÿä¼šè°ƒç”¨è¯¥æ–¹æ³•ã€‚ä»£ç å¦‚ä¸‹ï¼š // TypeAliasRegistry.javapublic void registerAlias(String alias, String value) {    try {        registerAlias(alias,                Resources.classForName(value) // é€šè¿‡ç±»åçš„å­—ç¬¦ä¸²ï¼Œè·å¾—å¯¹åº”çš„ç±»ã€‚        );    } catch (ClassNotFoundException e) {        throw new TypeException("Error registering type alias " + alias + " for " + value + ". Cause: " + e, e);    }} 
```

## 7.3 registerAliases

`#registerAliases(String packageName, ...)` æ–¹æ³•ï¼Œæ‰«ææŒ‡å®šåŒ…ä¸‹çš„æ‰€æœ‰ç±»ï¼Œå¹¶è¿›è¡Œæ³¨å†Œã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// TypeAliasRegistry.java

/**
 * æ³¨å†ŒæŒ‡å®šåŒ…ä¸‹çš„åˆ«åä¸ç±»çš„æ˜ å°„
 *
 * @param packageName æŒ‡å®šåŒ…
 */
public void registerAliases(String packageName) {
    registerAliases(packageName, Object.class);
}

/**
 * æ³¨å†ŒæŒ‡å®šåŒ…ä¸‹çš„åˆ«åä¸ç±»çš„æ˜ å°„ã€‚å¦å¤–ï¼Œè¦æ±‚ç±»å¿…é¡»æ˜¯ {@param superType} ç±»å‹ï¼ˆåŒ…æ‹¬å­ç±»ï¼‰ã€‚
 *
 * @param packageName æŒ‡å®šåŒ…
 * @param superType æŒ‡å®šçˆ¶ç±»
 */
public void registerAliases(String packageName, Class<?> superType) {
    // è·å¾—æŒ‡å®šåŒ…ä¸‹çš„ç±»é—¨
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
    // éå†ï¼Œé€ä¸ªæ³¨å†Œç±»å‹ä¸åˆ«åçš„æ³¨å†Œè¡¨
    for (Class<?> type : typeSet) {
        // Ignore inner classes and interfaces (including package-info.java)
        // Skip also inner classes. See issue #6
        if (!type.isAnonymousClass() // æ’é™¤åŒ¿åç±»
                && !type.isInterface()  // æ’é™¤æ¥å£
                && !type.isMemberClass()) { // æ’é™¤å†…éƒ¨ç±»
            registerAlias(type);
        }
    }
}
â€‹```    

## 7.4 resolveAlias

`#resolveAlias(String string)` æ–¹æ³•ï¼Œè·å¾—åˆ«åå¯¹åº”çš„ç±»å‹ã€‚ä»£ç å¦‚ä¸‹ï¼š

â€‹```Java
// TypeAliasRegistry.java

public <T> Class<T> resolveAlias(String string) {
    try {
        if (string == null) {
            return null;
        }
        // issue #748
        // <1> è½¬æ¢æˆå°å†™
        String key = string.toLowerCase(Locale.ENGLISH);
        Class<T> value;
        // <2.1> é¦–å…ˆï¼Œä» TYPE_ALIASES ä¸­è·å–
        if (TYPE_ALIASES.containsKey(key)) {
            value = (Class<T>) TYPE_ALIASES.get(key);
        // <2.2> å…¶æ¬¡ï¼Œç›´æ¥è·å¾—å¯¹åº”ç±»
        } else {
            value = (Class<T>) Resources.classForName(string);
        }
        return value;
    } catch (ClassNotFoundException e) { // <2.3> å¼‚å¸¸
        throw new TypeException("Could not resolve type alias '" + string + "'.  Cause: " + e, e);
    }
}
```

- `<1>` å¤„ï¼Œå°†åˆ«åè½¬æ¢æˆ**å°å†™**ã€‚
- `<2.1>` å¤„ï¼Œé¦–å…ˆï¼Œä» `TYPE_ALIASES` ä¸­è·å–å¯¹åº”çš„ç±»å‹ã€‚
- `<2.2>` å¤„ï¼Œå…¶æ¬¡ï¼Œç›´æ¥è·å–å¯¹åº”çš„ç±»ã€‚æ‰€ä»¥ï¼Œè¿™ä¸ªæ–¹æ³•ï¼ŒåŒæ—¶å¤„ç†äº†åˆ«åä¸å…¨ç±»åä¸¤ç§æƒ…å†µã€‚
- `<2.3>` å¤„ï¼Œæœ€å·®ï¼Œæ‰¾ä¸åˆ°å¯¹åº”çš„ç±»ï¼Œå‘ç”Ÿå¼‚å¸¸ï¼ŒæŠ›å‡º TypeException å¼‚å¸¸ã€‚

# 8. SimpleTypeRegistry

`org.apache.ibatis.type.SimpleTypeRegistry` ï¼Œç®€å•ç±»å‹æ³¨å†Œè¡¨ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// SimpleTypeRegistry.java

public class SimpleTypeRegistry {

    /**
     * ç®€å•ç±»å‹çš„é›†åˆ
     */
    private static final Set<Class<?>> SIMPLE_TYPE_SET = new HashSet<>();

    // åˆå§‹åŒ–å¸¸ç”¨ç±»åˆ° SIMPLE_TYPE_SET ä¸­
    static {
        SIMPLE_TYPE_SET.add(String.class);
        SIMPLE_TYPE_SET.add(Byte.class);
        SIMPLE_TYPE_SET.add(Short.class);
        SIMPLE_TYPE_SET.add(Character.class);
        SIMPLE_TYPE_SET.add(Integer.class);
        SIMPLE_TYPE_SET.add(Long.class);
        SIMPLE_TYPE_SET.add(Float.class);
        SIMPLE_TYPE_SET.add(Double.class);
        SIMPLE_TYPE_SET.add(Boolean.class);
        SIMPLE_TYPE_SET.add(Date.class);
        SIMPLE_TYPE_SET.add(Class.class);
        SIMPLE_TYPE_SET.add(BigInteger.class);
        SIMPLE_TYPE_SET.add(BigDecimal.class);
    }

    private SimpleTypeRegistry() {
        // Prevent Instantiation
    }

    /*
     * Tells us if the class passed in is a known common type
     *
     * @param clazz The class to check
     * @return True if the class is known
     */
    public static boolean isSimpleType(Class<?> clazz) {
        return SIMPLE_TYPE_SET.contains(clazz);
    }

}
```

# 9. ByteArrayUtils

`org.apache.ibatis.type.ByteArrayUtils` ï¼ŒByte æ•°ç»„çš„å·¥å…·ç±»ã€‚ä»£ç å¦‚ä¸‹ï¼š

```
// ByteArrayUtils.java

class ByteArrayUtils {

    private ByteArrayUtils() {
        // Prevent Instantiation
    }

    // Byte[] => byte[]
    static byte[] convertToPrimitiveArray(Byte[] objects) {
        final byte[] bytes = new byte[objects.length];
        for (int i = 0; i < objects.length; i++) {
            bytes[i] = objects[i];
        }
        return bytes;
    }

    // byte[] => Byte[]
    static Byte[] convertToObjectArray(byte[] bytes) {
        final Byte[] objects = new Byte[bytes.length];
        for (int i = 0; i < bytes.length; i++) {
            objects[i] = bytes[i];
        }
        return objects;
    }

}
```

# 666. å½©è›‹

`type` æ¨¡å—çš„ä»£ç ï¼Œè¿˜æ˜¯ç›¸å¯¹å¤šçš„ï¼Œä¸è¿‡æ¯”è¾ƒç®€å•çš„ã€‚

å‚è€ƒå’Œæ¨èå¦‚ä¸‹æ–‡ç« ï¼š

- ç¥–å¤§ä¿Š [ã€ŠMybatis3.3.xæŠ€æœ¯å†…å¹•ï¼ˆåäºŒï¼‰ï¼šMybatisä¹‹TypeHandlerã€‹](https://my.oschina.net/zudajun/blog/671075)
- å¾éƒ¡æ˜ [ã€ŠMyBatis æŠ€æœ¯å†…å¹•ã€‹](https://item.jd.com/12125531.html) çš„ [ã€Œ2.3 ç±»å‹è½¬æ¢ã€](http://svip.iocoder.cn/MyBatis/type-package/#) å°èŠ‚