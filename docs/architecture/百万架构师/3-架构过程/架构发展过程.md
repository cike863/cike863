

# 微服务背景揭秘 SOA

 

1、某业务服务能力由一组服务串联完成(业务角度来讲的)  ***\*DDD\**** , 服务自治

2、颠覆已有技术，进入大规模服务化的流程  (技术角度讲 ，  RD)  rpc feign http(restapi )

3、服务无感知、滚动升级、灰度发布  (运维测 ，OP)

4、服务治理  (平台级的管控能力 ，AI )

5、技术多样性  (技术选型)

解决所有团队的问题：(慢)



 ![](http://cdn.luluwanlong.cn/architecture-process-1.png)



## 巨石程序 vs 微服务 拆分 与 组合

 ![](http://cdn.luluwanlong.cn/architecture-process-2.png) 

## 单体应用的例子



 ![](http://cdn.luluwanlong.cn/architecture-process-3.png) 



## 单体应用拆分

 ![](http://cdn.luluwanlong.cn/architecture-process-4.png)![img](file:///C:\Users\LX\AppData\Local\Temp\ksohtml16400\wps393.jpg) 

## 为什么要使用微服务

dubbo发布的颗粒度为 接口范围

feign 对应的服务颗粒度 ，  发布IP地址  @RequestMapping()

version

<dubbo service version="1.0.1"  interface=""

DDD , 聚合根 代表一个服务的入口

version 1.0.1 ~1.0.9  1.0 ~2.0

消费者

@FeignClient

接口

服务透明化：不需要知道具体服务在何处。

 ![](http://cdn.luluwanlong.cn/architecture-process-5.png) 

 



## 百万架构流量运营微服务实践-中台思想

中台的目标：快速构建不同行业的产品

 ![](http://cdn.luluwanlong.cn/architecture-process-6.png) 



## 大中台对技术平台的需求

 ![](http://cdn.luluwanlong.cn/architecture-process-7.png) 

 ![](http://cdn.luluwanlong.cn/architecture-process-8.png) 



## 百万架构运营大中台建设需要技术平台

 ![](http://cdn.luluwanlong.cn/architecture-process-9.png) 



![img](file:///C:\Users\LX\AppData\Local\Temp\ksohtml16400\wps399.png) 

## Dubbo 体系




 ![](http://cdn.luluwanlong.cn/architecture-process-10.png) 

 

## 服务化后的开发方式转变



 ![](http://cdn.luluwanlong.cn/architecture-process-11.png) 

 

# 互联网架构总体设计

随着互联网从不断快速的发展，从传统的内容推广、信息交互、数据挖掘、人机交互，最终到万物互联 互通，总共已经历了如下4个阶段，而每个阶段，给互联网技术支撑架构带来了什么样的变化呢 ? 这个 是我们值得思考的，而本质的变化量是什么？是数据吗！答案数据是本质。管理数据的方案则称之为管 理架构体系，随着数据之间的关系关联性不断延伸，则管理的本质也随着发生演化。



第一，互联网1.0阶段完成了传统广告业数据化；

- 三大门户网站


第二，互联网2.0阶段完成了内容产业数据化；  ( 用户粘性)

- 微博、  wtitter、instagram、QQ农场、开心农场


第三，移动互联网阶段完成了生活服务业数据化；

- QQ ，微信、陌陌、  facebook 、抖音、钉钉( IM OA SAAS)、短视频、直播平台 第四，万联网阶段，就是万物皆可相连，一切皆被数据化。


-  智能设备(家具，制造)


# 互联网架构升级改造演进过程全解析

假设：

单体架构，每秒1000W QPS ，还需要技术架构演进吗？是否只存在业务架构？

### 客户端形态

-  浏览器


- 手机浏览器wap\H5


- 安卓APP


-  苹果APP


-  小程序

-  应用内程序   (快应用  ，轻量级应用)   业务平台数据隔离

-   window&MAC&PAD客户端

-  广告电子终端
-   电视&移动大屏&智能终端
-  智能机器人 ，智能穿戴设备(+大数据+AI)


## 互联网架构设计演进原因(0->0.5->1)

- 功能越来越复杂

- 数据量越来越大

- 请求越来越密集

- 业务迭代速度越来越快  MVP

- 服务规模越来越庞大   KPI  SLA


## 架构设计的本质：

-  不管什么样的技术架构，能够使业务产品快速迭代，持续交互才是王道。 
-   降本提效
  -   降低人力与机器成本
  -  提高开发、测试、运维效率
  -  为什么不用单体而使用微服务目的就是快速迭代与快速交付
-   业务越来越多，数据量越来越大，用户体验度越来越高 ，对架构带来了很大的挑战 
  -   因此 ，架构演进由需求驱动。

## 架构演进：核心【分而治之】

- 单体架构(monoliths)

- 水平分层架构(Horizontal layered)

- 
  集群架构(Cluster Architecture)

- 面向服务架构(Service Oriented Architecture)
  - 技术通信模式：
    - 单服务总线

- 微服务架构(MicroServices)
  -  技术通信模式：
    -   P2P模式

- 服务网格架构(Service Mesh)
  -   isito
-   服务化架构(ServerLess)
  -   (技术下沉)  事件  (事件数据)



## 传统架构存在的问题与痛点

### 单体架构1.0版本

 ![](http://cdn.luluwanlong.cn/architecture-process-12.png) 

 

### 单体架构2.0版本

 ![](http://cdn.luluwanlong.cn/architecture-process-13.png) 

 

#### 单体实体适应产品

-  初期产品全部适合


#### 初期单体的优势

- 开发简单

- 测试流程与环境简单

- 手动部署或简单脚本部署

- 整体伸缩容易

- 问题跟踪快速

- 问题修复高效

- 业务拆分分包

- 业务调用直接

- 等等


### 传统架构痛点

####  常规痛点

-  复杂应用的开发维护成本变高，部署效率主键降低
-   团队协作效率差，公共模块功能重复开发
-  系统可靠性变差
  - 内存泄露
  - 访问量逐渐攀升
  - 网路流量，负载均衡数据库连接都面临巨大压力，导致服务宕机
-  维护与定制困难(业务代码不断膨胀，功能越来越复杂)
-  新功能上线周期变长
  -  公共API变更导致策略工作量剧增
  -  新特性无法独立部署和交付

#### 后期单体的弊端

-  代码重复量高
-  需求变更困难
-  代码维护难度高
-  部署效率低
-  新需求上线周期长
-  技术选型单一
-  系统耦合性高
-  开发效率越来越低

-  性能痛点
  -  访问量
  -  数据量
  -  扩充方式
  -  级联故障
  -  复用难
  -  业务无法快速响应

### 单体架构设计与业务分析

 ![](http://cdn.luluwanlong.cn/architecture-process-14.png) 



对于这样一个系统，随着使用产品的用户越来越多，网站的流量会增加，最终单台服务器无法处理那么 大的流量，此时就需要用分而治之的思想来解决问题

 

#### 总结：专业的事交给专业的人来做：分而治之



### 抗流思路：

- 首先尝试通过简单扩容来解决
- 其次通过物理垂直扩容，  CPU32核提升CPU64核，内存64GB升级到256GB，随机读写量从HDD 升级到SSD 或通过RAID卡 来提升吞吐量，网卡百兆提升千兆或万兆。

- 水平扩容(大颗粒),搞不定，就需要水平拆分数据/应用来提升系统的伸缩性




### 单体架构3.0版本

内存使用偏移比较严重



 ![](http://cdn.luluwanlong.cn/architecture-process-15.png) 

 

 

### 优异性选择对比

#### 异步快 还是 同步快

-  如果同步调用的RT比较低，那么该情况下比异步性能更高
  - 异步消耗更多的内存 与 CPU  (线程，切换)
  - 异步解决 单线程业务处理中所带来的Block (堵塞)问题
    -   Redis访问
      -  切换线程走异步

#### 单体快  (小规模)   还是  集群快  (中型规模)   或是  微服务快(大型规模)

-  业务面积的大小，所带来的服务规模大小
-  假设：在单体中能够解决业务性能问题的条件下，单体架构比其他任何架构都要快。 
-  案例：  ArrayList快  还是  Hadoop快

#### 结论：规模化 损耗 与 规模化 收益之间的权衡



## 水平分层架构设计与业务分析

针对单体架构，如何二次提升（大颗粒资源浪费）

### 架构层：

#### 垂直方向拆分

-  用户、交易、商品、库存、积分、促销 等等

#### 水平方向拆分

- 网关层
- web服务层（偏业务，技术实现 nginx+lua） rcp 方式调用业务逻辑层的服务
- 业务逻辑层 (c,go ,pytho,java,php etc)
- 数据访问层 
  - UC（用户中心数据处理模块）
    - mysql , redis , hbase etc
  - 持久化层（通过驱动的方式进行调用）
- 不同服务由独立进程管理
  - 性能层面的划分
    - 服务读写分离
      - UC读服务
      - UC写服务

#### 按照职责进行水平划分

- 网关层
  - 认证和安全
  - 性能监测
  - 动态路由
  - 负载分配
- Web层
  - 业务数据组织
  - 视图内容转换
- 业务层
  - 业务逻辑判断
    - 只负责业务数据的处理
    - 不关系业务数据的来源，对业务数据来源进行透明化 ( 责任链模式 )
- 数据访问层
  - CRUD
    - 自动增加条件不会增加接口（Mapper）
    - 单\批处理 
      - --------提升协议数据的交互流程 ， 提高了持久层的吞吐量 可选题，编程题(自己使用socket解析http协议，上传文件，不采用buffffer,写入磁盘)
  - ORM（实体关系映射）
    - hibernate\mybatis\ibatis\（**在业务框架层面**，必须将技术层面的标准透明化）
      - 抽象工厂模式，来透明化持久层框架的能力
  - 屏蔽底层存储差异性
    - db2\mysql\sqlserver\hbase\mongodb
    - memcache\redis\etc

#### 数据库层：

- 垂直拆分(分库)
- 水平拆分(分表)

- 技术产品：  mycat , sharding jdbc  ( PROXY)


### 分层设计原理图

 ![](http://cdn.luluwanlong.cn/architecture-process-16.png) 



### 解决垂直架构问题

- 将**核心业务**抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速地响应多变的市场需求
  - 隔离性的特征来保障核心服务的稳定性
- 将公共API抽取出来，作为独立的公共服务提供其他调用者消费，以实现服务的共享与重用，降低开发与维护成本
- 应用**拆分之后按照模块**独立部署，接口调用由本地API演进成跨进程的远程访问访问，这就是RPC框架应运而生。
- REST API : Rest 仅仅是一个接口资源风格，依赖于HTTP协议进行通信 ，只是丰富利用了Method多样性的类型方式
  - Rest 资源定位不明确 ，不同的工程师对同一个资源具有不同风格的命名方式
    - url 
  - Product 接口类
    - getProduct方法
    - insertProduct方法
    - deleteProduct方法
    - updateProduct方法
- RPC 与 HTTP公有协议的差异性是什么？
  - **RPC** 简单，因为之为远程方法调用而产生的协议
    - 接口名，方法名，参数，版本，组
    - http://www.solomonall.com/product/getproduct/1
      - web服务平台



 ![](http://cdn.luluwanlong.cn/architecture-process-17.png) 

 

### 同步架构与异步架构

![](http://cdn.luluwanlong.cn/architecture-process-18.png) 

 

用户获取一个产品信息，是否可以使用异步架构来进行实现？

- 可以，但是存在资源消耗(Block ,timeout) **Future** get 堵塞 ，需要消耗一定的内存。
- 结论：需要立马获取结果的环境，则不建议使用异步化的技术

#### **异步调用**

##### 目标

将请求操作缓存慢慢消化,返回客户一个假设状态，增加系统的吞吐量 ，高并发场景下使用。

手段：MQ(性能高) \ DB(效率低) \Memcache(性能最高，但是不安全)

- 对比：
  - DB：随机写，效率低
  - MQ：顺序写（append操作），性能高

##### 问题

- 请求路径过长
- 响应时间变高
- 定位问题复杂化
- 运维成本变高
- 粗颗粒

##### 层级划分

- 网关层
- 业务逻辑层
- 数据访问层
- 数据存储层

#### **同步调用**

- 手段：直接远程调用
  - rpc\rest\rmi
- 层级划分
  - 网关层
  - 异步消息队列层
  - 业务逻辑层
  - 数据访问层
  - 数据存储层

### 水平架构整体图

 

 ![](http://cdn.luluwanlong.cn/architecture-process-19.png) 





## SOA面向服务架构设计与业务分析

#### SOA定义

- SOA是一种粗颗粒，松耦合的**以服务为中心的架构**，接口之间通过定义明确的协议和接口进行通信
- SOA解决问题
  - 帮助企业架构师以更迅速、可靠和可重用的形式规划整个业务系统，相比传统非服务化架构，SOA更加从容地应对复杂企**业系统集成** 和 需求的快速变化
- 组建模型（服务模块化，应用系统中的某个功能 或者 整体能力）
- 不同功能单元（服务）通过定义的良好接口关联（不同类型的消息适配器）
- 接口采用中立的方式定义，独立于硬件平台、操作系统和编程语言（SOAP&WSDL&XML通用语言）
- SOA支持协议类型为：
  - HTTP
  - REST API
  - JMS
  - TCP SOCKET
  - EJB
  - COM/DCOM
  - WebService为什么需要这么多的协议支持？
    - 大公司存在不同的技术栈
      - C C++ PHP JAVA GO ELANGE PYTHON ETC.
    - 不同的协议 具有特定场景的优势。
- 早期服务调用方式
  - 早期的服务外放方式仅仅为HTTP 请求 rest api
    - http://ip:port/source
    - URLConnection
    - HttpClients
  - WebService :场景 服务外放 ， WSDL (web 服务定义语言)
    - 音乐平台的曲库外放
    - 对接的优势：
      - 通过接口签名的方式进行调用，而不需要知道具体的服务在什么地方
    - 只适合小规模形式的调用
    - WSDL 定义了一份 接口 ，方法 ，参数 等相关信息。
      - <method name ="" args=""
    - 不适合定义N个平台的部分功能
      - 曲艺人： 希望访问曲艺人的服务节点（192.168.1.2）
      - 曲库：希望访问曲库服务节点（192.168.1.3）



### SOA架构图

#### 业务结构

 ![](http://cdn.luluwanlong.cn/architecture-process-20.png) 



#### 框架结构



![](http://cdn.luluwanlong.cn/architecture-process-21.png) 

路由器类别：（责任链模式）

- 前置路由器
  - 幂等路由器
    - 防止重复消息消费
  - 条件路由器
    - 过滤符合本业务组件的消息
  - 聚合路由器
  - 排序路由器
  - 转发路由器
- 后置路由器
  - 过滤路由器
    - 为一个组件配置多个过滤路由器，各自路由器可根据自己的业务规则进行过滤，判断消息内容是否通过本路由器进行转发。
  - 多播路由器
    - 将消息转发给多个不同的目标地址。
  - 消息分割路由器
  - 等等

SOA外放处理的服务一定是WEB层的类型的。



### SOA架构特点

- 目标
  - **重用已有的IT资产**，对不同的异构服务进行灵活互通
- 实现手段
  - 消息适配器
  - 消息路由器
  - 应用或业务组件
- 拆分方式：
  - 垂直拆分

### SOA缺点

- 业务垂直方向拆分 ，每个服务还是一个单体，颗粒度比较大

- 严重依赖ESB总线




## 微服务架构设计与业务分析                               [ ](af://n736)

**微服务架构特点(P2P模式) RPC Channel(p2p) 分库，分表 （物理层分割，带来的性能提升）**

 

 

![](http://cdn.luluwanlong.cn/architecture-process-22.png) 

 

 ![](http://cdn.luluwanlong.cn/architecture-process-23.png) 

 

### 架构特点：

- 微服务架构仅仅是一种**架构风格**
- 将单个应用程序开发为**一组小型服务**的方法
- 每个服务都在**自己的进程**中运行
- 并使用轻量级机制（通常是http API \ RPC \RMI）通信这些服务是围绕业务**能力域**构建的
- 可以通过完全自动化的部署机制进行独立部署
- 这些服务的集中管理是最低限度的
- 这些服务可以用不同的编程语言编写并使用不同的数据存储 ， **GO**
- 微服务主要特征
  - 原子服务
    - 专注一件事、功能越单一，对其他功能的依赖就越少（减少服务网络关系，高内聚，松耦合）
  - 高密度部署
    - 重要服务可以独立部署，非核心服务可以独立打包，合设到同一个进程中，服务被高密度部署
    - 服务部署，一台服务器可以部署多个服务实例进程

 

![](http://cdn.luluwanlong.cn/architecture-process-24.png) 

![](http://cdn.luluwanlong.cn/architecture-process-25.png) 

- 敏捷交付
  - 服务由小研发团队负责设计、开发、测试、部署、线上治理、灰度发布和下线、运维整个生命周期支撑，实现真正的DevOps

![](http://cdn.luluwanlong.cn/architecture-process-26.png) 

 

![](http://cdn.luluwanlong.cn/architecture-process-27.png) 

 

- 微自治
  - 服务足够小，功能单一，可以独立开发、打包、部署、升级、回滚和弹性伸缩。
  - 不依赖其他服务（与不调用是两回事），实现局部自治
  - 微服务之前



![](http://cdn.luluwanlong.cn/architecture-process-28.png) 

-  微服务之后


![](http://cdn.luluwanlong.cn/architecture-process-29.png) 

 



### **拆分方式：**

- 水平拆分，收编通用与公共服务，并形成独立而稳定的服务
- 垂直拆分，划分成独立的业务或功能域，避免能力域之间的交差性，而达到自治的特性

### **适应场景：**

- 业务变化频率高，需要快速试错，持续交互，缩短业务或产品发布周期
- 需要高吞吐量的扩容伸缩架构（小颗粒服务更具弹性化，架构性能消耗/整体请求估值<=1%）
  - 平均响应时延增高
- 最终一致性场景，来保证高的请求吞吐量，否则强一致性拉低整体服务吞吐量。

### **目的：**

- 项目快速迭代
- 项目持续交付
- 降本提效

![](http://cdn.luluwanlong.cn/architecture-process-30.png) 

 

 

![](http://cdn.luluwanlong.cn/architecture-process-31.png) 

 

## 微服务框架演进

- 业务团队只专注于业务逻辑本身基础设施由基础研发团队负责

- 基础设施能力从应用程序中往下推

- 一套基础设施支持多语言开发

- 解耦业务团队与基础团队

- 满足现今的快速迭代与快速试错、可持续性交付

  ​															 Dubbo框架应用

业务服务肯定是一个进程（JAR）【192.168.1.2】， 技术支撑进程 【192.168.1.3】

dubbo 轻量级 SDK 														dubbo 重量级JAR（SDK）服务

Dubbo 应用层 ServiceReference 								Dubbo支撑层(服务发现)

cn.com.solomon.Product->ProductProxy

![](http://cdn.luluwanlong.cn/architecture-process-32.png) 



## 服务网格设计

- 服务网格是一种基础设施层，用于处理服务间的通信
- 云原生应用有着复杂的服务拓扑，服务网格负责在这些拓扑中实现请求的可靠传递
- 在实践中，服务网格通常实现为一组轻量级网格代理，他们与应用程序部署在一起，而对应用透明

### ServiceMesh 架构

![](http://cdn.luluwanlong.cn/architecture-process-33.png) 

 

### ServiceMesh优点

- ServiceMesh 独立进程、独立升级

- 业务团队专注于业务本身

- 一套基础设施支持多语言开发

- 业务团队和基础设施团队解耦

- 如何考量服务间通信的性能




### **如何考量服务间通信的性能**

- 协议的选型 
  - 大文件传输
    - http 
    - ftp 
- 同步还是异步
- 长连接或短连接
  - 长连接
    - 传输数据具有持续性
  - 短连接 
    - 传输频率低 
    - 服务能力QPS为1000QPS 业务请求QPS为200-500
- NIO还是BIO
- 私有协议还是公有协议
  - QQ IM通信协议
    - 属于UDP协议改进

## 服务间的负载均衡设计

### **什么是负载均衡**

负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带

宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性

### **负载均衡分类**

- 硬件负载
  - F5\A10\RadWare
- 软件负载
  - LVS(4层) 
  - HAProxy(4层或7层)
  - NGINX（4层或7层）
    - 反向代理
    - 负载均衡算法
    - 随机
    - 轮询
    - 最少连接数
    - 最少时延
    - hash
    - 一致性hash
    - 权重
- 负载均衡的高可靠
  - 服务故障自动发现
    - zk\consul\etcd\nacos
  - 故障服务自动剔除
  - 服务恢复自动发现服务假死，自动重试策略
    - 熔断机制（sentinel，异常次数或者比率）

### SLB负载均衡




![](http://cdn.luluwanlong.cn/architecture-process-34.png) 

#### SLB内部实现原理

![](http://cdn.luluwanlong.cn/architecture-process-35.png) 

#### 入网流量路径

![](http://cdn.luluwanlong.cn/architecture-process-36.png) 



## 服务的无状态化设计

### **什么是无状态**

在集群对等的服务中，请求提交到任意服务，处理结果完全一样，服务不存储业务上下文信息，仅根据

请求携带的数据进行业务逻辑处理。

### **无状态核心思考点**

- 上下文数据
  - 数据存储任何地方都可以，但是所有服务对应的数据是一致的。
- 服务之间数据一致性操作方式
  - 流量方式
    - 服务与服务之间数据同步
    - 数据存放客户端，传递给执行的服务，过期或清空容易丢失
  - 外部容器
    - 外部缓存容器（Redis/Memcache)

### **无状态案例**

- 用户登录Session数据

## 如何设计高可用架构

### **什么是高可用**

高可用性（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服

务的高度可用性，通常服务为7*24小时运行，无论何时何地都能提供有效的服务请求。

### **导致服务不可靠的因素**

- 硬件生命周期
  - 服务器
  - 交换机&路由器
  - 组网方式
  - 存储设备
- 软件不可靠
  - 业务BUG
  - 架构BUG
  - 关键关联性BUG

### **高可靠的评估方式**

假设一台服务器的宕机概率为0.1% ,那么通常物理架构中采用3台服务设备同时宕机的概率则为0.001% ,

则可用性为99.999% 。

宕机时间计算：（宕机时间/总时间） 或 一段时间的占比 (停机时间影响请求数/总的请求数)

- 2个9 (全年不超过88H)
- 3个9 (全年不超过9H)
- 4个9 (全年不超过53M)
- 5个9 (全年不超过6M)
- 6个9 (全年不超过30S)

### **高可用设计手段**

- 服务层面
  - 服务冗余（无状态化，满足服务对等能力，可伸缩）
  - 负载均衡（幂等设计，满足数据一致性)
  - 超时机制（确保服务访问可靠）
  - 异步化机制（提高服务吞度量）
  - 限流、降级、熔断（保证服务可用性）
- 数据层面
  - 数据热双备 （ 数据高可靠 ）
  - 缓存、多级缓存 （ 加速请求响应）
  - Sharding ( 减少速度处理时间 )
- 架构设计层面
  - 业务拆分独立服务域，细颗粒化，符合服务微自治特性（服务快速伸缩）



